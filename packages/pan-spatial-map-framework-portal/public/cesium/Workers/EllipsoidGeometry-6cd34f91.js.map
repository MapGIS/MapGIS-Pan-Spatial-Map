{"version":3,"file":"EllipsoidGeometry-6cd34f91.js","sources":["../../../../Source/Core/EllipsoidGeometry.js"],"sourcesContent":["import arrayFill from './arrayFill.js';\r\nimport BoundingSphere from './BoundingSphere.js';\r\nimport Cartesian2 from './Cartesian2.js';\r\nimport Cartesian3 from './Cartesian3.js';\r\nimport ComponentDatatype from './ComponentDatatype.js';\r\nimport defaultValue from './defaultValue.js';\r\nimport defined from './defined.js';\r\nimport DeveloperError from './DeveloperError.js';\r\nimport Ellipsoid from './Ellipsoid.js';\r\nimport Geometry from './Geometry.js';\r\nimport GeometryAttribute from './GeometryAttribute.js';\r\nimport GeometryAttributes from './GeometryAttributes.js';\r\nimport GeometryOffsetAttribute from './GeometryOffsetAttribute.js';\r\nimport IndexDatatype from './IndexDatatype.js';\r\nimport CesiumMath from './Math.js';\r\nimport PrimitiveType from './PrimitiveType.js';\r\nimport VertexFormat from './VertexFormat.js';\r\n\r\nvar scratchPosition = new Cartesian3();\r\nvar scratchNormal = new Cartesian3();\r\nvar scratchTangent = new Cartesian3();\r\nvar scratchBitangent = new Cartesian3();\r\nvar scratchNormalST = new Cartesian3();\r\nvar defaultRadii = new Cartesian3(1.0, 1.0, 1.0);\r\n\r\nvar cos = Math.cos;\r\nvar sin = Math.sin;\r\n\r\n/**\r\n * A description of an ellipsoid centered at the origin.\r\n *\r\n * @alias EllipsoidGeometry\r\n * @constructor\r\n *\r\n * @param {Object} [options] Object with the following properties:\r\n * @param {Cartesian3} [options.radii=Cartesian3(1.0, 1.0, 1.0)] The radii of the ellipsoid in the x, y, and z directions.\r\n * @param {Cartesian3} [options.innerRadii=options.radii] The inner radii of the ellipsoid in the x, y, and z directions.\r\n * @param {Number} [options.minimumClock=0.0] The minimum angle lying in the xy-plane measured from the positive x-axis and toward the positive y-axis.\r\n * @param {Number} [options.maximumClock=2*PI] The maximum angle lying in the xy-plane measured from the positive x-axis and toward the positive y-axis.\r\n * @param {Number} [options.minimumCone=0.0] The minimum angle measured from the positive z-axis and toward the negative z-axis.\r\n * @param {Number} [options.maximumCone=PI] The maximum angle measured from the positive z-axis and toward the negative z-axis.\r\n * @param {Number} [options.stackPartitions=64] The number of times to partition the ellipsoid into stacks.\r\n * @param {Number} [options.slicePartitions=64] The number of times to partition the ellipsoid into radial slices.\r\n * @param {VertexFormat} [options.vertexFormat=VertexFormat.DEFAULT] The vertex attributes to be computed.\r\n *\r\n * @exception {DeveloperError} options.slicePartitions cannot be less than three.\r\n * @exception {DeveloperError} options.stackPartitions cannot be less than three.\r\n *\r\n * @see EllipsoidGeometry#createGeometry\r\n *\r\n * @example\r\n * var ellipsoid = new Cesium.EllipsoidGeometry({\r\n *   vertexFormat : Cesium.VertexFormat.POSITION_ONLY,\r\n *   radii : new Cesium.Cartesian3(1000000.0, 500000.0, 500000.0)\r\n * });\r\n * var geometry = Cesium.EllipsoidGeometry.createGeometry(ellipsoid);\r\n */\r\nfunction EllipsoidGeometry(options) {\r\n    options = defaultValue(options, defaultValue.EMPTY_OBJECT);\r\n\r\n    var radii = defaultValue(options.radii, defaultRadii);\r\n    var innerRadii = defaultValue(options.innerRadii, radii);\r\n    var minimumClock = defaultValue(options.minimumClock, 0.0);\r\n    var maximumClock = defaultValue(options.maximumClock, CesiumMath.TWO_PI);\r\n    var minimumCone = defaultValue(options.minimumCone, 0.0);\r\n    var maximumCone = defaultValue(options.maximumCone, CesiumMath.PI);\r\n    var stackPartitions = Math.round(defaultValue(options.stackPartitions, 64));\r\n    var slicePartitions = Math.round(defaultValue(options.slicePartitions, 64));\r\n    var vertexFormat = defaultValue(options.vertexFormat, VertexFormat.DEFAULT);\r\n\r\n    //>>includeStart('debug', pragmas.debug);\r\n    if (slicePartitions < 3) {\r\n        throw new DeveloperError('options.slicePartitions cannot be less than three.');\r\n    }\r\n    if (stackPartitions < 3) {\r\n        throw new DeveloperError('options.stackPartitions cannot be less than three.');\r\n    }\r\n    //>>includeEnd('debug');\r\n\r\n    this._radii = Cartesian3.clone(radii);\r\n    this._innerRadii = Cartesian3.clone(innerRadii);\r\n    this._minimumClock = minimumClock;\r\n    this._maximumClock = maximumClock;\r\n    this._minimumCone = minimumCone;\r\n    this._maximumCone = maximumCone;\r\n    this._stackPartitions = stackPartitions;\r\n    this._slicePartitions = slicePartitions;\r\n    this._vertexFormat = VertexFormat.clone(vertexFormat);\r\n    this._offsetAttribute = options.offsetAttribute;\r\n    this._workerName = 'createEllipsoidGeometry';\r\n}\r\n\r\n/**\r\n * The number of elements used to pack the object into an array.\r\n * @type {Number}\r\n */\r\nEllipsoidGeometry.packedLength = 2 * Cartesian3.packedLength + VertexFormat.packedLength + 7;\r\n\r\n/**\r\n * Stores the provided instance into the provided array.\r\n *\r\n * @param {EllipsoidGeometry} value The value to pack.\r\n * @param {Number[]} array The array to pack into.\r\n * @param {Number} [startingIndex=0] The index into the array at which to start packing the elements.\r\n *\r\n * @returns {Number[]} The array that was packed into\r\n */\r\nEllipsoidGeometry.pack = function (value, array, startingIndex) {\r\n    //>>includeStart('debug', pragmas.debug);\r\n    if (!defined(value)) {\r\n        throw new DeveloperError('value is required');\r\n    }\r\n    if (!defined(array)) {\r\n        throw new DeveloperError('array is required');\r\n    }\r\n    //>>includeEnd('debug');\r\n\r\n    startingIndex = defaultValue(startingIndex, 0);\r\n\r\n    Cartesian3.pack(value._radii, array, startingIndex);\r\n    startingIndex += Cartesian3.packedLength;\r\n\r\n    Cartesian3.pack(value._innerRadii, array, startingIndex);\r\n    startingIndex += Cartesian3.packedLength;\r\n\r\n    VertexFormat.pack(value._vertexFormat, array, startingIndex);\r\n    startingIndex += VertexFormat.packedLength;\r\n\r\n    array[startingIndex++] = value._minimumClock;\r\n    array[startingIndex++] = value._maximumClock;\r\n    array[startingIndex++] = value._minimumCone;\r\n    array[startingIndex++] = value._maximumCone;\r\n    array[startingIndex++] = value._stackPartitions;\r\n    array[startingIndex++] = value._slicePartitions;\r\n    array[startingIndex] = defaultValue(value._offsetAttribute, -1);\r\n\r\n    return array;\r\n};\r\n\r\nvar scratchRadii = new Cartesian3();\r\nvar scratchInnerRadii = new Cartesian3();\r\nvar scratchVertexFormat = new VertexFormat();\r\nvar scratchOptions = {\r\n    radii: scratchRadii,\r\n    innerRadii: scratchInnerRadii,\r\n    vertexFormat: scratchVertexFormat,\r\n    minimumClock: undefined,\r\n    maximumClock: undefined,\r\n    minimumCone: undefined,\r\n    maximumCone: undefined,\r\n    stackPartitions: undefined,\r\n    slicePartitions: undefined,\r\n    offsetAttribute: undefined\r\n};\r\n\r\n/**\r\n * Retrieves an instance from a packed array.\r\n *\r\n * @param {Number[]} array The packed array.\r\n * @param {Number} [startingIndex=0] The starting index of the element to be unpacked.\r\n * @param {EllipsoidGeometry} [result] The object into which to store the result.\r\n * @returns {EllipsoidGeometry} The modified result parameter or a new EllipsoidGeometry instance if one was not provided.\r\n */\r\nEllipsoidGeometry.unpack = function (array, startingIndex, result) {\r\n    //>>includeStart('debug', pragmas.debug);\r\n    if (!defined(array)) {\r\n        throw new DeveloperError('array is required');\r\n    }\r\n    //>>includeEnd('debug');\r\n\r\n    startingIndex = defaultValue(startingIndex, 0);\r\n\r\n    var radii = Cartesian3.unpack(array, startingIndex, scratchRadii);\r\n    startingIndex += Cartesian3.packedLength;\r\n\r\n    var innerRadii = Cartesian3.unpack(array, startingIndex, scratchInnerRadii);\r\n    startingIndex += Cartesian3.packedLength;\r\n\r\n    var vertexFormat = VertexFormat.unpack(array, startingIndex, scratchVertexFormat);\r\n    startingIndex += VertexFormat.packedLength;\r\n\r\n    var minimumClock = array[startingIndex++];\r\n    var maximumClock = array[startingIndex++];\r\n    var minimumCone = array[startingIndex++];\r\n    var maximumCone = array[startingIndex++];\r\n    var stackPartitions = array[startingIndex++];\r\n    var slicePartitions = array[startingIndex++];\r\n    var offsetAttribute = array[startingIndex];\r\n\r\n    if (!defined(result)) {\r\n        scratchOptions.minimumClock = minimumClock;\r\n        scratchOptions.maximumClock = maximumClock;\r\n        scratchOptions.minimumCone = minimumCone;\r\n        scratchOptions.maximumCone = maximumCone;\r\n        scratchOptions.stackPartitions = stackPartitions;\r\n        scratchOptions.slicePartitions = slicePartitions;\r\n        scratchOptions.offsetAttribute = offsetAttribute === -1 ? undefined : offsetAttribute;\r\n        return new EllipsoidGeometry(scratchOptions);\r\n    }\r\n\r\n    result._radii = Cartesian3.clone(radii, result._radii);\r\n    result._innerRadii = Cartesian3.clone(innerRadii, result._innerRadii);\r\n    result._vertexFormat = VertexFormat.clone(vertexFormat, result._vertexFormat);\r\n    result._minimumClock = minimumClock;\r\n    result._maximumClock = maximumClock;\r\n    result._minimumCone = minimumCone;\r\n    result._maximumCone = maximumCone;\r\n    result._stackPartitions = stackPartitions;\r\n    result._slicePartitions = slicePartitions;\r\n    result._offsetAttribute = offsetAttribute === -1 ? undefined : offsetAttribute;\r\n\r\n    return result;\r\n};\r\n\r\n/**\r\n * Computes the geometric representation of an ellipsoid, including its vertices, indices, and a bounding sphere.\r\n *\r\n * @param {EllipsoidGeometry} ellipsoidGeometry A description of the ellipsoid.\r\n * @returns {Geometry|undefined} The computed vertices and indices.\r\n */\r\nEllipsoidGeometry.createGeometry = function (ellipsoidGeometry) {\r\n    var radii = ellipsoidGeometry._radii;\r\n    if (radii.x <= 0 || radii.y <= 0 || radii.z <= 0) {\r\n        return;\r\n    }\r\n\r\n    var innerRadii = ellipsoidGeometry._innerRadii;\r\n    if (innerRadii.x <= 0 || innerRadii.y <= 0 || innerRadii.z <= 0) {\r\n        return;\r\n    }\r\n\r\n    var minimumClock = ellipsoidGeometry._minimumClock;\r\n    var maximumClock = ellipsoidGeometry._maximumClock;\r\n    var minimumCone = ellipsoidGeometry._minimumCone;\r\n    var maximumCone = ellipsoidGeometry._maximumCone;\r\n    var vertexFormat = ellipsoidGeometry._vertexFormat;\r\n\r\n    // Add an extra slice and stack so that the number of partitions is the\r\n    // number of surfaces rather than the number of joints\r\n    var slicePartitions = ellipsoidGeometry._slicePartitions + 1;\r\n    var stackPartitions = ellipsoidGeometry._stackPartitions + 1;\r\n\r\n    slicePartitions = Math.round((slicePartitions * Math.abs(maximumClock - minimumClock)) / CesiumMath.TWO_PI);\r\n    stackPartitions = Math.round((stackPartitions * Math.abs(maximumCone - minimumCone)) / CesiumMath.PI);\r\n\r\n    if (slicePartitions < 2) {\r\n        slicePartitions = 2;\r\n    }\r\n    if (stackPartitions < 2) {\r\n        stackPartitions = 2;\r\n    }\r\n\r\n    var i;\r\n    var j;\r\n    var index = 0;\r\n\r\n    // Create arrays for theta and phi. Duplicate first and last angle to\r\n    // allow different normals at the intersections.\r\n    var phis = [minimumCone];\r\n    var thetas = [minimumClock];\r\n    for (i = 0; i < stackPartitions; i++) {\r\n        phis.push(minimumCone + (i * (maximumCone - minimumCone)) / (stackPartitions - 1));\r\n    }\r\n    phis.push(maximumCone);\r\n    for (j = 0; j < slicePartitions; j++) {\r\n        thetas.push(minimumClock + (j * (maximumClock - minimumClock)) / (slicePartitions - 1));\r\n    }\r\n    thetas.push(maximumClock);\r\n    var numPhis = phis.length;\r\n    var numThetas = thetas.length;\r\n\r\n    // Allow for extra indices if there is an inner surface and if we need\r\n    // to close the sides if the clock range is not a full circle\r\n    var extraIndices = 0;\r\n    var vertexMultiplier = 1.0;\r\n    var hasInnerSurface = innerRadii.x !== radii.x || innerRadii.y !== radii.y || innerRadii.z !== radii.z;\r\n    var isTopOpen = false;\r\n    var isBotOpen = false;\r\n    var isClockOpen = false;\r\n    if (hasInnerSurface) {\r\n        vertexMultiplier = 2.0;\r\n        if (minimumCone > 0.0) {\r\n            isTopOpen = true;\r\n            extraIndices += slicePartitions - 1;\r\n        }\r\n        if (maximumCone < Math.PI) {\r\n            isBotOpen = true;\r\n            extraIndices += slicePartitions - 1;\r\n        }\r\n        if ((maximumClock - minimumClock) % CesiumMath.TWO_PI) {\r\n            isClockOpen = true;\r\n            extraIndices += (stackPartitions - 1) * 2 + 1;\r\n        } else {\r\n            extraIndices += 1;\r\n        }\r\n    }\r\n\r\n    var vertexCount = numThetas * numPhis * vertexMultiplier;\r\n    var positions = new Float64Array(vertexCount * 3);\r\n    var isInner = arrayFill(new Array(vertexCount), false);\r\n    var negateNormal = arrayFill(new Array(vertexCount), false);\r\n\r\n    // Multiply by 6 because there are two triangles per sector\r\n    var indexCount = slicePartitions * stackPartitions * vertexMultiplier;\r\n    var numIndices = 6 * (indexCount + extraIndices + 1 - (slicePartitions + stackPartitions) * vertexMultiplier);\r\n    var indices = IndexDatatype.createTypedArray(indexCount, numIndices);\r\n\r\n    var normals = vertexFormat.normal ? new Float32Array(vertexCount * 3) : undefined;\r\n    var tangents = vertexFormat.tangent ? new Float32Array(vertexCount * 3) : undefined;\r\n    var bitangents = vertexFormat.bitangent ? new Float32Array(vertexCount * 3) : undefined;\r\n    var st = vertexFormat.st ? new Float32Array(vertexCount * 2) : undefined;\r\n\r\n    // Calculate sin/cos phi\r\n    var sinPhi = new Array(numPhis);\r\n    var cosPhi = new Array(numPhis);\r\n    for (i = 0; i < numPhis; i++) {\r\n        sinPhi[i] = sin(phis[i]);\r\n        cosPhi[i] = cos(phis[i]);\r\n    }\r\n\r\n    // Calculate sin/cos theta\r\n    var sinTheta = new Array(numThetas);\r\n    var cosTheta = new Array(numThetas);\r\n    for (j = 0; j < numThetas; j++) {\r\n        cosTheta[j] = cos(thetas[j]);\r\n        sinTheta[j] = sin(thetas[j]);\r\n    }\r\n\r\n    // Create outer surface\r\n    for (i = 0; i < numPhis; i++) {\r\n        for (j = 0; j < numThetas; j++) {\r\n            positions[index++] = radii.x * sinPhi[i] * cosTheta[j];\r\n            positions[index++] = radii.y * sinPhi[i] * sinTheta[j];\r\n            positions[index++] = radii.z * cosPhi[i];\r\n        }\r\n    }\r\n\r\n    // Create inner surface\r\n    var vertexIndex = vertexCount / 2.0;\r\n    if (hasInnerSurface) {\r\n        for (i = 0; i < numPhis; i++) {\r\n            for (j = 0; j < numThetas; j++) {\r\n                positions[index++] = innerRadii.x * sinPhi[i] * cosTheta[j];\r\n                positions[index++] = innerRadii.y * sinPhi[i] * sinTheta[j];\r\n                positions[index++] = innerRadii.z * cosPhi[i];\r\n\r\n                // Keep track of which vertices are the inner and which ones\r\n                // need the normal to be negated\r\n                isInner[vertexIndex] = true;\r\n                if (i > 0 && i !== numPhis - 1 && j !== 0 && j !== numThetas - 1) {\r\n                    negateNormal[vertexIndex] = true;\r\n                }\r\n                vertexIndex++;\r\n            }\r\n        }\r\n    }\r\n\r\n    // Create indices for outer surface\r\n    index = 0;\r\n    var topOffset;\r\n    var bottomOffset;\r\n    for (i = 1; i < numPhis - 2; i++) {\r\n        topOffset = i * numThetas;\r\n        bottomOffset = (i + 1) * numThetas;\r\n\r\n        for (j = 1; j < numThetas - 2; j++) {\r\n            indices[index++] = bottomOffset + j;\r\n            indices[index++] = bottomOffset + j + 1;\r\n            indices[index++] = topOffset + j + 1;\r\n\r\n            indices[index++] = bottomOffset + j;\r\n            indices[index++] = topOffset + j + 1;\r\n            indices[index++] = topOffset + j;\r\n        }\r\n    }\r\n\r\n    // Create indices for inner surface\r\n    if (hasInnerSurface) {\r\n        var offset = numPhis * numThetas;\r\n        for (i = 1; i < numPhis - 2; i++) {\r\n            topOffset = offset + i * numThetas;\r\n            bottomOffset = offset + (i + 1) * numThetas;\r\n\r\n            for (j = 1; j < numThetas - 2; j++) {\r\n                indices[index++] = bottomOffset + j;\r\n                indices[index++] = topOffset + j;\r\n                indices[index++] = topOffset + j + 1;\r\n\r\n                indices[index++] = bottomOffset + j;\r\n                indices[index++] = topOffset + j + 1;\r\n                indices[index++] = bottomOffset + j + 1;\r\n            }\r\n        }\r\n    }\r\n\r\n    var outerOffset;\r\n    var innerOffset;\r\n    if (hasInnerSurface) {\r\n        if (isTopOpen) {\r\n            // Connect the top of the inner surface to the top of the outer surface\r\n            innerOffset = numPhis * numThetas;\r\n            for (i = 1; i < numThetas - 2; i++) {\r\n                indices[index++] = i;\r\n                indices[index++] = i + 1;\r\n                indices[index++] = innerOffset + i + 1;\r\n\r\n                indices[index++] = i;\r\n                indices[index++] = innerOffset + i + 1;\r\n                indices[index++] = innerOffset + i;\r\n            }\r\n        }\r\n\r\n        if (isBotOpen) {\r\n            // Connect the bottom of the inner surface to the bottom of the outer surface\r\n            outerOffset = numPhis * numThetas - numThetas;\r\n            innerOffset = numPhis * numThetas * vertexMultiplier - numThetas;\r\n            for (i = 1; i < numThetas - 2; i++) {\r\n                indices[index++] = outerOffset + i + 1;\r\n                indices[index++] = outerOffset + i;\r\n                indices[index++] = innerOffset + i;\r\n\r\n                indices[index++] = outerOffset + i + 1;\r\n                indices[index++] = innerOffset + i;\r\n                indices[index++] = innerOffset + i + 1;\r\n            }\r\n        }\r\n    }\r\n\r\n    // Connect the edges if clock is not closed\r\n    if (isClockOpen) {\r\n        for (i = 1; i < numPhis - 2; i++) {\r\n            innerOffset = numThetas * numPhis + numThetas * i;\r\n            outerOffset = numThetas * i;\r\n            indices[index++] = innerOffset;\r\n            indices[index++] = outerOffset + numThetas;\r\n            indices[index++] = outerOffset;\r\n\r\n            indices[index++] = innerOffset;\r\n            indices[index++] = innerOffset + numThetas;\r\n            indices[index++] = outerOffset + numThetas;\r\n        }\r\n\r\n        for (i = 1; i < numPhis - 2; i++) {\r\n            innerOffset = numThetas * numPhis + numThetas * (i + 1) - 1;\r\n            outerOffset = numThetas * (i + 1) - 1;\r\n            indices[index++] = outerOffset + numThetas;\r\n            indices[index++] = innerOffset;\r\n            indices[index++] = outerOffset;\r\n\r\n            indices[index++] = outerOffset + numThetas;\r\n            indices[index++] = innerOffset + numThetas;\r\n            indices[index++] = innerOffset;\r\n        }\r\n    }\r\n\r\n    var attributes = new GeometryAttributes();\r\n\r\n    if (vertexFormat.position) {\r\n        attributes.position = new GeometryAttribute({\r\n            componentDatatype: ComponentDatatype.DOUBLE,\r\n            componentsPerAttribute: 3,\r\n            values: positions\r\n        });\r\n    }\r\n\r\n    var stIndex = 0;\r\n    var normalIndex = 0;\r\n    var tangentIndex = 0;\r\n    var bitangentIndex = 0;\r\n    var vertexCountHalf = vertexCount / 2.0;\r\n\r\n    var ellipsoid;\r\n    var ellipsoidOuter = Ellipsoid.fromCartesian3(radii);\r\n    var ellipsoidInner = Ellipsoid.fromCartesian3(innerRadii);\r\n\r\n    if (vertexFormat.st || vertexFormat.normal || vertexFormat.tangent || vertexFormat.bitangent) {\r\n        for (i = 0; i < vertexCount; i++) {\r\n            ellipsoid = isInner[i] ? ellipsoidInner : ellipsoidOuter;\r\n            var position = Cartesian3.fromArray(positions, i * 3, scratchPosition);\r\n            var normal = ellipsoid.geodeticSurfaceNormal(position, scratchNormal);\r\n            if (negateNormal[i]) {\r\n                Cartesian3.negate(normal, normal);\r\n            }\r\n\r\n            if (vertexFormat.st) {\r\n                var normalST = Cartesian2.negate(normal, scratchNormalST);\r\n                st[stIndex++] = Math.atan2(normalST.y, normalST.x) / CesiumMath.TWO_PI + 0.5;\r\n                st[stIndex++] = Math.asin(normal.z) / Math.PI + 0.5;\r\n            }\r\n\r\n            if (vertexFormat.normal) {\r\n                normals[normalIndex++] = normal.x;\r\n                normals[normalIndex++] = normal.y;\r\n                normals[normalIndex++] = normal.z;\r\n            }\r\n\r\n            if (vertexFormat.tangent || vertexFormat.bitangent) {\r\n                var tangent = scratchTangent;\r\n\r\n                // Use UNIT_X for the poles\r\n                var tangetOffset = 0;\r\n                var unit;\r\n                if (isInner[i]) {\r\n                    tangetOffset = vertexCountHalf;\r\n                }\r\n                if (!isTopOpen && i >= tangetOffset && i < tangetOffset + numThetas * 2) {\r\n                    unit = Cartesian3.UNIT_X;\r\n                } else {\r\n                    unit = Cartesian3.UNIT_Z;\r\n                }\r\n                Cartesian3.cross(unit, normal, tangent);\r\n                Cartesian3.normalize(tangent, tangent);\r\n\r\n                if (vertexFormat.tangent) {\r\n                    tangents[tangentIndex++] = tangent.x;\r\n                    tangents[tangentIndex++] = tangent.y;\r\n                    tangents[tangentIndex++] = tangent.z;\r\n                }\r\n\r\n                if (vertexFormat.bitangent) {\r\n                    var bitangent = Cartesian3.cross(normal, tangent, scratchBitangent);\r\n                    Cartesian3.normalize(bitangent, bitangent);\r\n\r\n                    bitangents[bitangentIndex++] = bitangent.x;\r\n                    bitangents[bitangentIndex++] = bitangent.y;\r\n                    bitangents[bitangentIndex++] = bitangent.z;\r\n                }\r\n            }\r\n        }\r\n\r\n        if (vertexFormat.st) {\r\n            attributes.st = new GeometryAttribute({\r\n                componentDatatype: ComponentDatatype.FLOAT,\r\n                componentsPerAttribute: 2,\r\n                values: st\r\n            });\r\n        }\r\n\r\n        if (vertexFormat.normal) {\r\n            attributes.normal = new GeometryAttribute({\r\n                componentDatatype: ComponentDatatype.FLOAT,\r\n                componentsPerAttribute: 3,\r\n                values: normals\r\n            });\r\n        }\r\n\r\n        if (vertexFormat.tangent) {\r\n            attributes.tangent = new GeometryAttribute({\r\n                componentDatatype: ComponentDatatype.FLOAT,\r\n                componentsPerAttribute: 3,\r\n                values: tangents\r\n            });\r\n        }\r\n\r\n        if (vertexFormat.bitangent) {\r\n            attributes.bitangent = new GeometryAttribute({\r\n                componentDatatype: ComponentDatatype.FLOAT,\r\n                componentsPerAttribute: 3,\r\n                values: bitangents\r\n            });\r\n        }\r\n    }\r\n\r\n    if (defined(ellipsoidGeometry._offsetAttribute)) {\r\n        var length = positions.length;\r\n        var applyOffset = new Uint8Array(length / 3);\r\n        var offsetValue = ellipsoidGeometry._offsetAttribute === GeometryOffsetAttribute.NONE ? 0 : 1;\r\n        arrayFill(applyOffset, offsetValue);\r\n        attributes.applyOffset = new GeometryAttribute({\r\n            componentDatatype: ComponentDatatype.UNSIGNED_BYTE,\r\n            componentsPerAttribute: 1,\r\n            values: applyOffset\r\n        });\r\n    }\r\n\r\n    return new Geometry({\r\n        attributes: attributes,\r\n        indices: indices,\r\n        primitiveType: PrimitiveType.TRIANGLES,\r\n        boundingSphere: BoundingSphere.fromEllipsoid(ellipsoidOuter),\r\n        offsetAttribute: ellipsoidGeometry._offsetAttribute\r\n    });\r\n};\r\n\r\nvar unitEllipsoidGeometry;\r\n\r\n/**\r\n * Returns the geometric representation of a unit ellipsoid, including its vertices, indices, and a bounding sphere.\r\n * @returns {Geometry} The computed vertices and indices.\r\n *\r\n * @private\r\n */\r\nEllipsoidGeometry.getUnitEllipsoid = function () {\r\n    if (!defined(unitEllipsoidGeometry)) {\r\n        unitEllipsoidGeometry = EllipsoidGeometry.createGeometry(\r\n            new EllipsoidGeometry({\r\n                radii: new Cartesian3(1.0, 1.0, 1.0),\r\n                vertexFormat: VertexFormat.POSITION_ONLY\r\n            })\r\n        );\r\n    }\r\n    return unitEllipsoidGeometry;\r\n};\r\nexport default EllipsoidGeometry;\r\n"],"names":["Cartesian3","defaultValue","CesiumMath","VertexFormat","DeveloperError","defined","arrayFill","IndexDatatype","GeometryAttributes","GeometryAttribute","ComponentDatatype","Ellipsoid","Cartesian2","GeometryOffsetAttribute","Geometry","PrimitiveType","BoundingSphere"],"mappings":"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"}