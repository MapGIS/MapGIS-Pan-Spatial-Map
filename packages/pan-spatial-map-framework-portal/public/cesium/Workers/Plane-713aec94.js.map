{"version":3,"file":"Plane-713aec94.js","sources":["../../../../Source/Core/Plane.js"],"sourcesContent":["import Cartesian3 from './Cartesian3.js';\r\nimport Cartesian4 from './Cartesian4.js';\r\nimport Check from './Check.js';\r\nimport defined from './defined.js';\r\nimport DeveloperError from './DeveloperError.js';\r\nimport CesiumMath from './Math.js';\r\nimport Matrix4 from './Matrix4.js';\r\n\r\n/**\r\n * A plane in Hessian Normal Form defined by\r\n * <pre>\r\n * ax + by + cz + d = 0\r\n * </pre>\r\n * where (a, b, c) is the plane's <code>normal</code>, d is the signed\r\n * <code>distance</code> to the plane, and (x, y, z) is any point on\r\n * the plane.\r\n *\r\n * @alias Plane\r\n * @constructor\r\n *\r\n * @param {Cartesian3} normal The plane's normal (normalized).\r\n * @param {Number} distance The shortest distance from the origin to the plane.  The sign of\r\n * <code>distance</code> determines which side of the plane the origin\r\n * is on.  If <code>distance</code> is positive, the origin is in the half-space\r\n * in the direction of the normal; if negative, the origin is in the half-space\r\n * opposite to the normal; if zero, the plane passes through the origin.\r\n *\r\n * @example\r\n * // The plane x=0\r\n * var plane = new Cesium.Plane(Cesium.Cartesian3.UNIT_X, 0.0);\r\n *\r\n * @exception {DeveloperError} Normal must be normalized\r\n */\r\nfunction Plane(normal, distance) {\r\n    //>>includeStart('debug', pragmas.debug);\r\n    Check.typeOf.object('normal', normal);\r\n    if (!CesiumMath.equalsEpsilon(Cartesian3.magnitude(normal), 1.0, CesiumMath.EPSILON6)) {\r\n        throw new DeveloperError('normal must be normalized.');\r\n    }\r\n    Check.typeOf.number('distance', distance);\r\n    //>>includeEnd('debug');\r\n\r\n    /**\r\n     * The plane's normal.\r\n     *\r\n     * @type {Cartesian3}\r\n     */\r\n    this.normal = Cartesian3.clone(normal);\r\n\r\n    /**\r\n     * The shortest distance from the origin to the plane.  The sign of\r\n     * <code>distance</code> determines which side of the plane the origin\r\n     * is on.  If <code>distance</code> is positive, the origin is in the half-space\r\n     * in the direction of the normal; if negative, the origin is in the half-space\r\n     * opposite to the normal; if zero, the plane passes through the origin.\r\n     *\r\n     * @type {Number}\r\n     */\r\n    this.distance = distance;\r\n}\r\n\r\n/**\r\n * Creates a plane from a normal and a point on the plane.\r\n * 通过平面的法向量（normal vector）和一个在平面上的点，生成一个新平面\r\n *\r\n * @param {Cartesian3} point The point on the plane.\r\n * @param {Cartesian3} normal The plane's normal (normalized).\r\n * @param {Plane} [result] The object onto which to store the result.\r\n * @returns {Plane} A new plane instance or the modified result parameter.\r\n *\r\n * @example\r\n * var point = Cesium.Cartesian3.fromDegrees(-72.0, 40.0);\r\n * var normal = ellipsoid.geodeticSurfaceNormal(point);\r\n * var tangentPlane = Cesium.Plane.fromPointNormal(point, normal);\r\n *\r\n * @exception {DeveloperError} Normal must be normalized\r\n */\r\nPlane.fromPointNormal = function (point, normal, result) {\r\n    //>>includeStart('debug', pragmas.debug);\r\n    Check.typeOf.object('point', point);\r\n    Check.typeOf.object('normal', normal);\r\n    if (!CesiumMath.equalsEpsilon(Cartesian3.magnitude(normal), 1.0, CesiumMath.EPSILON6)) {\r\n        throw new DeveloperError('normal must be normalized.');\r\n    }\r\n    //>>includeEnd('debug');\r\n\r\n    var distance = -Cartesian3.dot(normal, point);\r\n\r\n    if (!defined(result)) {\r\n        return new Plane(normal, distance);\r\n    }\r\n\r\n    Cartesian3.clone(normal, result.normal);\r\n    result.distance = distance;\r\n    return result;\r\n};\r\n\r\nvar scratchNormal = new Cartesian3();\r\n/**\r\n * Creates a plane from the general equation\r\n *\r\n * @param {Cartesian4} coefficients The plane's normal (normalized).\r\n * @param {Plane} [result] The object onto which to store the result.\r\n * @returns {Plane} A new plane instance or the modified result parameter.\r\n *\r\n * @exception {DeveloperError} Normal must be normalized\r\n */\r\nPlane.fromCartesian4 = function (coefficients, result) {\r\n    //>>includeStart('debug', pragmas.debug);\r\n    Check.typeOf.object('coefficients', coefficients);\r\n    //>>includeEnd('debug');\r\n\r\n    var normal = Cartesian3.fromCartesian4(coefficients, scratchNormal);\r\n    var distance = coefficients.w;\r\n\r\n    //>>includeStart('debug', pragmas.debug);\r\n    if (!CesiumMath.equalsEpsilon(Cartesian3.magnitude(normal), 1.0, CesiumMath.EPSILON6)) {\r\n        throw new DeveloperError('normal must be normalized.');\r\n    }\r\n    //>>includeEnd('debug');\r\n\r\n    if (!defined(result)) {\r\n        return new Plane(normal, distance);\r\n    }\r\n    Cartesian3.clone(normal, result.normal);\r\n    result.distance = distance;\r\n    return result;\r\n};\r\n\r\n/**\r\n * Computes the signed shortest distance of a point to a plane.\r\n * The sign of the distance determines which side of the plane the point\r\n * is on.  If the distance is positive, the point is in the half-space\r\n * in the direction of the normal; if negative, the point is in the half-space\r\n * opposite to the normal; if zero, the plane passes through the point.\r\n *\r\n * @param {Plane} plane The plane.\r\n * @param {Cartesian3} point The point.\r\n * @returns {Number} The signed shortest distance of the point to the plane.\r\n */\r\nPlane.getPointDistance = function (plane, point) {\r\n    //>>includeStart('debug', pragmas.debug);\r\n    Check.typeOf.object('plane', plane);\r\n    Check.typeOf.object('point', point);\r\n    //>>includeEnd('debug');\r\n\r\n    return Cartesian3.dot(plane.normal, point) + plane.distance;\r\n};\r\n\r\nvar scratchCartesian = new Cartesian3();\r\n/**\r\n * Projects a point onto the plane.\r\n * @param {Plane} plane The plane to project the point onto\r\n * @param {Cartesian3} point The point to project onto the plane\r\n * @param {Cartesian3} [result] The result point.  If undefined, a new Cartesian3 will be created.\r\n * @returns {Cartesian3} The modified result parameter or a new Cartesian3 instance if one was not provided.\r\n */\r\nPlane.projectPointOntoPlane = function (plane, point, result) {\r\n    //>>includeStart('debug', pragmas.debug);\r\n    Check.typeOf.object('plane', plane);\r\n    Check.typeOf.object('point', point);\r\n    //>>includeEnd('debug');\r\n\r\n    if (!defined(result)) {\r\n        result = new Cartesian3();\r\n    }\r\n\r\n    // projectedPoint = point - (normal.point + scale) * normal\r\n    var pointDistance = Plane.getPointDistance(plane, point);\r\n    var scaledNormal = Cartesian3.multiplyByScalar(plane.normal, pointDistance, scratchCartesian);\r\n\r\n    return Cartesian3.subtract(point, scaledNormal, result);\r\n};\r\n\r\nvar scratchInverseTranspose = new Matrix4();\r\nvar scratchPlaneCartesian4 = new Cartesian4();\r\nvar scratchTransformNormal = new Cartesian3();\r\n/**\r\n * Transforms the plane by the given transformation matrix.\r\n *\r\n * @param {Plane} plane The plane.\r\n * @param {Matrix4} transform The transformation matrix.\r\n * @param {Plane} [result] The object into which to store the result.\r\n * @returns {Plane} The plane transformed by the given transformation matrix.\r\n */\r\nPlane.transform = function (plane, transform, result) {\r\n    //>>includeStart('debug', pragmas.debug);\r\n    Check.typeOf.object('plane', plane);\r\n    Check.typeOf.object('transform', transform);\r\n    //>>includeEnd('debug');\r\n\r\n    var normal = plane.normal;\r\n    var distance = plane.distance;\r\n    var inverseTranspose = Matrix4.inverseTranspose(transform, scratchInverseTranspose);\r\n    var planeAsCartesian4 = Cartesian4.fromElements(normal.x, normal.y, normal.z, distance, scratchPlaneCartesian4);\r\n    planeAsCartesian4 = Matrix4.multiplyByVector(inverseTranspose, planeAsCartesian4, planeAsCartesian4);\r\n\r\n    // Convert the transformed plane to Hessian Normal Form\r\n    var transformedNormal = Cartesian3.fromCartesian4(planeAsCartesian4, scratchTransformNormal);\r\n\r\n    planeAsCartesian4 = Cartesian4.divideByScalar(planeAsCartesian4, Cartesian3.magnitude(transformedNormal), planeAsCartesian4);\r\n\r\n    return Plane.fromCartesian4(planeAsCartesian4, result);\r\n};\r\n\r\n/**\r\n * Duplicates a Plane instance.\r\n *\r\n * @param {Plane} plane The plane to duplicate.\r\n * @param {Plane} [result] The object onto which to store the result.\r\n * @returns {Plane} The modified result parameter or a new Plane instance if one was not provided.\r\n */\r\nPlane.clone = function (plane, result) {\r\n    //>>includeStart('debug', pragmas.debug);\r\n    Check.typeOf.object('plane', plane);\r\n    //>>includeEnd('debug');\r\n\r\n    if (!defined(result)) {\r\n        return new Plane(plane.normal, plane.distance);\r\n    }\r\n\r\n    Cartesian3.clone(plane.normal, result.normal);\r\n    result.distance = plane.distance;\r\n\r\n    return result;\r\n};\r\n\r\n/**\r\n * Compares the provided Planes by normal and distance and returns\r\n * <code>true</code> if they are equal, <code>false</code> otherwise.\r\n *\r\n * @param {Plane} left The first plane.\r\n * @param {Plane} right The second plane.\r\n * @returns {Boolean} <code>true</code> if left and right are equal, <code>false</code> otherwise.\r\n */\r\nPlane.equals = function (left, right) {\r\n    //>>includeStart('debug', pragmas.debug);\r\n    Check.typeOf.object('left', left);\r\n    Check.typeOf.object('right', right);\r\n    //>>includeEnd('debug');\r\n\r\n    return left.distance === right.distance && Cartesian3.equals(left.normal, right.normal);\r\n};\r\n\r\n/**\r\n * A constant initialized to the XY plane passing through the origin, with normal in positive Z.\r\n *\r\n * @type {Plane}\r\n * @constant\r\n */\r\nPlane.ORIGIN_XY_PLANE = Object.freeze(new Plane(Cartesian3.UNIT_Z, 0.0));\r\n\r\n/**\r\n * A constant initialized to the YZ plane passing through the origin, with normal in positive X.\r\n *\r\n * @type {Plane}\r\n * @constant\r\n */\r\nPlane.ORIGIN_YZ_PLANE = Object.freeze(new Plane(Cartesian3.UNIT_X, 0.0));\r\n\r\n/**\r\n * A constant initialized to the ZX plane passing through the origin, with normal in positive Y.\r\n *\r\n * @type {Plane}\r\n * @constant\r\n */\r\nPlane.ORIGIN_ZX_PLANE = Object.freeze(new Plane(Cartesian3.UNIT_Y, 0.0));\r\nexport default Plane;\r\n"],"names":["Check","CesiumMath","Cartesian3","DeveloperError","defined","Matrix4","Cartesian4"],"mappings":"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"}