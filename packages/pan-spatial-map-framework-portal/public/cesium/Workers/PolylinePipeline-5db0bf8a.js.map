{"version":3,"file":"PolylinePipeline-5db0bf8a.js","sources":["../../../../Source/Core/PolylinePipeline.js"],"sourcesContent":["import Cartesian3 from './Cartesian3.js';\r\nimport Cartographic from './Cartographic.js';\r\nimport defaultValue from './defaultValue.js';\r\nimport defined from './defined.js';\r\nimport DeveloperError from './DeveloperError.js';\r\nimport Ellipsoid from './Ellipsoid.js';\r\nimport EllipsoidGeodesic from './EllipsoidGeodesic.js';\r\nimport EllipsoidRhumbLine from './EllipsoidRhumbLine.js';\r\nimport IntersectionTests from './IntersectionTests.js';\r\nimport CesiumMath from './Math.js';\r\nimport Matrix4 from './Matrix4.js';\r\nimport Plane from './Plane.js';\r\n\r\n/**\r\n * @private\r\n */\r\nvar PolylinePipeline = {};\r\n\r\nPolylinePipeline.numberOfPoints = function (p0, p1, minDistance) {\r\n    var distance = Cartesian3.distance(p0, p1);\r\n    return Math.ceil(distance / minDistance);\r\n};\r\n\r\nPolylinePipeline.numberOfPointsRhumbLine = function (p0, p1, granularity) {\r\n    var radiansDistanceSquared = Math.pow(p0.longitude - p1.longitude, 2) + Math.pow(p0.latitude - p1.latitude, 2);\r\n\r\n    return Math.max(1, Math.ceil(Math.sqrt(radiansDistanceSquared / (granularity * granularity))));\r\n};\r\n\r\nvar cartoScratch = new Cartographic();\r\nPolylinePipeline.extractHeights = function (positions, ellipsoid) {\r\n    var length = positions.length;\r\n    var heights = new Array(length);\r\n    for (var i = 0; i < length; i++) {\r\n        var p = positions[i];\r\n        heights[i] = ellipsoid.cartesianToCartographic(p, cartoScratch).height;\r\n    }\r\n    return heights;\r\n};\r\n\r\nvar wrapLongitudeInversMatrix = new Matrix4();\r\nvar wrapLongitudeOrigin = new Cartesian3();\r\nvar wrapLongitudeXZNormal = new Cartesian3();\r\nvar wrapLongitudeXZPlane = new Plane(Cartesian3.UNIT_X, 0.0);\r\nvar wrapLongitudeYZNormal = new Cartesian3();\r\nvar wrapLongitudeYZPlane = new Plane(Cartesian3.UNIT_X, 0.0);\r\nvar wrapLongitudeIntersection = new Cartesian3();\r\nvar wrapLongitudeOffset = new Cartesian3();\r\n\r\nvar subdivideHeightsScratchArray = [];\r\n\r\nfunction subdivideHeights(numPoints, h0, h1) {\r\n    var heights = subdivideHeightsScratchArray;\r\n    heights.length = numPoints;\r\n\r\n    var i;\r\n    if (h0 === h1) {\r\n        for (i = 0; i < numPoints; i++) {\r\n            heights[i] = h0;\r\n        }\r\n        return heights;\r\n    }\r\n\r\n    var dHeight = h1 - h0;\r\n    var heightPerVertex = dHeight / numPoints;\r\n\r\n    for (i = 0; i < numPoints; i++) {\r\n        var h = h0 + i * heightPerVertex;\r\n        heights[i] = h;\r\n    }\r\n\r\n    return heights;\r\n}\r\n\r\nvar carto1 = new Cartographic();\r\nvar carto2 = new Cartographic();\r\nvar cartesian = new Cartesian3();\r\nvar scaleFirst = new Cartesian3();\r\nvar scaleLast = new Cartesian3();\r\nvar ellipsoidGeodesic = new EllipsoidGeodesic();\r\nvar ellipsoidRhumb = new EllipsoidRhumbLine();\r\n\r\n//Returns subdivided line scaled to ellipsoid surface starting at p1 and ending at p2.\r\n//Result includes p1, but not include p2.  This function is called for a sequence of line segments,\r\n//and this prevents duplication of end point.\r\nfunction generateCartesianArc(p0, p1, minDistance, ellipsoid, h0, h1, array, offset) {\r\n    var first = ellipsoid.scaleToGeodeticSurface(p0, scaleFirst);\r\n    var last = ellipsoid.scaleToGeodeticSurface(p1, scaleLast);\r\n    var numPoints = PolylinePipeline.numberOfPoints(p0, p1, minDistance);\r\n    var start = ellipsoid.cartesianToCartographic(first, carto1);\r\n    var end = ellipsoid.cartesianToCartographic(last, carto2);\r\n    var heights = subdivideHeights(numPoints, h0, h1);\r\n\r\n    ellipsoidGeodesic.setEndPoints(start, end);\r\n    var surfaceDistanceBetweenPoints = ellipsoidGeodesic.surfaceDistance / numPoints;\r\n\r\n    var index = offset;\r\n    start.height = h0;\r\n    var cart = ellipsoid.cartographicToCartesian(start, cartesian);\r\n    Cartesian3.pack(cart, array, index);\r\n    index += 3;\r\n\r\n    for (var i = 1; i < numPoints; i++) {\r\n        var carto = ellipsoidGeodesic.interpolateUsingSurfaceDistance(i * surfaceDistanceBetweenPoints, carto2);\r\n        carto.height = heights[i];\r\n        cart = ellipsoid.cartographicToCartesian(carto, cartesian);\r\n        Cartesian3.pack(cart, array, index);\r\n        index += 3;\r\n    }\r\n\r\n    return index;\r\n}\r\n\r\n//Returns subdivided line scaled to ellipsoid surface starting at p1 and ending at p2.\r\n//Result includes p1, but not include p2.  This function is called for a sequence of line segments,\r\n//and this prevents duplication of end point.\r\nfunction generateCartesianRhumbArc(p0, p1, granularity, ellipsoid, h0, h1, array, offset) {\r\n    var start = ellipsoid.cartesianToCartographic(p0, carto1);\r\n    var end = ellipsoid.cartesianToCartographic(p1, carto2);\r\n    var numPoints = PolylinePipeline.numberOfPointsRhumbLine(start, end, granularity);\r\n    start.height = 0.0;\r\n    end.height = 0.0;\r\n    var heights = subdivideHeights(numPoints, h0, h1);\r\n\r\n    if (!ellipsoidRhumb.ellipsoid.equals(ellipsoid)) {\r\n        ellipsoidRhumb = new EllipsoidRhumbLine(undefined, undefined, ellipsoid);\r\n    }\r\n    ellipsoidRhumb.setEndPoints(start, end);\r\n    var surfaceDistanceBetweenPoints = ellipsoidRhumb.surfaceDistance / numPoints;\r\n\r\n    var index = offset;\r\n    start.height = h0;\r\n    var cart = ellipsoid.cartographicToCartesian(start, cartesian);\r\n    Cartesian3.pack(cart, array, index);\r\n    index += 3;\r\n\r\n    for (var i = 1; i < numPoints; i++) {\r\n        var carto = ellipsoidRhumb.interpolateUsingSurfaceDistance(i * surfaceDistanceBetweenPoints, carto2);\r\n        carto.height = heights[i];\r\n        cart = ellipsoid.cartographicToCartesian(carto, cartesian);\r\n        Cartesian3.pack(cart, array, index);\r\n        index += 3;\r\n    }\r\n\r\n    return index;\r\n}\r\n\r\n/**\r\n * Breaks a {@link Polyline} into segments such that it does not cross the &plusmn;180 degree meridian of an ellipsoid.\r\n *\r\n * @param {Cartesian3[]} positions The polyline's Cartesian positions.\r\n * @param {Matrix4} [modelMatrix=Matrix4.IDENTITY] The polyline's model matrix. Assumed to be an affine\r\n * transformation matrix, where the upper left 3x3 elements are a rotation matrix, and\r\n * the upper three elements in the fourth column are the translation.  The bottom row is assumed to be [0, 0, 0, 1].\r\n * The matrix is not verified to be in the proper form.\r\n * @returns {Object} An object with a <code>positions</code> property that is an array of positions and a\r\n * <code>segments</code> property.\r\n *\r\n *\r\n * @example\r\n * var polylines = new Cesium.PolylineCollection();\r\n * var polyline = polylines.add(...);\r\n * var positions = polyline.positions;\r\n * var modelMatrix = polylines.modelMatrix;\r\n * var segments = Cesium.PolylinePipeline.wrapLongitude(positions, modelMatrix);\r\n *\r\n * @see PolygonPipeline.wrapLongitude\r\n * @see Polyline\r\n * @see PolylineCollection\r\n */\r\nPolylinePipeline.wrapLongitude = function (positions, modelMatrix) {\r\n    var cartesians = [];\r\n    var segments = [];\r\n\r\n    if (defined(positions) && positions.length > 0) {\r\n        modelMatrix = defaultValue(modelMatrix, Matrix4.IDENTITY);\r\n        var inverseModelMatrix = Matrix4.inverseTransformation(modelMatrix, wrapLongitudeInversMatrix);\r\n\r\n        var origin = Matrix4.multiplyByPoint(inverseModelMatrix, Cartesian3.ZERO, wrapLongitudeOrigin);\r\n        var xzNormal = Cartesian3.normalize(Matrix4.multiplyByPointAsVector(inverseModelMatrix, Cartesian3.UNIT_Y, wrapLongitudeXZNormal), wrapLongitudeXZNormal);\r\n        var xzPlane = Plane.fromPointNormal(origin, xzNormal, wrapLongitudeXZPlane);\r\n        var yzNormal = Cartesian3.normalize(Matrix4.multiplyByPointAsVector(inverseModelMatrix, Cartesian3.UNIT_X, wrapLongitudeYZNormal), wrapLongitudeYZNormal);\r\n        var yzPlane = Plane.fromPointNormal(origin, yzNormal, wrapLongitudeYZPlane);\r\n\r\n        var count = 1;\r\n        cartesians.push(Cartesian3.clone(positions[0]));\r\n        var prev = cartesians[0];\r\n\r\n        var length = positions.length;\r\n        for (var i = 1; i < length; ++i) {\r\n            var cur = positions[i];\r\n\r\n            // intersects the IDL if either endpoint is on the negative side of the yz-plane\r\n            if (Plane.getPointDistance(yzPlane, prev) < 0.0 || Plane.getPointDistance(yzPlane, cur) < 0.0) {\r\n                // and intersects the xz-plane\r\n                var intersection = IntersectionTests.lineSegmentPlane(prev, cur, xzPlane, wrapLongitudeIntersection);\r\n                if (defined(intersection)) {\r\n                    // move point on the xz-plane slightly away from the plane\r\n                    var offset = Cartesian3.multiplyByScalar(xzNormal, 5.0e-9, wrapLongitudeOffset);\r\n                    if (Plane.getPointDistance(xzPlane, prev) < 0.0) {\r\n                        Cartesian3.negate(offset, offset);\r\n                    }\r\n\r\n                    cartesians.push(Cartesian3.add(intersection, offset, new Cartesian3()));\r\n                    segments.push(count + 1);\r\n\r\n                    Cartesian3.negate(offset, offset);\r\n                    cartesians.push(Cartesian3.add(intersection, offset, new Cartesian3()));\r\n                    count = 1;\r\n                }\r\n            }\r\n\r\n            cartesians.push(Cartesian3.clone(positions[i]));\r\n            count++;\r\n\r\n            prev = cur;\r\n        }\r\n\r\n        segments.push(count);\r\n    }\r\n\r\n    return {\r\n        positions: cartesians,\r\n        lengths: segments\r\n    };\r\n};\r\n\r\n/**\r\n * Subdivides polyline and raises all points to the specified height.  Returns an array of numbers to represent the positions.\r\n * @param {Object} options Object with the following properties:\r\n * @param {Cartesian3[]} options.positions The array of type {Cartesian3} representing positions.\r\n * @param {Number|Number[]} [options.height=0.0] A number or array of numbers representing the heights of each position.\r\n * @param {Number} [options.granularity = CesiumMath.RADIANS_PER_DEGREE] The distance, in radians, between each latitude and longitude. Determines the number of positions in the buffer.\r\n * @param {Ellipsoid} [options.ellipsoid=Ellipsoid.WGS84] The ellipsoid on which the positions lie.\r\n * @returns {Number[]} A new array of positions of type {Number} that have been subdivided and raised to the surface of the ellipsoid.\r\n *\r\n * @example\r\n * var positions = Cesium.Cartesian3.fromDegreesArray([\r\n *   -105.0, 40.0,\r\n *   -100.0, 38.0,\r\n *   -105.0, 35.0,\r\n *   -100.0, 32.0\r\n * ]);\r\n * var surfacePositions = Cesium.PolylinePipeline.generateArc({\r\n *   positons: positions\r\n * });\r\n */\r\nPolylinePipeline.generateArc = function (options) {\r\n    if (!defined(options)) {\r\n        options = {};\r\n    }\r\n    var positions = options.positions;\r\n    //>>includeStart('debug', pragmas.debug);\r\n    if (!defined(positions)) {\r\n        throw new DeveloperError('options.positions is required.');\r\n    }\r\n    //>>includeEnd('debug');\r\n\r\n    var length = positions.length;\r\n    var ellipsoid = defaultValue(options.ellipsoid, Ellipsoid.WGS84);\r\n    var height = defaultValue(options.height, 0);\r\n    var hasHeightArray = Array.isArray(height);\r\n\r\n    if (length < 1) {\r\n        return [];\r\n    } else if (length === 1) {\r\n        var p = ellipsoid.scaleToGeodeticSurface(positions[0], scaleFirst);\r\n        height = hasHeightArray ? height[0] : height;\r\n        if (height !== 0) {\r\n            var n = ellipsoid.geodeticSurfaceNormal(p, cartesian);\r\n            Cartesian3.multiplyByScalar(n, height, n);\r\n            Cartesian3.add(p, n, p);\r\n        }\r\n\r\n        return [p.x, p.y, p.z];\r\n    }\r\n\r\n    var minDistance = options.minDistance;\r\n    if (!defined(minDistance)) {\r\n        var granularity = defaultValue(options.granularity, CesiumMath.RADIANS_PER_DEGREE);\r\n        minDistance = CesiumMath.chordLength(granularity, ellipsoid.maximumRadius);\r\n    }\r\n\r\n    var numPoints = 0;\r\n    var i;\r\n\r\n    for (i = 0; i < length - 1; i++) {\r\n        numPoints += PolylinePipeline.numberOfPoints(positions[i], positions[i + 1], minDistance);\r\n    }\r\n\r\n    var arrayLength = (numPoints + 1) * 3;\r\n    var newPositions = new Array(arrayLength);\r\n    var offset = 0;\r\n\r\n    for (i = 0; i < length - 1; i++) {\r\n        var p0 = positions[i];\r\n        var p1 = positions[i + 1];\r\n\r\n        var h0 = hasHeightArray ? height[i] : height;\r\n        var h1 = hasHeightArray ? height[i + 1] : height;\r\n\r\n        offset = generateCartesianArc(p0, p1, minDistance, ellipsoid, h0, h1, newPositions, offset);\r\n    }\r\n\r\n    subdivideHeightsScratchArray.length = 0;\r\n\r\n    var lastPoint = positions[length - 1];\r\n    var carto = ellipsoid.cartesianToCartographic(lastPoint, carto1);\r\n    carto.height = hasHeightArray ? height[length - 1] : height;\r\n    var cart = ellipsoid.cartographicToCartesian(carto, cartesian);\r\n    Cartesian3.pack(cart, newPositions, arrayLength - 3);\r\n\r\n    return newPositions;\r\n};\r\n\r\nvar scratchCartographic0 = new Cartographic();\r\nvar scratchCartographic1 = new Cartographic();\r\n\r\n/**\r\n * Subdivides polyline and raises all points to the specified height using Rhumb lines.  Returns an array of numbers to represent the positions.\r\n * @param {Object} options Object with the following properties:\r\n * @param {Cartesian3[]} options.positions The array of type {Cartesian3} representing positions.\r\n * @param {Number|Number[]} [options.height=0.0] A number or array of numbers representing the heights of each position.\r\n * @param {Number} [options.granularity = CesiumMath.RADIANS_PER_DEGREE] The distance, in radians, between each latitude and longitude. Determines the number of positions in the buffer.\r\n * @param {Ellipsoid} [options.ellipsoid=Ellipsoid.WGS84] The ellipsoid on which the positions lie.\r\n * @returns {Number[]} A new array of positions of type {Number} that have been subdivided and raised to the surface of the ellipsoid.\r\n *\r\n * @example\r\n * var positions = Cesium.Cartesian3.fromDegreesArray([\r\n *   -105.0, 40.0,\r\n *   -100.0, 38.0,\r\n *   -105.0, 35.0,\r\n *   -100.0, 32.0\r\n * ]);\r\n * var surfacePositions = Cesium.PolylinePipeline.generateRhumbArc({\r\n *   positons: positions\r\n * });\r\n */\r\nPolylinePipeline.generateRhumbArc = function (options) {\r\n    if (!defined(options)) {\r\n        options = {};\r\n    }\r\n    var positions = options.positions;\r\n    //>>includeStart('debug', pragmas.debug);\r\n    if (!defined(positions)) {\r\n        throw new DeveloperError('options.positions is required.');\r\n    }\r\n    //>>includeEnd('debug');\r\n\r\n    var length = positions.length;\r\n    var ellipsoid = defaultValue(options.ellipsoid, Ellipsoid.WGS84);\r\n    var height = defaultValue(options.height, 0);\r\n    var hasHeightArray = Array.isArray(height);\r\n\r\n    if (length < 1) {\r\n        return [];\r\n    } else if (length === 1) {\r\n        var p = ellipsoid.scaleToGeodeticSurface(positions[0], scaleFirst);\r\n        height = hasHeightArray ? height[0] : height;\r\n        if (height !== 0) {\r\n            var n = ellipsoid.geodeticSurfaceNormal(p, cartesian);\r\n            Cartesian3.multiplyByScalar(n, height, n);\r\n            Cartesian3.add(p, n, p);\r\n        }\r\n\r\n        return [p.x, p.y, p.z];\r\n    }\r\n\r\n    var granularity = defaultValue(options.granularity, CesiumMath.RADIANS_PER_DEGREE);\r\n\r\n    var numPoints = 0;\r\n    var i;\r\n\r\n    var c0 = ellipsoid.cartesianToCartographic(positions[0], scratchCartographic0);\r\n    var c1;\r\n    for (i = 0; i < length - 1; i++) {\r\n        c1 = ellipsoid.cartesianToCartographic(positions[i + 1], scratchCartographic1);\r\n        numPoints += PolylinePipeline.numberOfPointsRhumbLine(c0, c1, granularity);\r\n        c0 = Cartographic.clone(c1, scratchCartographic0);\r\n    }\r\n\r\n    var arrayLength = (numPoints + 1) * 3;\r\n    var newPositions = new Array(arrayLength);\r\n    var offset = 0;\r\n\r\n    for (i = 0; i < length - 1; i++) {\r\n        var p0 = positions[i];\r\n        var p1 = positions[i + 1];\r\n\r\n        var h0 = hasHeightArray ? height[i] : height;\r\n        var h1 = hasHeightArray ? height[i + 1] : height;\r\n\r\n        offset = generateCartesianRhumbArc(p0, p1, granularity, ellipsoid, h0, h1, newPositions, offset);\r\n    }\r\n\r\n    subdivideHeightsScratchArray.length = 0;\r\n\r\n    var lastPoint = positions[length - 1];\r\n    var carto = ellipsoid.cartesianToCartographic(lastPoint, carto1);\r\n    carto.height = hasHeightArray ? height[length - 1] : height;\r\n    var cart = ellipsoid.cartographicToCartesian(carto, cartesian);\r\n    Cartesian3.pack(cart, newPositions, arrayLength - 3);\r\n\r\n    return newPositions;\r\n};\r\n\r\n/**\r\n * Subdivides polyline and raises all points to the specified height. Returns an array of new {Cartesian3} positions.\r\n * @param {Object} options Object with the following properties:\r\n * @param {Cartesian3[]} options.positions The array of type {Cartesian3} representing positions.\r\n * @param {Number|Number[]} [options.height=0.0] A number or array of numbers representing the heights of each position.\r\n * @param {Number} [options.granularity = CesiumMath.RADIANS_PER_DEGREE] The distance, in radians, between each latitude and longitude. Determines the number of positions in the buffer.\r\n * @param {Ellipsoid} [options.ellipsoid=Ellipsoid.WGS84] The ellipsoid on which the positions lie.\r\n * @returns {Cartesian3[]} A new array of cartesian3 positions that have been subdivided and raised to the surface of the ellipsoid.\r\n *\r\n * @example\r\n * var positions = Cesium.Cartesian3.fromDegreesArray([\r\n *   -105.0, 40.0,\r\n *   -100.0, 38.0,\r\n *   -105.0, 35.0,\r\n *   -100.0, 32.0\r\n * ]);\r\n * var surfacePositions = Cesium.PolylinePipeline.generateCartesianArc({\r\n *   positons: positions\r\n * });\r\n */\r\nPolylinePipeline.generateCartesianArc = function (options) {\r\n    var numberArray = PolylinePipeline.generateArc(options);\r\n    var size = numberArray.length / 3;\r\n    var newPositions = new Array(size);\r\n    for (var i = 0; i < size; i++) {\r\n        newPositions[i] = Cartesian3.unpack(numberArray, i * 3);\r\n    }\r\n    return newPositions;\r\n};\r\n\r\n/**\r\n * Subdivides polyline and raises all points to the specified height using Rhumb Lines. Returns an array of new {Cartesian3} positions.\r\n * @param {Object} options Object with the following properties:\r\n * @param {Cartesian3[]} options.positions The array of type {Cartesian3} representing positions.\r\n * @param {Number|Number[]} [options.height=0.0] A number or array of numbers representing the heights of each position.\r\n * @param {Number} [options.granularity = CesiumMath.RADIANS_PER_DEGREE] The distance, in radians, between each latitude and longitude. Determines the number of positions in the buffer.\r\n * @param {Ellipsoid} [options.ellipsoid=Ellipsoid.WGS84] The ellipsoid on which the positions lie.\r\n * @returns {Cartesian3[]} A new array of cartesian3 positions that have been subdivided and raised to the surface of the ellipsoid.\r\n *\r\n * @example\r\n * var positions = Cesium.Cartesian3.fromDegreesArray([\r\n *   -105.0, 40.0,\r\n *   -100.0, 38.0,\r\n *   -105.0, 35.0,\r\n *   -100.0, 32.0\r\n * ]);\r\n * var surfacePositions = Cesium.PolylinePipeline.generateCartesianRhumbArc({\r\n *   positons: positions\r\n * });\r\n */\r\nPolylinePipeline.generateCartesianRhumbArc = function (options) {\r\n    var numberArray = PolylinePipeline.generateRhumbArc(options);\r\n    var size = numberArray.length / 3;\r\n    var newPositions = new Array(size);\r\n    for (var i = 0; i < size; i++) {\r\n        newPositions[i] = Cartesian3.unpack(numberArray, i * 3);\r\n    }\r\n    return newPositions;\r\n};\r\nexport default PolylinePipeline;\r\n"],"names":["Cartesian3","Cartographic","Matrix4","Plane","EllipsoidGeodesic","EllipsoidRhumbLine","defined","defaultValue","IntersectionTests","DeveloperError","Ellipsoid","CesiumMath"],"mappings":"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"}