{"version":3,"file":"TerrainEncoding-f1f8bbe4.js","sources":["../../../../Source/Core/EllipsoidalOccluder.js","../../../../Source/Core/TerrainExaggeration.js","../../../../Source/Core/TerrainQuantization.js","../../../../Source/Core/TerrainEncoding.js"],"sourcesContent":["import BoundingSphere from './BoundingSphere.js';\r\nimport Cartesian3 from './Cartesian3.js';\r\nimport Check from './Check.js';\r\nimport defaultValue from './defaultValue.js';\r\nimport defined from './defined.js';\r\nimport Ellipsoid from './Ellipsoid.js';\r\nimport Rectangle from './Rectangle.js';\r\n\r\n/**\r\n * Determine whether or not other objects are visible or hidden behind the visible horizon defined by\r\n * an {@link Ellipsoid} and a camera position.  The ellipsoid is assumed to be located at the\r\n * origin of the coordinate system.  This class uses the algorithm described in the\r\n * {@link https://cesium.com/blog/2013/04/25/Horizon-culling/|Horizon Culling} blog post.\r\n *\r\n * @alias EllipsoidalOccluder\r\n *\r\n * @param {Ellipsoid} ellipsoid The ellipsoid to use as an occluder.\r\n * @param {Cartesian3} [cameraPosition] The coordinate of the viewer/camera.  If this parameter is not\r\n *        specified, {@link EllipsoidalOccluder#cameraPosition} must be called before\r\n *        testing visibility.\r\n *\r\n * @constructor\r\n *\r\n * @example\r\n * // Construct an ellipsoidal occluder with radii 1.0, 1.1, and 0.9.\r\n * var cameraPosition = new Cesium.Cartesian3(5.0, 6.0, 7.0);\r\n * var occluderEllipsoid = new Cesium.Ellipsoid(1.0, 1.1, 0.9);\r\n * var occluder = new Cesium.EllipsoidalOccluder(occluderEllipsoid, cameraPosition);\r\n *\r\n * @private\r\n */\r\nfunction EllipsoidalOccluder(ellipsoid, cameraPosition) {\r\n    //>>includeStart('debug', pragmas.debug);\r\n    Check.typeOf.object('ellipsoid', ellipsoid);\r\n    //>>includeEnd('debug');\r\n\r\n    this._ellipsoid = ellipsoid;\r\n    this._cameraPosition = new Cartesian3();\r\n    this._cameraPositionInScaledSpace = new Cartesian3();\r\n    this._distanceToLimbInScaledSpaceSquared = 0.0;\r\n\r\n    // cameraPosition fills in the above values\r\n    if (defined(cameraPosition)) {\r\n        this.cameraPosition = cameraPosition;\r\n    }\r\n}\r\n\r\nObject.defineProperties(EllipsoidalOccluder.prototype, {\r\n    /**\r\n     * Gets the occluding ellipsoid.\r\n     * @memberof EllipsoidalOccluder.prototype\r\n     * @type {Ellipsoid}\r\n     */\r\n    ellipsoid: {\r\n        get: function () {\r\n            return this._ellipsoid;\r\n        }\r\n    },\r\n    /**\r\n     * Gets or sets the position of the camera.\r\n     * @memberof EllipsoidalOccluder.prototype\r\n     * @type {Cartesian3}\r\n     */\r\n    cameraPosition: {\r\n        get: function () {\r\n            return this._cameraPosition;\r\n        },\r\n        set: function (cameraPosition) {\r\n            // See https://cesium.com/blog/2013/04/25/Horizon-culling/\r\n            var ellipsoid = this._ellipsoid;\r\n            var cv = ellipsoid.transformPositionToScaledSpace(cameraPosition, this._cameraPositionInScaledSpace);\r\n            var vhMagnitudeSquared = Cartesian3.magnitudeSquared(cv) - 1.0;\r\n\r\n            Cartesian3.clone(cameraPosition, this._cameraPosition);\r\n            this._cameraPositionInScaledSpace = cv;\r\n            this._distanceToLimbInScaledSpaceSquared = vhMagnitudeSquared;\r\n        }\r\n    }\r\n});\r\n\r\nvar scratchCartesian = new Cartesian3();\r\n\r\n/**\r\n * Determines whether or not a point, the <code>occludee</code>, is hidden from view by the occluder.\r\n *\r\n * @param {Cartesian3} occludee The point to test for visibility.\r\n * @returns {Boolean} <code>true</code> if the occludee is visible; otherwise <code>false</code>.\r\n *\r\n * @example\r\n * var cameraPosition = new Cesium.Cartesian3(0, 0, 2.5);\r\n * var ellipsoid = new Cesium.Ellipsoid(1.0, 1.1, 0.9);\r\n * var occluder = new Cesium.EllipsoidalOccluder(ellipsoid, cameraPosition);\r\n * var point = new Cesium.Cartesian3(0, -3, -3);\r\n * occluder.isPointVisible(point); //returns true\r\n */\r\nEllipsoidalOccluder.prototype.isPointVisible = function (occludee) {\r\n    var ellipsoid = this._ellipsoid;\r\n    var occludeeScaledSpacePosition = ellipsoid.transformPositionToScaledSpace(occludee, scratchCartesian);\r\n    return isScaledSpacePointVisible(occludeeScaledSpacePosition, this._cameraPositionInScaledSpace, this._distanceToLimbInScaledSpaceSquared);\r\n};\r\n\r\n/**\r\n * Determines whether or not a point expressed in the ellipsoid scaled space, is hidden from view by the\r\n * occluder.  To transform a Cartesian X, Y, Z position in the coordinate system aligned with the ellipsoid\r\n * into the scaled space, call {@link Ellipsoid#transformPositionToScaledSpace}.\r\n *\r\n * @param {Cartesian3} occludeeScaledSpacePosition The point to test for visibility, represented in the scaled space.\r\n * @returns {Boolean} <code>true</code> if the occludee is visible; otherwise <code>false</code>.\r\n *\r\n * @example\r\n * var cameraPosition = new Cesium.Cartesian3(0, 0, 2.5);\r\n * var ellipsoid = new Cesium.Ellipsoid(1.0, 1.1, 0.9);\r\n * var occluder = new Cesium.EllipsoidalOccluder(ellipsoid, cameraPosition);\r\n * var point = new Cesium.Cartesian3(0, -3, -3);\r\n * var scaledSpacePoint = ellipsoid.transformPositionToScaledSpace(point);\r\n * occluder.isScaledSpacePointVisible(scaledSpacePoint); //returns true\r\n */\r\nEllipsoidalOccluder.prototype.isScaledSpacePointVisible = function (occludeeScaledSpacePosition) {\r\n    return isScaledSpacePointVisible(occludeeScaledSpacePosition, this._cameraPositionInScaledSpace, this._distanceToLimbInScaledSpaceSquared);\r\n};\r\n\r\nvar scratchCameraPositionInScaledSpaceShrunk = new Cartesian3();\r\n\r\n/**\r\n * Similar to {@link EllipsoidalOccluder#isScaledSpacePointVisible} except tests against an\r\n * ellipsoid that has been shrunk by the minimum height when the minimum height is below\r\n * the ellipsoid. This is intended to be used with points generated by\r\n * {@link EllipsoidalOccluder#computeHorizonCullingPointPossiblyUnderEllipsoid} or\r\n * {@link EllipsoidalOccluder#computeHorizonCullingPointFromVerticesPossiblyUnderEllipsoid}.\r\n *\r\n * @param {Cartesian3} occludeeScaledSpacePosition The point to test for visibility, represented in the scaled space of the possibly-shrunk ellipsoid.\r\n * @returns {Boolean} <code>true</code> if the occludee is visible; otherwise <code>false</code>.\r\n */\r\nEllipsoidalOccluder.prototype.isScaledSpacePointVisiblePossiblyUnderEllipsoid = function (occludeeScaledSpacePosition, minimumHeight) {\r\n    var ellipsoid = this._ellipsoid;\r\n    var vhMagnitudeSquared;\r\n    var cv;\r\n\r\n    if (defined(minimumHeight) && minimumHeight < 0.0 && ellipsoid.minimumRadius > -minimumHeight) {\r\n        // This code is similar to the cameraPosition setter, but unrolled for performance because it will be called a lot.\r\n        cv = scratchCameraPositionInScaledSpaceShrunk;\r\n        cv.x = this._cameraPosition.x / (ellipsoid.radii.x + minimumHeight);\r\n        cv.y = this._cameraPosition.y / (ellipsoid.radii.y + minimumHeight);\r\n        cv.z = this._cameraPosition.z / (ellipsoid.radii.z + minimumHeight);\r\n        vhMagnitudeSquared = cv.x * cv.x + cv.y * cv.y + cv.z * cv.z - 1.0;\r\n    } else {\r\n        cv = this._cameraPositionInScaledSpace;\r\n        vhMagnitudeSquared = this._distanceToLimbInScaledSpaceSquared;\r\n    }\r\n\r\n    return isScaledSpacePointVisible(occludeeScaledSpacePosition, cv, vhMagnitudeSquared);\r\n};\r\n\r\n/**\r\n * Computes a point that can be used for horizon culling from a list of positions.  If the point is below\r\n * the horizon, all of the positions are guaranteed to be below the horizon as well.  The returned point\r\n * is expressed in the ellipsoid-scaled space and is suitable for use with\r\n * {@link EllipsoidalOccluder#isScaledSpacePointVisible}.\r\n *\r\n * @param {Cartesian3} directionToPoint The direction that the computed point will lie along.\r\n *                     A reasonable direction to use is the direction from the center of the ellipsoid to\r\n *                     the center of the bounding sphere computed from the positions.  The direction need not\r\n *                     be normalized.\r\n * @param {Cartesian3[]} positions The positions from which to compute the horizon culling point.  The positions\r\n *                       must be expressed in a reference frame centered at the ellipsoid and aligned with the\r\n *                       ellipsoid's axes.\r\n * @param {Cartesian3} [result] The instance on which to store the result instead of allocating a new instance.\r\n * @returns {Cartesian3} The computed horizon culling point, expressed in the ellipsoid-scaled space.\r\n */\r\nEllipsoidalOccluder.prototype.computeHorizonCullingPoint = function (directionToPoint, positions, result) {\r\n    return computeHorizonCullingPointFromPositions(this._ellipsoid, directionToPoint, positions, result);\r\n};\r\n\r\nvar scratchEllipsoidShrunk = Ellipsoid.clone(Ellipsoid.UNIT_SPHERE);\r\n\r\n/**\r\n * Similar to {@link EllipsoidalOccluder#computeHorizonCullingPoint} except computes the culling\r\n * point relative to an ellipsoid that has been shrunk by the minimum height when the minimum height is below\r\n * the ellipsoid. The returned point is expressed in the possibly-shrunk ellipsoid-scaled space and is suitable\r\n * for use with {@link EllipsoidalOccluder#isScaledSpacePointVisiblePossiblyUnderEllipsoid}.\r\n *\r\n * @param {Cartesian3} directionToPoint The direction that the computed point will lie along.\r\n *                     A reasonable direction to use is the direction from the center of the ellipsoid to\r\n *                     the center of the bounding sphere computed from the positions.  The direction need not\r\n *                     be normalized.\r\n * @param {Cartesian3[]} positions The positions from which to compute the horizon culling point.  The positions\r\n *                       must be expressed in a reference frame centered at the ellipsoid and aligned with the\r\n *                       ellipsoid's axes.\r\n * @param {Number} [minimumHeight] The minimum height of all positions. If this value is undefined, all positions are assumed to be above the ellipsoid.\r\n * @param {Cartesian3} [result] The instance on which to store the result instead of allocating a new instance.\r\n * @returns {Cartesian3} The computed horizon culling point, expressed in the possibly-shrunk ellipsoid-scaled space.\r\n */\r\nEllipsoidalOccluder.prototype.computeHorizonCullingPointPossiblyUnderEllipsoid = function (directionToPoint, positions, minimumHeight, result) {\r\n    var possiblyShrunkEllipsoid = getPossiblyShrunkEllipsoid(this._ellipsoid, minimumHeight, scratchEllipsoidShrunk);\r\n    return computeHorizonCullingPointFromPositions(possiblyShrunkEllipsoid, directionToPoint, positions, result);\r\n};\r\n/**\r\n * Computes a point that can be used for horizon culling from a list of positions.  If the point is below\r\n * the horizon, all of the positions are guaranteed to be below the horizon as well.  The returned point\r\n * is expressed in the ellipsoid-scaled space and is suitable for use with\r\n * {@link EllipsoidalOccluder#isScaledSpacePointVisible}.\r\n *\r\n * @param {Cartesian3} directionToPoint The direction that the computed point will lie along.\r\n *                     A reasonable direction to use is the direction from the center of the ellipsoid to\r\n *                     the center of the bounding sphere computed from the positions.  The direction need not\r\n *                     be normalized.\r\n * @param {Number[]} vertices  The vertices from which to compute the horizon culling point.  The positions\r\n *                   must be expressed in a reference frame centered at the ellipsoid and aligned with the\r\n *                   ellipsoid's axes.\r\n * @param {Number} [stride=3]\r\n * @param {Cartesian3} [center=Cartesian3.ZERO]\r\n * @param {Cartesian3} [result] The instance on which to store the result instead of allocating a new instance.\r\n * @returns {Cartesian3} The computed horizon culling point, expressed in the ellipsoid-scaled space.\r\n */\r\nEllipsoidalOccluder.prototype.computeHorizonCullingPointFromVertices = function (directionToPoint, vertices, stride, center, result) {\r\n    return computeHorizonCullingPointFromVertices(this._ellipsoid, directionToPoint, vertices, stride, center, result);\r\n};\r\n\r\n/**\r\n * Similar to {@link EllipsoidalOccluder#computeHorizonCullingPointFromVertices} except computes the culling\r\n * point relative to an ellipsoid that has been shrunk by the minimum height when the minimum height is below\r\n * the ellipsoid. The returned point is expressed in the possibly-shrunk ellipsoid-scaled space and is suitable\r\n * for use with {@link EllipsoidalOccluder#isScaledSpacePointVisiblePossiblyUnderEllipsoid}.\r\n *\r\n * @param {Cartesian3} directionToPoint The direction that the computed point will lie along.\r\n *                     A reasonable direction to use is the direction from the center of the ellipsoid to\r\n *                     the center of the bounding sphere computed from the positions.  The direction need not\r\n *                     be normalized.\r\n * @param {Number[]} vertices  The vertices from which to compute the horizon culling point.  The positions\r\n *                   must be expressed in a reference frame centered at the ellipsoid and aligned with the\r\n *                   ellipsoid's axes.\r\n * @param {Number} [stride=3]\r\n * @param {Cartesian3} [center=Cartesian3.ZERO]\r\n * @param {Number} [minimumHeight] The minimum height of all vertices. If this value is undefined, all vertices are assumed to be above the ellipsoid.\r\n * @param {Cartesian3} [result] The instance on which to store the result instead of allocating a new instance.\r\n * @returns {Cartesian3} The computed horizon culling point, expressed in the possibly-shrunk ellipsoid-scaled space.\r\n */\r\nEllipsoidalOccluder.prototype.computeHorizonCullingPointFromVerticesPossiblyUnderEllipsoid = function (directionToPoint, vertices, stride, center, minimumHeight, result) {\r\n    var possiblyShrunkEllipsoid = getPossiblyShrunkEllipsoid(this._ellipsoid, minimumHeight, scratchEllipsoidShrunk);\r\n    return computeHorizonCullingPointFromVertices(possiblyShrunkEllipsoid, directionToPoint, vertices, stride, center, result);\r\n};\r\n\r\nvar subsampleScratch = [];\r\n\r\n/**\r\n * Computes a point that can be used for horizon culling of a rectangle.  If the point is below\r\n * the horizon, the ellipsoid-conforming rectangle is guaranteed to be below the horizon as well.\r\n * The returned point is expressed in the ellipsoid-scaled space and is suitable for use with\r\n * {@link EllipsoidalOccluder#isScaledSpacePointVisible}.\r\n *\r\n * @param {Rectangle} rectangle The rectangle for which to compute the horizon culling point.\r\n * @param {Ellipsoid} ellipsoid The ellipsoid on which the rectangle is defined.  This may be different from\r\n *                    the ellipsoid used by this instance for occlusion testing.\r\n * @param {Cartesian3} [result] The instance on which to store the result instead of allocating a new instance.\r\n * @returns {Cartesian3} The computed horizon culling point, expressed in the ellipsoid-scaled space.\r\n */\r\nEllipsoidalOccluder.prototype.computeHorizonCullingPointFromRectangle = function (rectangle, ellipsoid, result) {\r\n    //>>includeStart('debug', pragmas.debug);\r\n    Check.typeOf.object('rectangle', rectangle);\r\n    //>>includeEnd('debug');\r\n\r\n    var positions = Rectangle.subsample(rectangle, ellipsoid, 0.0, subsampleScratch);\r\n    var bs = BoundingSphere.fromPoints(positions);\r\n\r\n    // If the bounding sphere center is too close to the center of the occluder, it doesn't make\r\n    // sense to try to horizon cull it.\r\n    if (Cartesian3.magnitude(bs.center) < 0.1 * ellipsoid.minimumRadius) {\r\n        return undefined;\r\n    }\r\n\r\n    return this.computeHorizonCullingPoint(bs.center, positions, result);\r\n};\r\n\r\nvar scratchEllipsoidShrunkRadii = new Cartesian3();\r\n\r\nfunction getPossiblyShrunkEllipsoid(ellipsoid, minimumHeight, result) {\r\n    if (defined(minimumHeight) && minimumHeight < 0.0 && ellipsoid.minimumRadius > -minimumHeight) {\r\n        var ellipsoidShrunkRadii = Cartesian3.fromElements(\r\n            ellipsoid.radii.x + minimumHeight,\r\n            ellipsoid.radii.y + minimumHeight,\r\n            ellipsoid.radii.z + minimumHeight,\r\n            scratchEllipsoidShrunkRadii\r\n        );\r\n        ellipsoid = Ellipsoid.fromCartesian3(ellipsoidShrunkRadii, result);\r\n    }\r\n    return ellipsoid;\r\n}\r\n\r\nfunction computeHorizonCullingPointFromPositions(ellipsoid, directionToPoint, positions, result) {\r\n    //>>includeStart('debug', pragmas.debug);\r\n    Check.typeOf.object('directionToPoint', directionToPoint);\r\n    Check.defined('positions', positions);\r\n    //>>includeEnd('debug');\r\n\r\n    if (!defined(result)) {\r\n        result = new Cartesian3();\r\n    }\r\n\r\n    var scaledSpaceDirectionToPoint = computeScaledSpaceDirectionToPoint(ellipsoid, directionToPoint);\r\n    var resultMagnitude = 0.0;\r\n\r\n    for (var i = 0, len = positions.length; i < len; ++i) {\r\n        var position = positions[i];\r\n        var candidateMagnitude = computeMagnitude(ellipsoid, position, scaledSpaceDirectionToPoint);\r\n        if (candidateMagnitude < 0.0) {\r\n            // all points should face the same direction, but this one doesn't, so return undefined\r\n            return undefined;\r\n        }\r\n        resultMagnitude = Math.max(resultMagnitude, candidateMagnitude);\r\n    }\r\n\r\n    return magnitudeToPoint(scaledSpaceDirectionToPoint, resultMagnitude, result);\r\n}\r\n\r\nvar positionScratch = new Cartesian3();\r\n\r\nfunction computeHorizonCullingPointFromVertices(ellipsoid, directionToPoint, vertices, stride, center, result) {\r\n    //>>includeStart('debug', pragmas.debug);\r\n    Check.typeOf.object('directionToPoint', directionToPoint);\r\n    Check.defined('vertices', vertices);\r\n    Check.typeOf.number('stride', stride);\r\n    //>>includeEnd('debug');\r\n\r\n    if (!defined(result)) {\r\n        result = new Cartesian3();\r\n    }\r\n\r\n    stride = defaultValue(stride, 3);\r\n    center = defaultValue(center, Cartesian3.ZERO);\r\n    var scaledSpaceDirectionToPoint = computeScaledSpaceDirectionToPoint(ellipsoid, directionToPoint);\r\n    var resultMagnitude = 0.0;\r\n\r\n    for (var i = 0, len = vertices.length; i < len; i += stride) {\r\n        positionScratch.x = vertices[i] + center.x;\r\n        positionScratch.y = vertices[i + 1] + center.y;\r\n        positionScratch.z = vertices[i + 2] + center.z;\r\n\r\n        var candidateMagnitude = computeMagnitude(ellipsoid, positionScratch, scaledSpaceDirectionToPoint);\r\n        if (candidateMagnitude < 0.0) {\r\n            // all points should face the same direction, but this one doesn't, so return undefined\r\n            return undefined;\r\n        }\r\n        resultMagnitude = Math.max(resultMagnitude, candidateMagnitude);\r\n    }\r\n\r\n    return magnitudeToPoint(scaledSpaceDirectionToPoint, resultMagnitude, result);\r\n}\r\n\r\nfunction isScaledSpacePointVisible(occludeeScaledSpacePosition, cameraPositionInScaledSpace, distanceToLimbInScaledSpaceSquared) {\r\n    // See https://cesium.com/blog/2013/04/25/Horizon-culling/\r\n    var cv = cameraPositionInScaledSpace;\r\n    var vhMagnitudeSquared = distanceToLimbInScaledSpaceSquared;\r\n    var vt = Cartesian3.subtract(occludeeScaledSpacePosition, cv, scratchCartesian);\r\n    var vtDotVc = -Cartesian3.dot(vt, cv);\r\n    // If vhMagnitudeSquared < 0 then we are below the surface of the ellipsoid and\r\n    // in this case, set the culling plane to be on V.\r\n    var isOccluded = vhMagnitudeSquared < 0 ? vtDotVc > 0 : vtDotVc > vhMagnitudeSquared && (vtDotVc * vtDotVc) / Cartesian3.magnitudeSquared(vt) > vhMagnitudeSquared;\r\n    return !isOccluded;\r\n}\r\n\r\nvar scaledSpaceScratch = new Cartesian3();\r\nvar directionScratch = new Cartesian3();\r\n\r\nfunction computeMagnitude(ellipsoid, position, scaledSpaceDirectionToPoint) {\r\n    var scaledSpacePosition = ellipsoid.transformPositionToScaledSpace(position, scaledSpaceScratch);\r\n    var magnitudeSquared = Cartesian3.magnitudeSquared(scaledSpacePosition);\r\n    var magnitude = Math.sqrt(magnitudeSquared);\r\n    var direction = Cartesian3.divideByScalar(scaledSpacePosition, magnitude, directionScratch);\r\n\r\n    // For the purpose of this computation, points below the ellipsoid are consider to be on it instead.\r\n    magnitudeSquared = Math.max(1.0, magnitudeSquared);\r\n    magnitude = Math.max(1.0, magnitude);\r\n\r\n    var cosAlpha = Cartesian3.dot(direction, scaledSpaceDirectionToPoint);\r\n    var sinAlpha = Cartesian3.magnitude(Cartesian3.cross(direction, scaledSpaceDirectionToPoint, direction));\r\n    var cosBeta = 1.0 / magnitude;\r\n    var sinBeta = Math.sqrt(magnitudeSquared - 1.0) * cosBeta;\r\n\r\n    return 1.0 / (cosAlpha * cosBeta - sinAlpha * sinBeta);\r\n}\r\n\r\nfunction magnitudeToPoint(scaledSpaceDirectionToPoint, resultMagnitude, result) {\r\n    // The horizon culling point is undefined if there were no positions from which to compute it,\r\n    // the directionToPoint is pointing opposite all of the positions,  or if we computed NaN or infinity.\r\n    if (resultMagnitude <= 0.0 || resultMagnitude === 1.0 / 0.0 || resultMagnitude !== resultMagnitude) {\r\n        return undefined;\r\n    }\r\n\r\n    return Cartesian3.multiplyByScalar(scaledSpaceDirectionToPoint, resultMagnitude, result);\r\n}\r\n\r\nvar directionToPointScratch = new Cartesian3();\r\n\r\nfunction computeScaledSpaceDirectionToPoint(ellipsoid, directionToPoint) {\r\n    if (Cartesian3.equals(directionToPoint, Cartesian3.ZERO)) {\r\n        return directionToPoint;\r\n    }\r\n\r\n    ellipsoid.transformPositionToScaledSpace(directionToPoint, directionToPointScratch);\r\n    return Cartesian3.normalize(directionToPointScratch, directionToPointScratch);\r\n}\r\nexport default EllipsoidalOccluder;\r\n","import Cartesian3 from './Cartesian3.js';\r\n\r\n/**\r\n * @private\r\n */\r\nvar TerrainExaggeration = {};\r\n\r\n/**\r\n * Scales a height relative to an offset.\r\n *\r\n * @param {Number} height The height.\r\n * @param {Number} scale A scalar used to exaggerate the terrain. If the value is 1.0 there will be no effect.\r\n * @param {Number} relativeHeight The height relative to which terrain is exaggerated. If the value is 0.0 terrain will be exaggerated relative to the ellipsoid surface.\r\n */\r\nTerrainExaggeration.getHeight = function (height, scale, relativeHeight) {\r\n    return (height - relativeHeight) * scale + relativeHeight;\r\n};\r\n\r\nvar scratchCartographic = new Cartesian3();\r\n\r\n/**\r\n * Scales a position by exaggeration.\r\n */\r\nTerrainExaggeration.getPosition = function (position, ellipsoid, terrainExaggeration, terrainExaggerationRelativeHeight, result) {\r\n    var cartographic = ellipsoid.cartesianToCartographic(position, scratchCartographic);\r\n    var newHeight = TerrainExaggeration.getHeight(cartographic.height, terrainExaggeration, terrainExaggerationRelativeHeight);\r\n    return Cartesian3.fromRadians(cartographic.longitude, cartographic.latitude, newHeight, ellipsoid, result);\r\n};\r\n\r\nexport default TerrainExaggeration;\r\n","/**\r\n * This enumerated type is used to determine how the vertices of the terrain mesh are compressed.\r\n *\r\n * @enum {Number}\r\n *\r\n * @private\r\n */\r\nvar TerrainQuantization = {\r\n    /**\r\n     * The vertices are not compressed.\r\n     *\r\n     * @type {Number}\r\n     * @constant\r\n     */\r\n    NONE: 0,\r\n\r\n    /**\r\n     * The vertices are compressed to 12 bits.\r\n     *\r\n     * @type {Number}\r\n     * @constant\r\n     */\r\n    BITS12: 1\r\n};\r\nexport default Object.freeze(TerrainQuantization);\r\n","import AttributeCompression from './AttributeCompression.js';\r\nimport Cartesian2 from './Cartesian2.js';\r\nimport Cartesian3 from './Cartesian3.js';\r\nimport ComponentDatatype from './ComponentDatatype.js';\r\nimport defaultValue from './defaultValue.js';\r\nimport defined from './defined.js';\r\nimport CesiumMath from './Math.js';\r\nimport Matrix4 from './Matrix4.js';\r\nimport TerrainExaggeration from './TerrainExaggeration.js';\r\nimport TerrainQuantization from './TerrainQuantization.js';\r\n\r\nvar cartesian3Scratch = new Cartesian3();\r\nvar cartesian3DimScratch = new Cartesian3();\r\nvar cartesian2Scratch = new Cartesian2();\r\nvar matrix4Scratch = new Matrix4();\r\nvar matrix4Scratch2 = new Matrix4();\r\n\r\nvar SHIFT_LEFT_12 = Math.pow(2.0, 12.0);\r\n\r\n/**\r\n * Data used to quantize and pack the terrain mesh. The position can be unpacked for picking and all attributes\r\n * are unpacked in the vertex shader.\r\n *\r\n * @alias TerrainEncoding\r\n * @constructor\r\n *\r\n * @param {Cartesian3} center The center point of the vertices.\r\n * @param {AxisAlignedBoundingBox} axisAlignedBoundingBox The bounds of the tile in the east-north-up coordinates at the tiles center.\r\n * @param {Number} minimumHeight The minimum height.\r\n * @param {Number} maximumHeight The maximum height.\r\n * @param {Matrix4} fromENU The east-north-up to fixed frame matrix at the center of the terrain mesh.\r\n * @param {Boolean} hasVertexNormals If the mesh has vertex normals.\r\n * @param {Boolean} [hasWebMercatorT=false] true if the terrain data includes a Web Mercator texture coordinate; otherwise, false.\r\n * @param {Boolean} [hasGeodeticSurfaceNormals=false] true if the terrain data includes geodetic surface normals; otherwise, false.\r\n * @param {Number} [exaggeration=1.0] A scalar used to exaggerate terrain.\r\n * @param {Number} [exaggerationRelativeHeight=0.0] The relative height from which terrain is exaggerated.\r\n *\r\n * @private\r\n */\r\nfunction TerrainEncoding(\r\n    center,\r\n    axisAlignedBoundingBox,\r\n    minimumHeight,\r\n    maximumHeight,\r\n    fromENU,\r\n    hasVertexNormals,\r\n    hasWebMercatorT,\r\n    hasGeodeticSurfaceNormals,\r\n    exaggeration,\r\n    exaggerationRelativeHeight\r\n) {\r\n    var quantization = TerrainQuantization.NONE;\r\n    var toENU;\r\n    var matrix;\r\n\r\n    if (defined(axisAlignedBoundingBox) && defined(minimumHeight) && defined(maximumHeight) && defined(fromENU)) {\r\n        var minimum = axisAlignedBoundingBox.minimum;\r\n        var maximum = axisAlignedBoundingBox.maximum;\r\n\r\n        var dimensions = Cartesian3.subtract(maximum, minimum, cartesian3DimScratch);\r\n        var hDim = maximumHeight - minimumHeight;\r\n        var maxDim = Math.max(Cartesian3.maximumComponent(dimensions), hDim);\r\n\r\n        if (maxDim < SHIFT_LEFT_12 - 1.0) {\r\n            quantization = TerrainQuantization.BITS12;\r\n        } else {\r\n            quantization = TerrainQuantization.NONE;\r\n        }\r\n\r\n        toENU = Matrix4.inverseTransformation(fromENU, new Matrix4());\r\n\r\n        var translation = Cartesian3.negate(minimum, cartesian3Scratch);\r\n        Matrix4.multiply(Matrix4.fromTranslation(translation, matrix4Scratch), toENU, toENU);\r\n\r\n        var scale = cartesian3Scratch;\r\n        scale.x = 1.0 / dimensions.x;\r\n        scale.y = 1.0 / dimensions.y;\r\n        scale.z = 1.0 / dimensions.z;\r\n        Matrix4.multiply(Matrix4.fromScale(scale, matrix4Scratch), toENU, toENU);\r\n\r\n        matrix = Matrix4.clone(fromENU);\r\n        Matrix4.setTranslation(matrix, Cartesian3.ZERO, matrix);\r\n\r\n        fromENU = Matrix4.clone(fromENU, new Matrix4());\r\n\r\n        var translationMatrix = Matrix4.fromTranslation(minimum, matrix4Scratch);\r\n        var scaleMatrix = Matrix4.fromScale(dimensions, matrix4Scratch2);\r\n        var st = Matrix4.multiply(translationMatrix, scaleMatrix, matrix4Scratch);\r\n\r\n        Matrix4.multiply(fromENU, st, fromENU);\r\n        Matrix4.multiply(matrix, st, matrix);\r\n    }\r\n\r\n    /**\r\n     * How the vertices of the mesh were compressed.\r\n     * @type {TerrainQuantization}\r\n     */\r\n    this.quantization = quantization;\r\n\r\n    /**\r\n     * The minimum height of the tile including the skirts.\r\n     * @type {Number}\r\n     */\r\n    this.minimumHeight = minimumHeight;\r\n\r\n    /**\r\n     * The maximum height of the tile.\r\n     * @type {Number}\r\n     */\r\n    this.maximumHeight = maximumHeight;\r\n\r\n    /**\r\n     * The center of the tile.\r\n     * @type {Cartesian3}\r\n     */\r\n    this.center = Cartesian3.clone(center);\r\n\r\n    /**\r\n     * A matrix that takes a vertex from the tile, transforms it to east-north-up at the center and scales\r\n     * it so each component is in the [0, 1] range.\r\n     * @type {Matrix4}\r\n     */\r\n    this.toScaledENU = toENU;\r\n\r\n    /**\r\n     * A matrix that restores a vertex transformed with toScaledENU back to the earth fixed reference frame\r\n     * @type {Matrix4}\r\n     */\r\n    this.fromScaledENU = fromENU;\r\n\r\n    /**\r\n     * The matrix used to decompress the terrain vertices in the shader for RTE rendering.\r\n     * @type {Matrix4}\r\n     */\r\n    this.matrix = matrix;\r\n\r\n    /**\r\n     * The terrain mesh contains normals.\r\n     * @type {Boolean}\r\n     */\r\n    this.hasVertexNormals = hasVertexNormals;\r\n\r\n    /**\r\n     * The terrain mesh contains a vertical texture coordinate following the Web Mercator projection.\r\n     * @type {Boolean}\r\n     */\r\n    this.hasWebMercatorT = defaultValue(hasWebMercatorT, false);\r\n\r\n    /**\r\n     * The terrain mesh contains geodetic surface normals, used for terrain exaggeration.\r\n     * @type {Boolean}\r\n     */\r\n    this.hasGeodeticSurfaceNormals = defaultValue(hasGeodeticSurfaceNormals, false);\r\n\r\n    /**\r\n     * A scalar used to exaggerate terrain.\r\n     * @type {Number}\r\n     */\r\n    this.exaggeration = defaultValue(exaggeration, 1.0);\r\n\r\n    /**\r\n     * The relative height from which terrain is exaggerated.\r\n     */\r\n    this.exaggerationRelativeHeight = defaultValue(exaggerationRelativeHeight, 0.0);\r\n\r\n    /**\r\n     * The number of components in each vertex. This value can differ with different quantizations.\r\n     * @type {Number}\r\n     */\r\n    this.stride = 0;\r\n\r\n    this._offsetGeodeticSurfaceNormal = 0;\r\n    this._offsetVertexNormal = 0;\r\n\r\n    // Calculate the stride and offsets declared above\r\n    this._calculateStrideAndOffsets();\r\n}\r\n\r\nTerrainEncoding.prototype.encode = function (vertexBuffer, bufferIndex, position, uv, height, normalToPack, webMercatorT, geodeticSurfaceNormal) {\r\n    var u = uv.x;\r\n    var v = uv.y;\r\n\r\n    if (this.quantization === TerrainQuantization.BITS12) {\r\n        position = Matrix4.multiplyByPoint(this.toScaledENU, position, cartesian3Scratch);\r\n\r\n        position.x = CesiumMath.clamp(position.x, 0.0, 1.0);\r\n        position.y = CesiumMath.clamp(position.y, 0.0, 1.0);\r\n        position.z = CesiumMath.clamp(position.z, 0.0, 1.0);\r\n\r\n        var hDim = this.maximumHeight - this.minimumHeight;\r\n        var h = CesiumMath.clamp((height - this.minimumHeight) / hDim, 0.0, 1.0);\r\n\r\n        Cartesian2.fromElements(position.x, position.y, cartesian2Scratch);\r\n        var compressed0 = AttributeCompression.compressTextureCoordinates(cartesian2Scratch);\r\n\r\n        Cartesian2.fromElements(position.z, h, cartesian2Scratch);\r\n        var compressed1 = AttributeCompression.compressTextureCoordinates(cartesian2Scratch);\r\n\r\n        Cartesian2.fromElements(u, v, cartesian2Scratch);\r\n        var compressed2 = AttributeCompression.compressTextureCoordinates(cartesian2Scratch);\r\n\r\n        vertexBuffer[bufferIndex++] = compressed0;\r\n        vertexBuffer[bufferIndex++] = compressed1;\r\n        vertexBuffer[bufferIndex++] = compressed2;\r\n\r\n        if (this.hasWebMercatorT) {\r\n            Cartesian2.fromElements(webMercatorT, 0.0, cartesian2Scratch);\r\n            var compressed3 = AttributeCompression.compressTextureCoordinates(cartesian2Scratch);\r\n            vertexBuffer[bufferIndex++] = compressed3;\r\n        }\r\n    } else {\r\n        Cartesian3.subtract(position, this.center, cartesian3Scratch);\r\n\r\n        vertexBuffer[bufferIndex++] = cartesian3Scratch.x;\r\n        vertexBuffer[bufferIndex++] = cartesian3Scratch.y;\r\n        vertexBuffer[bufferIndex++] = cartesian3Scratch.z;\r\n        vertexBuffer[bufferIndex++] = height;\r\n        vertexBuffer[bufferIndex++] = u;\r\n        vertexBuffer[bufferIndex++] = v;\r\n\r\n        if (this.hasWebMercatorT) {\r\n            vertexBuffer[bufferIndex++] = webMercatorT;\r\n        }\r\n    }\r\n\r\n    if (this.hasVertexNormals) {\r\n        vertexBuffer[bufferIndex++] = AttributeCompression.octPackFloat(normalToPack);\r\n    }\r\n\r\n    if (this.hasGeodeticSurfaceNormals) {\r\n        vertexBuffer[bufferIndex++] = geodeticSurfaceNormal.x;\r\n        vertexBuffer[bufferIndex++] = geodeticSurfaceNormal.y;\r\n        vertexBuffer[bufferIndex++] = geodeticSurfaceNormal.z;\r\n    }\r\n\r\n    return bufferIndex;\r\n};\r\n\r\nvar scratchPosition = new Cartesian3();\r\nvar scratchGeodeticSurfaceNormal = new Cartesian3();\r\n\r\nTerrainEncoding.prototype.addGeodeticSurfaceNormals = function (oldBuffer, newBuffer, ellipsoid) {\r\n    if (this.hasGeodeticSurfaceNormals) {\r\n        return;\r\n    }\r\n\r\n    var oldStride = this.stride;\r\n    var vertexCount = oldBuffer.length / oldStride;\r\n    this.hasGeodeticSurfaceNormals = true;\r\n    this._calculateStrideAndOffsets();\r\n    var newStride = this.stride;\r\n\r\n    for (var index = 0; index < vertexCount; index++) {\r\n        for (var offset = 0; offset < oldStride; offset++) {\r\n            var oldIndex = index * oldStride + offset;\r\n            var newIndex = index * newStride + offset;\r\n            newBuffer[newIndex] = oldBuffer[oldIndex];\r\n        }\r\n        var position = this.decodePosition(newBuffer, index, scratchPosition);\r\n        var geodeticSurfaceNormal = ellipsoid.geodeticSurfaceNormal(position, scratchGeodeticSurfaceNormal);\r\n\r\n        var bufferIndex = index * newStride + this._offsetGeodeticSurfaceNormal;\r\n        newBuffer[bufferIndex] = geodeticSurfaceNormal.x;\r\n        newBuffer[bufferIndex + 1] = geodeticSurfaceNormal.y;\r\n        newBuffer[bufferIndex + 2] = geodeticSurfaceNormal.z;\r\n    }\r\n};\r\n\r\nTerrainEncoding.prototype.removeGeodeticSurfaceNormals = function (oldBuffer, newBuffer) {\r\n    if (!this.hasGeodeticSurfaceNormals) {\r\n        return;\r\n    }\r\n\r\n    var oldStride = this.stride;\r\n    var vertexCount = oldBuffer.length / oldStride;\r\n    this.hasGeodeticSurfaceNormals = false;\r\n    this._calculateStrideAndOffsets();\r\n    var newStride = this.stride;\r\n\r\n    for (var index = 0; index < vertexCount; index++) {\r\n        for (var offset = 0; offset < newStride; offset++) {\r\n            var oldIndex = index * oldStride + offset;\r\n            var newIndex = index * newStride + offset;\r\n            newBuffer[newIndex] = oldBuffer[oldIndex];\r\n        }\r\n    }\r\n};\r\n\r\nTerrainEncoding.prototype.decodePosition = function (buffer, index, result) {\r\n    if (!defined(result)) {\r\n        result = new Cartesian3();\r\n    }\r\n\r\n    index *= this.stride;\r\n\r\n    if (this.quantization === TerrainQuantization.BITS12) {\r\n        var xy = AttributeCompression.decompressTextureCoordinates(buffer[index], cartesian2Scratch);\r\n        result.x = xy.x;\r\n        result.y = xy.y;\r\n\r\n        var zh = AttributeCompression.decompressTextureCoordinates(buffer[index + 1], cartesian2Scratch);\r\n        result.z = zh.x;\r\n\r\n        return Matrix4.multiplyByPoint(this.fromScaledENU, result, result);\r\n    }\r\n\r\n    result.x = buffer[index];\r\n    result.y = buffer[index + 1];\r\n    result.z = buffer[index + 2];\r\n    return Cartesian3.add(result, this.center, result);\r\n};\r\n\r\nTerrainEncoding.prototype.getExaggeratedPosition = function (buffer, index, result) {\r\n    result = this.decodePosition(buffer, index, result);\r\n\r\n    var exaggeration = this.exaggeration;\r\n    var exaggerationRelativeHeight = this.exaggerationRelativeHeight;\r\n    var hasExaggeration = exaggeration !== 1.0;\r\n    if (hasExaggeration && this.hasGeodeticSurfaceNormals) {\r\n        var geodeticSurfaceNormal = this.decodeGeodeticSurfaceNormal(buffer, index, scratchGeodeticSurfaceNormal);\r\n        var rawHeight = this.decodeHeight(buffer, index);\r\n        var heightDifference = TerrainExaggeration.getHeight(rawHeight, exaggeration, exaggerationRelativeHeight) - rawHeight;\r\n\r\n        // some math is unrolled for better performance\r\n        result.x += geodeticSurfaceNormal.x * heightDifference;\r\n        result.y += geodeticSurfaceNormal.y * heightDifference;\r\n        result.z += geodeticSurfaceNormal.z * heightDifference;\r\n    }\r\n\r\n    return result;\r\n};\r\n\r\nTerrainEncoding.prototype.decodeTextureCoordinates = function (buffer, index, result) {\r\n    if (!defined(result)) {\r\n        result = new Cartesian2();\r\n    }\r\n\r\n    index *= this.stride;\r\n\r\n    if (this.quantization === TerrainQuantization.BITS12) {\r\n        return AttributeCompression.decompressTextureCoordinates(buffer[index + 2], result);\r\n    }\r\n\r\n    return Cartesian2.fromElements(buffer[index + 4], buffer[index + 5], result);\r\n};\r\n\r\nTerrainEncoding.prototype.decodeHeight = function (buffer, index) {\r\n    index *= this.stride;\r\n\r\n    if (this.quantization === TerrainQuantization.BITS12) {\r\n        var zh = AttributeCompression.decompressTextureCoordinates(buffer[index + 1], cartesian2Scratch);\r\n        return zh.y * (this.maximumHeight - this.minimumHeight) + this.minimumHeight;\r\n    }\r\n\r\n    return buffer[index + 3];\r\n};\r\n\r\nTerrainEncoding.prototype.decodeWebMercatorT = function (buffer, index) {\r\n    index *= this.stride;\r\n\r\n    if (this.quantization === TerrainQuantization.BITS12) {\r\n        return AttributeCompression.decompressTextureCoordinates(buffer[index + 3], cartesian2Scratch).x;\r\n    }\r\n\r\n    return buffer[index + 6];\r\n};\r\n\r\nTerrainEncoding.prototype.getOctEncodedNormal = function (buffer, index, result) {\r\n    index = index * this.stride + this._offsetVertexNormal;\r\n\r\n    var temp = buffer[index] / 256.0;\r\n    var x = Math.floor(temp);\r\n    var y = (temp - x) * 256.0;\r\n\r\n    return Cartesian2.fromElements(x, y, result);\r\n};\r\n\r\nTerrainEncoding.prototype.decodeGeodeticSurfaceNormal = function (buffer, index, result) {\r\n    index = index * this.stride + this._offsetGeodeticSurfaceNormal;\r\n\r\n    result.x = buffer[index];\r\n    result.y = buffer[index + 1];\r\n    result.z = buffer[index + 2];\r\n    return result;\r\n};\r\n\r\nTerrainEncoding.prototype._calculateStrideAndOffsets = function () {\r\n    var vertexStride = 0;\r\n\r\n    switch (this.quantization) {\r\n        case TerrainQuantization.BITS12:\r\n            vertexStride += 3;\r\n            break;\r\n        default:\r\n            vertexStride += 6;\r\n    }\r\n    if (this.hasWebMercatorT) {\r\n        vertexStride += 1;\r\n    }\r\n    if (this.hasVertexNormals) {\r\n        this._offsetVertexNormal = vertexStride;\r\n        vertexStride += 1;\r\n    }\r\n    if (this.hasGeodeticSurfaceNormals) {\r\n        this._offsetGeodeticSurfaceNormal = vertexStride;\r\n        vertexStride += 3;\r\n    }\r\n\r\n    this.stride = vertexStride;\r\n};\r\n\r\nvar attributesIndicesNone = {\r\n    position3DAndHeight: 0,\r\n    textureCoordAndEncodedNormals: 1,\r\n    geodeticSurfaceNormal: 2\r\n};\r\nvar attributesIndicesBits12 = {\r\n    compressed0: 0,\r\n    compressed1: 1,\r\n    geodeticSurfaceNormal: 2\r\n};\r\n\r\nTerrainEncoding.prototype.getAttributes = function (buffer) {\r\n    var datatype = ComponentDatatype.FLOAT;\r\n    var sizeInBytes = ComponentDatatype.getSizeInBytes(datatype);\r\n    var strideInBytes = this.stride * sizeInBytes;\r\n    var offsetInBytes = 0;\r\n\r\n    var attributes = [];\r\n    function addAttribute(index, componentsPerAttribute) {\r\n        attributes.push({\r\n            index: index,\r\n            vertexBuffer: buffer,\r\n            componentDatatype: datatype,\r\n            componentsPerAttribute: componentsPerAttribute,\r\n            offsetInBytes: offsetInBytes,\r\n            strideInBytes: strideInBytes\r\n        });\r\n        offsetInBytes += componentsPerAttribute * sizeInBytes;\r\n    }\r\n\r\n    if (this.quantization === TerrainQuantization.NONE) {\r\n        addAttribute(attributesIndicesNone.position3DAndHeight, 4);\r\n\r\n        var componentsTexCoordAndNormals = 2;\r\n        componentsTexCoordAndNormals += this.hasWebMercatorT ? 1 : 0;\r\n        componentsTexCoordAndNormals += this.hasVertexNormals ? 1 : 0;\r\n        addAttribute(attributesIndicesNone.textureCoordAndEncodedNormals, componentsTexCoordAndNormals);\r\n\r\n        if (this.hasGeodeticSurfaceNormals) {\r\n            addAttribute(attributesIndicesNone.geodeticSurfaceNormal, 3);\r\n        }\r\n    } else {\r\n        // When there is no webMercatorT or vertex normals, the attribute only needs 3 components: x/y, z/h, u/v.\r\n        // WebMercatorT and vertex normals each take up one component, so if only one of them is present the first\r\n        // attribute gets a 4th component. If both are present, we need an additional attribute that has 1 component.\r\n        var usingAttribute0Component4 = this.hasWebMercatorT || this.hasVertexNormals;\r\n        var usingAttribute1Component1 = this.hasWebMercatorT && this.hasVertexNormals;\r\n        addAttribute(attributesIndicesBits12.compressed0, usingAttribute0Component4 ? 4 : 3);\r\n\r\n        if (usingAttribute1Component1) {\r\n            addAttribute(attributesIndicesBits12.compressed1, 1);\r\n        }\r\n\r\n        if (this.hasGeodeticSurfaceNormals) {\r\n            addAttribute(attributesIndicesBits12.geodeticSurfaceNormal, 3);\r\n        }\r\n    }\r\n\r\n    return attributes;\r\n};\r\n\r\nTerrainEncoding.prototype.getAttributeLocations = function () {\r\n    if (this.quantization === TerrainQuantization.NONE) {\r\n        return attributesIndicesNone;\r\n    }\r\n    return attributesIndicesBits12;\r\n};\r\n\r\nTerrainEncoding.clone = function (encoding, result) {\r\n    if (!defined(encoding)) {\r\n        return undefined;\r\n    }\r\n    if (!defined(result)) {\r\n        result = new TerrainEncoding();\r\n    }\r\n\r\n    result.quantization = encoding.quantization;\r\n    result.minimumHeight = encoding.minimumHeight;\r\n    result.maximumHeight = encoding.maximumHeight;\r\n    result.center = Cartesian3.clone(encoding.center);\r\n    result.toScaledENU = Matrix4.clone(encoding.toScaledENU);\r\n    result.fromScaledENU = Matrix4.clone(encoding.fromScaledENU);\r\n    result.matrix = Matrix4.clone(encoding.matrix);\r\n    result.hasVertexNormals = encoding.hasVertexNormals;\r\n    result.hasWebMercatorT = encoding.hasWebMercatorT;\r\n    result.hasGeodeticSurfaceNormals = encoding.hasGeodeticSurfaceNormals;\r\n    result.exaggeration = encoding.exaggeration;\r\n    result.exaggerationRelativeHeight = encoding.exaggerationRelativeHeight;\r\n\r\n    result._calculateStrideAndOffsets();\r\n\r\n    return result;\r\n};\r\nexport default TerrainEncoding;\r\n"],"names":["Check","Cartesian3","defined","Ellipsoid","Rectangle","BoundingSphere","defaultValue","Cartesian2","Matrix4","TerrainQuantization","CesiumMath","AttributeCompression","ComponentDatatype"],"mappings":"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"}