{"version":3,"file":"OrientedBoundingBox-49f70ee6.js","sources":["../../../../Source/Core/OrientedBoundingBox.js"],"sourcesContent":["import BoundingSphere from './BoundingSphere.js';\r\nimport Cartesian2 from './Cartesian2.js';\r\nimport Cartesian3 from './Cartesian3.js';\r\nimport Cartographic from './Cartographic.js';\r\nimport Check from './Check.js';\r\nimport defaultValue from './defaultValue.js';\r\nimport defined from './defined.js';\r\nimport DeveloperError from './DeveloperError.js';\r\nimport Ellipsoid from './Ellipsoid.js';\r\nimport EllipsoidTangentPlane from './EllipsoidTangentPlane.js';\r\nimport Intersect from './Intersect.js';\r\nimport Interval from './Interval.js';\r\nimport CesiumMath from './Math.js';\r\nimport Matrix3 from './Matrix3.js';\r\nimport Plane from './Plane.js';\r\nimport Rectangle from './Rectangle.js';\r\n\r\n/**\r\n * Creates an instance of an OrientedBoundingBox.\r\n * An OrientedBoundingBox of some object is a closed and convex cuboid. It can provide a tighter bounding volume than {@link BoundingSphere} or {@link AxisAlignedBoundingBox} in many cases.\r\n * @alias OrientedBoundingBox\r\n * @constructor\r\n *\r\n * @param {Cartesian3} [center=Cartesian3.ZERO] The center of the box.\r\n * @param {Matrix3} [halfAxes=Matrix3.ZERO] The three orthogonal half-axes of the bounding box.\r\n *                                          Equivalently, the transformation matrix, to rotate and scale a 0x0x0\r\n *                                          cube centered at the origin.\r\n *\r\n *\r\n * @example\r\n * // Create an OrientedBoundingBox using a transformation matrix, a position where the box will be translated, and a scale.\r\n * var center = new Cesium.Cartesian3(1.0, 0.0, 0.0);\r\n * var halfAxes = Cesium.Matrix3.fromScale(new Cesium.Cartesian3(1.0, 3.0, 2.0), new Cesium.Matrix3());\r\n *\r\n * var obb = new Cesium.OrientedBoundingBox(center, halfAxes);\r\n *\r\n * @see BoundingSphere\r\n * @see BoundingRectangle\r\n */\r\nfunction OrientedBoundingBox(center, halfAxes) {\r\n    /**\r\n     * The center of the box.\r\n     * @type {Cartesian3}\r\n     * @default {@link Cartesian3.ZERO}\r\n     */\r\n    this.center = Cartesian3.clone(defaultValue(center, Cartesian3.ZERO));\r\n    /**\r\n     * The transformation matrix, to rotate the box to the right position.\r\n     * @type {Matrix3}\r\n     * @default {@link Matrix3.ZERO}\r\n     */\r\n    this.halfAxes = Matrix3.clone(defaultValue(halfAxes, Matrix3.ZERO));\r\n}\r\n\r\n/**\r\n * The number of elements used to pack the object into an array.\r\n * @type {Number}\r\n */\r\nOrientedBoundingBox.packedLength = Cartesian3.packedLength + Matrix3.packedLength;\r\n\r\n/**\r\n * Stores the provided instance into the provided array.\r\n *\r\n * @param {OrientedBoundingBox} value The value to pack.\r\n * @param {Number[]} array The array to pack into.\r\n * @param {Number} [startingIndex=0] The index into the array at which to start packing the elements.\r\n *\r\n * @returns {Number[]} The array that was packed into\r\n */\r\nOrientedBoundingBox.pack = function (value, array, startingIndex) {\r\n    //>>includeStart('debug', pragmas.debug);\r\n    Check.typeOf.object('value', value);\r\n    Check.defined('array', array);\r\n    //>>includeEnd('debug');\r\n\r\n    startingIndex = defaultValue(startingIndex, 0);\r\n\r\n    Cartesian3.pack(value.center, array, startingIndex);\r\n    Matrix3.pack(value.halfAxes, array, startingIndex + Cartesian3.packedLength);\r\n\r\n    return array;\r\n};\r\n\r\n/**\r\n * Retrieves an instance from a packed array.\r\n *\r\n * @param {Number[]} array The packed array.\r\n * @param {Number} [startingIndex=0] The starting index of the element to be unpacked.\r\n * @param {OrientedBoundingBox} [result] The object into which to store the result.\r\n * @returns {OrientedBoundingBox} The modified result parameter or a new OrientedBoundingBox instance if one was not provided.\r\n */\r\nOrientedBoundingBox.unpack = function (array, startingIndex, result) {\r\n    //>>includeStart('debug', pragmas.debug);\r\n    Check.defined('array', array);\r\n    //>>includeEnd('debug');\r\n\r\n    startingIndex = defaultValue(startingIndex, 0);\r\n\r\n    if (!defined(result)) {\r\n        result = new OrientedBoundingBox();\r\n    }\r\n\r\n    Cartesian3.unpack(array, startingIndex, result.center);\r\n    Matrix3.unpack(array, startingIndex + Cartesian3.packedLength, result.halfAxes);\r\n    return result;\r\n};\r\n\r\nvar scratchCartesian1 = new Cartesian3();\r\nvar scratchCartesian2 = new Cartesian3();\r\nvar scratchCartesian3 = new Cartesian3();\r\nvar scratchCartesian4 = new Cartesian3();\r\nvar scratchCartesian5 = new Cartesian3();\r\nvar scratchCartesian6 = new Cartesian3();\r\nvar scratchCovarianceResult = new Matrix3();\r\nvar scratchEigenResult = {\r\n    unitary: new Matrix3(),\r\n    diagonal: new Matrix3()\r\n};\r\n\r\n/**\r\n * Computes an instance of an OrientedBoundingBox of the given positions.\r\n * This is an implementation of Stefan Gottschalk's Collision Queries using Oriented Bounding Boxes solution (PHD thesis).\r\n * Reference: http://gamma.cs.unc.edu/users/gottschalk/main.pdf\r\n *\r\n * @param {Cartesian3[]} [positions] List of {@link Cartesian3} points that the bounding box will enclose.\r\n * @param {OrientedBoundingBox} [result] The object onto which to store the result.\r\n * @returns {OrientedBoundingBox} The modified result parameter or a new OrientedBoundingBox instance if one was not provided.\r\n *\r\n * @example\r\n * // Compute an object oriented bounding box enclosing two points.\r\n * var box = Cesium.OrientedBoundingBox.fromPoints([new Cesium.Cartesian3(2, 0, 0), new Cesium.Cartesian3(-2, 0, 0)]);\r\n */\r\nOrientedBoundingBox.fromPoints = function (positions, result) {\r\n    if (!defined(result)) {\r\n        result = new OrientedBoundingBox();\r\n    }\r\n\r\n    if (!defined(positions) || positions.length === 0) {\r\n        result.halfAxes = Matrix3.ZERO;\r\n        result.center = Cartesian3.ZERO;\r\n        return result;\r\n    }\r\n\r\n    var i;\r\n    var length = positions.length;\r\n\r\n    var meanPoint = Cartesian3.clone(positions[0], scratchCartesian1);\r\n    for (i = 1; i < length; i++) {\r\n        Cartesian3.add(meanPoint, positions[i], meanPoint);\r\n    }\r\n    var invLength = 1.0 / length;\r\n    Cartesian3.multiplyByScalar(meanPoint, invLength, meanPoint);\r\n\r\n    var exx = 0.0;\r\n    var exy = 0.0;\r\n    var exz = 0.0;\r\n    var eyy = 0.0;\r\n    var eyz = 0.0;\r\n    var ezz = 0.0;\r\n    var p;\r\n\r\n    for (i = 0; i < length; i++) {\r\n        p = Cartesian3.subtract(positions[i], meanPoint, scratchCartesian2);\r\n        exx += p.x * p.x;\r\n        exy += p.x * p.y;\r\n        exz += p.x * p.z;\r\n        eyy += p.y * p.y;\r\n        eyz += p.y * p.z;\r\n        ezz += p.z * p.z;\r\n    }\r\n\r\n    exx *= invLength;\r\n    exy *= invLength;\r\n    exz *= invLength;\r\n    eyy *= invLength;\r\n    eyz *= invLength;\r\n    ezz *= invLength;\r\n\r\n    var covarianceMatrix = scratchCovarianceResult;\r\n    covarianceMatrix[0] = exx;\r\n    covarianceMatrix[1] = exy;\r\n    covarianceMatrix[2] = exz;\r\n    covarianceMatrix[3] = exy;\r\n    covarianceMatrix[4] = eyy;\r\n    covarianceMatrix[5] = eyz;\r\n    covarianceMatrix[6] = exz;\r\n    covarianceMatrix[7] = eyz;\r\n    covarianceMatrix[8] = ezz;\r\n\r\n    var eigenDecomposition = Matrix3.computeEigenDecomposition(covarianceMatrix, scratchEigenResult);\r\n    var rotation = Matrix3.clone(eigenDecomposition.unitary, result.halfAxes);\r\n\r\n    var v1 = Matrix3.getColumn(rotation, 0, scratchCartesian4);\r\n    var v2 = Matrix3.getColumn(rotation, 1, scratchCartesian5);\r\n    var v3 = Matrix3.getColumn(rotation, 2, scratchCartesian6);\r\n\r\n    var u1 = -Number.MAX_VALUE;\r\n    var u2 = -Number.MAX_VALUE;\r\n    var u3 = -Number.MAX_VALUE;\r\n    var l1 = Number.MAX_VALUE;\r\n    var l2 = Number.MAX_VALUE;\r\n    var l3 = Number.MAX_VALUE;\r\n\r\n    for (i = 0; i < length; i++) {\r\n        p = positions[i];\r\n        u1 = Math.max(Cartesian3.dot(v1, p), u1);\r\n        u2 = Math.max(Cartesian3.dot(v2, p), u2);\r\n        u3 = Math.max(Cartesian3.dot(v3, p), u3);\r\n\r\n        l1 = Math.min(Cartesian3.dot(v1, p), l1);\r\n        l2 = Math.min(Cartesian3.dot(v2, p), l2);\r\n        l3 = Math.min(Cartesian3.dot(v3, p), l3);\r\n    }\r\n\r\n    v1 = Cartesian3.multiplyByScalar(v1, 0.5 * (l1 + u1), v1);\r\n    v2 = Cartesian3.multiplyByScalar(v2, 0.5 * (l2 + u2), v2);\r\n    v3 = Cartesian3.multiplyByScalar(v3, 0.5 * (l3 + u3), v3);\r\n\r\n    var center = Cartesian3.add(v1, v2, result.center);\r\n    Cartesian3.add(center, v3, center);\r\n\r\n    var scale = scratchCartesian3;\r\n    scale.x = u1 - l1;\r\n    scale.y = u2 - l2;\r\n    scale.z = u3 - l3;\r\n    Cartesian3.multiplyByScalar(scale, 0.5, scale);\r\n    Matrix3.multiplyByScale(result.halfAxes, scale, result.halfAxes);\r\n\r\n    return result;\r\n};\r\n\r\nvar scratchOffset = new Cartesian3();\r\nvar scratchScale = new Cartesian3();\r\nfunction fromPlaneExtents(planeOrigin, planeXAxis, planeYAxis, planeZAxis, minimumX, maximumX, minimumY, maximumY, minimumZ, maximumZ, result) {\r\n    //>>includeStart('debug', pragmas.debug);\r\n    if (!defined(minimumX) || !defined(maximumX) || !defined(minimumY) || !defined(maximumY) || !defined(minimumZ) || !defined(maximumZ)) {\r\n        throw new DeveloperError('all extents (minimum/maximum X/Y/Z) are required.');\r\n    }\r\n    //>>includeEnd('debug');\r\n\r\n    if (!defined(result)) {\r\n        result = new OrientedBoundingBox();\r\n    }\r\n\r\n    var halfAxes = result.halfAxes;\r\n    Matrix3.setColumn(halfAxes, 0, planeXAxis, halfAxes);\r\n    Matrix3.setColumn(halfAxes, 1, planeYAxis, halfAxes);\r\n    Matrix3.setColumn(halfAxes, 2, planeZAxis, halfAxes);\r\n\r\n    var centerOffset = scratchOffset;\r\n    centerOffset.x = (minimumX + maximumX) / 2.0;\r\n    centerOffset.y = (minimumY + maximumY) / 2.0;\r\n    centerOffset.z = (minimumZ + maximumZ) / 2.0;\r\n\r\n    var scale = scratchScale;\r\n    scale.x = (maximumX - minimumX) / 2.0;\r\n    scale.y = (maximumY - minimumY) / 2.0;\r\n    scale.z = (maximumZ - minimumZ) / 2.0;\r\n\r\n    var center = result.center;\r\n    centerOffset = Matrix3.multiplyByVector(halfAxes, centerOffset, centerOffset);\r\n    Cartesian3.add(planeOrigin, centerOffset, center);\r\n    Matrix3.multiplyByScale(halfAxes, scale, halfAxes);\r\n\r\n    return result;\r\n}\r\n\r\nvar scratchRectangleCenterCartographic = new Cartographic();\r\nvar scratchRectangleCenter = new Cartesian3();\r\nvar scratchPerimeterCartographicNC = new Cartographic();\r\nvar scratchPerimeterCartographicNW = new Cartographic();\r\nvar scratchPerimeterCartographicCW = new Cartographic();\r\nvar scratchPerimeterCartographicSW = new Cartographic();\r\nvar scratchPerimeterCartographicSC = new Cartographic();\r\nvar scratchPerimeterCartesianNC = new Cartesian3();\r\nvar scratchPerimeterCartesianNW = new Cartesian3();\r\nvar scratchPerimeterCartesianCW = new Cartesian3();\r\nvar scratchPerimeterCartesianSW = new Cartesian3();\r\nvar scratchPerimeterCartesianSC = new Cartesian3();\r\nvar scratchPerimeterProjectedNC = new Cartesian2();\r\nvar scratchPerimeterProjectedNW = new Cartesian2();\r\nvar scratchPerimeterProjectedCW = new Cartesian2();\r\nvar scratchPerimeterProjectedSW = new Cartesian2();\r\nvar scratchPerimeterProjectedSC = new Cartesian2();\r\n\r\nvar scratchPlaneOrigin = new Cartesian3();\r\nvar scratchPlaneNormal = new Cartesian3();\r\nvar scratchPlaneXAxis = new Cartesian3();\r\nvar scratchHorizonCartesian = new Cartesian3();\r\nvar scratchHorizonProjected = new Cartesian2();\r\nvar scratchMaxY = new Cartesian3();\r\nvar scratchMinY = new Cartesian3();\r\nvar scratchZ = new Cartesian3();\r\nvar scratchPlane = new Plane(Cartesian3.UNIT_X, 0.0);\r\n\r\n/**\r\n * Computes an OrientedBoundingBox that bounds a {@link Rectangle} on the surface of an {@link Ellipsoid}.\r\n * There are no guarantees about the orientation of the bounding box.\r\n *\r\n * @param {Rectangle} rectangle The cartographic rectangle on the surface of the ellipsoid.\r\n * @param {Number} [minimumHeight=0.0] The minimum height (elevation) within the tile.\r\n * @param {Number} [maximumHeight=0.0] The maximum height (elevation) within the tile.\r\n * @param {Ellipsoid} [ellipsoid=Ellipsoid.WGS84] The ellipsoid on which the rectangle is defined.\r\n * @param {OrientedBoundingBox} [result] The object onto which to store the result.\r\n * @returns {OrientedBoundingBox} The modified result parameter or a new OrientedBoundingBox instance if none was provided.\r\n *\r\n * @exception {DeveloperError} rectangle.width must be between 0 and pi.\r\n * @exception {DeveloperError} rectangle.height must be between 0 and pi.\r\n * @exception {DeveloperError} ellipsoid must be an ellipsoid of revolution (<code>radii.x == radii.y</code>)\r\n */\r\nOrientedBoundingBox.fromRectangle = function (rectangle, minimumHeight, maximumHeight, ellipsoid, result) {\r\n    //>>includeStart('debug', pragmas.debug);\r\n    if (!defined(rectangle)) {\r\n        throw new DeveloperError('rectangle is required');\r\n    }\r\n    if (rectangle.width < 0.0 || rectangle.width > CesiumMath.TWO_PI) {\r\n        throw new DeveloperError('Rectangle width must be between 0 and 2*pi');\r\n    }\r\n    if (rectangle.height < 0.0 || rectangle.height > CesiumMath.PI) {\r\n        throw new DeveloperError('Rectangle height must be between 0 and pi');\r\n    }\r\n    if (defined(ellipsoid) && !CesiumMath.equalsEpsilon(ellipsoid.radii.x, ellipsoid.radii.y, CesiumMath.EPSILON15)) {\r\n        throw new DeveloperError('Ellipsoid must be an ellipsoid of revolution (radii.x == radii.y)');\r\n    }\r\n    //>>includeEnd('debug');\r\n\r\n    minimumHeight = defaultValue(minimumHeight, 0.0);\r\n    maximumHeight = defaultValue(maximumHeight, 0.0);\r\n    ellipsoid = defaultValue(ellipsoid, Ellipsoid.WGS84);\r\n\r\n    var minX, maxX, minY, maxY, minZ, maxZ, plane;\r\n\r\n    if (rectangle.width <= CesiumMath.PI) {\r\n        // The bounding box will be aligned with the tangent plane at the center of the rectangle.\r\n        var tangentPointCartographic = Rectangle.center(rectangle, scratchRectangleCenterCartographic);\r\n        var tangentPoint = ellipsoid.cartographicToCartesian(tangentPointCartographic, scratchRectangleCenter);\r\n        var tangentPlane = new EllipsoidTangentPlane(tangentPoint, ellipsoid);\r\n        plane = tangentPlane.plane;\r\n\r\n        // If the rectangle spans the equator, CW is instead aligned with the equator (because it sticks out the farthest at the equator).\r\n        var lonCenter = tangentPointCartographic.longitude;\r\n        var latCenter = rectangle.south < 0.0 && rectangle.north > 0.0 ? 0.0 : tangentPointCartographic.latitude;\r\n\r\n        // Compute XY extents using the rectangle at maximum height\r\n        var perimeterCartographicNC = Cartographic.fromRadians(lonCenter, rectangle.north, maximumHeight, scratchPerimeterCartographicNC);\r\n        var perimeterCartographicNW = Cartographic.fromRadians(rectangle.west, rectangle.north, maximumHeight, scratchPerimeterCartographicNW);\r\n        var perimeterCartographicCW = Cartographic.fromRadians(rectangle.west, latCenter, maximumHeight, scratchPerimeterCartographicCW);\r\n        var perimeterCartographicSW = Cartographic.fromRadians(rectangle.west, rectangle.south, maximumHeight, scratchPerimeterCartographicSW);\r\n        var perimeterCartographicSC = Cartographic.fromRadians(lonCenter, rectangle.south, maximumHeight, scratchPerimeterCartographicSC);\r\n\r\n        var perimeterCartesianNC = ellipsoid.cartographicToCartesian(perimeterCartographicNC, scratchPerimeterCartesianNC);\r\n        var perimeterCartesianNW = ellipsoid.cartographicToCartesian(perimeterCartographicNW, scratchPerimeterCartesianNW);\r\n        var perimeterCartesianCW = ellipsoid.cartographicToCartesian(perimeterCartographicCW, scratchPerimeterCartesianCW);\r\n        var perimeterCartesianSW = ellipsoid.cartographicToCartesian(perimeterCartographicSW, scratchPerimeterCartesianSW);\r\n        var perimeterCartesianSC = ellipsoid.cartographicToCartesian(perimeterCartographicSC, scratchPerimeterCartesianSC);\r\n\r\n        var perimeterProjectedNC = tangentPlane.projectPointToNearestOnPlane(perimeterCartesianNC, scratchPerimeterProjectedNC);\r\n        var perimeterProjectedNW = tangentPlane.projectPointToNearestOnPlane(perimeterCartesianNW, scratchPerimeterProjectedNW);\r\n        var perimeterProjectedCW = tangentPlane.projectPointToNearestOnPlane(perimeterCartesianCW, scratchPerimeterProjectedCW);\r\n        var perimeterProjectedSW = tangentPlane.projectPointToNearestOnPlane(perimeterCartesianSW, scratchPerimeterProjectedSW);\r\n        var perimeterProjectedSC = tangentPlane.projectPointToNearestOnPlane(perimeterCartesianSC, scratchPerimeterProjectedSC);\r\n\r\n        minX = Math.min(perimeterProjectedNW.x, perimeterProjectedCW.x, perimeterProjectedSW.x);\r\n        maxX = -minX; // symmetrical\r\n\r\n        maxY = Math.max(perimeterProjectedNW.y, perimeterProjectedNC.y);\r\n        minY = Math.min(perimeterProjectedSW.y, perimeterProjectedSC.y);\r\n\r\n        // Compute minimum Z using the rectangle at minimum height, since it will be deeper than the maximum height\r\n        perimeterCartographicNW.height = perimeterCartographicSW.height = minimumHeight;\r\n        perimeterCartesianNW = ellipsoid.cartographicToCartesian(perimeterCartographicNW, scratchPerimeterCartesianNW);\r\n        perimeterCartesianSW = ellipsoid.cartographicToCartesian(perimeterCartographicSW, scratchPerimeterCartesianSW);\r\n\r\n        minZ = Math.min(Plane.getPointDistance(plane, perimeterCartesianNW), Plane.getPointDistance(plane, perimeterCartesianSW));\r\n        maxZ = maximumHeight; // Since the tangent plane touches the surface at height = 0, this is okay\r\n\r\n        return fromPlaneExtents(tangentPlane.origin, tangentPlane.xAxis, tangentPlane.yAxis, tangentPlane.zAxis, minX, maxX, minY, maxY, minZ, maxZ, result);\r\n    }\r\n\r\n    // Handle the case where rectangle width is greater than PI (wraps around more than half the ellipsoid).\r\n    var fullyAboveEquator = rectangle.south > 0.0;\r\n    var fullyBelowEquator = rectangle.north < 0.0;\r\n    var latitudeNearestToEquator = fullyAboveEquator ? rectangle.south : fullyBelowEquator ? rectangle.north : 0.0;\r\n    var centerLongitude = Rectangle.center(rectangle, scratchRectangleCenterCartographic).longitude;\r\n\r\n    // Plane is located at the rectangle's center longitude and the rectangle's latitude that is closest to the equator. It rotates around the Z axis.\r\n    // This results in a better fit than the obb approach for smaller rectangles, which orients with the rectangle's center normal.\r\n    var planeOrigin = Cartesian3.fromRadians(centerLongitude, latitudeNearestToEquator, maximumHeight, ellipsoid, scratchPlaneOrigin);\r\n    planeOrigin.z = 0.0; // center the plane on the equator to simpify plane normal calculation\r\n    var isPole = Math.abs(planeOrigin.x) < CesiumMath.EPSILON10 && Math.abs(planeOrigin.y) < CesiumMath.EPSILON10;\r\n    var planeNormal = !isPole ? Cartesian3.normalize(planeOrigin, scratchPlaneNormal) : Cartesian3.UNIT_X;\r\n    var planeYAxis = Cartesian3.UNIT_Z;\r\n    var planeXAxis = Cartesian3.cross(planeNormal, planeYAxis, scratchPlaneXAxis);\r\n    plane = Plane.fromPointNormal(planeOrigin, planeNormal, scratchPlane);\r\n\r\n    // Get the horizon point relative to the center. This will be the farthest extent in the plane's X dimension.\r\n    var horizonCartesian = Cartesian3.fromRadians(centerLongitude + CesiumMath.PI_OVER_TWO, latitudeNearestToEquator, maximumHeight, ellipsoid, scratchHorizonCartesian);\r\n    maxX = Cartesian3.dot(Plane.projectPointOntoPlane(plane, horizonCartesian, scratchHorizonProjected), planeXAxis);\r\n    minX = -maxX; // symmetrical\r\n\r\n    // Get the min and max Y, using the height that will give the largest extent\r\n    maxY = Cartesian3.fromRadians(0.0, rectangle.north, fullyBelowEquator ? minimumHeight : maximumHeight, ellipsoid, scratchMaxY).z;\r\n    minY = Cartesian3.fromRadians(0.0, rectangle.south, fullyAboveEquator ? minimumHeight : maximumHeight, ellipsoid, scratchMinY).z;\r\n\r\n    var farZ = Cartesian3.fromRadians(rectangle.east, latitudeNearestToEquator, maximumHeight, ellipsoid, scratchZ);\r\n    minZ = Plane.getPointDistance(plane, farZ);\r\n    maxZ = 0.0; // plane origin starts at maxZ already\r\n\r\n    // min and max are local to the plane axes\r\n    return fromPlaneExtents(planeOrigin, planeXAxis, planeYAxis, planeNormal, minX, maxX, minY, maxY, minZ, maxZ, result);\r\n};\r\n\r\n/**\r\n * Duplicates a OrientedBoundingBox instance.\r\n *\r\n * @param {OrientedBoundingBox} box The bounding box to duplicate.\r\n * @param {OrientedBoundingBox} [result] The object onto which to store the result.\r\n * @returns {OrientedBoundingBox} The modified result parameter or a new OrientedBoundingBox instance if none was provided. (Returns undefined if box is undefined)\r\n */\r\nOrientedBoundingBox.clone = function (box, result) {\r\n    if (!defined(box)) {\r\n        return undefined;\r\n    }\r\n\r\n    if (!defined(result)) {\r\n        return new OrientedBoundingBox(box.center, box.halfAxes);\r\n    }\r\n\r\n    Cartesian3.clone(box.center, result.center);\r\n    Matrix3.clone(box.halfAxes, result.halfAxes);\r\n\r\n    return result;\r\n};\r\n\r\n/**\r\n * Determines which side of a plane the oriented bounding box is located.\r\n *\r\n * @param {OrientedBoundingBox} box The oriented bounding box to test.\r\n * @param {Plane} plane The plane to test against.\r\n * @returns {Intersect} {@link Intersect.INSIDE} if the entire box is on the side of the plane\r\n *                      the normal is pointing, {@link Intersect.OUTSIDE} if the entire box is\r\n *                      on the opposite side, and {@link Intersect.INTERSECTING} if the box\r\n *                      intersects the plane.\r\n */\r\nOrientedBoundingBox.intersectPlane = function (box, plane) {\r\n    //>>includeStart('debug', pragmas.debug);\r\n    if (!defined(box)) {\r\n        throw new DeveloperError('box is required.');\r\n    }\r\n\r\n    if (!defined(plane)) {\r\n        throw new DeveloperError('plane is required.');\r\n    }\r\n    //>>includeEnd('debug');\r\n\r\n    var center = box.center;\r\n    var normal = plane.normal;\r\n    var halfAxes = box.halfAxes;\r\n    var normalX = normal.x,\r\n        normalY = normal.y,\r\n        normalZ = normal.z;\r\n    // plane is used as if it is its normal; the first three components are assumed to be normalized\r\n    var radEffective =\r\n        Math.abs(normalX * halfAxes[Matrix3.COLUMN0ROW0] + normalY * halfAxes[Matrix3.COLUMN0ROW1] + normalZ * halfAxes[Matrix3.COLUMN0ROW2]) +\r\n        Math.abs(normalX * halfAxes[Matrix3.COLUMN1ROW0] + normalY * halfAxes[Matrix3.COLUMN1ROW1] + normalZ * halfAxes[Matrix3.COLUMN1ROW2]) +\r\n        Math.abs(normalX * halfAxes[Matrix3.COLUMN2ROW0] + normalY * halfAxes[Matrix3.COLUMN2ROW1] + normalZ * halfAxes[Matrix3.COLUMN2ROW2]);\r\n    var distanceToPlane = Cartesian3.dot(normal, center) + plane.distance;\r\n\r\n    if (distanceToPlane <= -radEffective) {\r\n        // The entire box is on the negative side of the plane normal\r\n        return Intersect.OUTSIDE;\r\n    } else if (distanceToPlane >= radEffective) {\r\n        // The entire box is on the positive side of the plane normal\r\n        return Intersect.INSIDE;\r\n    }\r\n    return Intersect.INTERSECTING;\r\n};\r\n\r\nvar scratchCartesianU = new Cartesian3();\r\nvar scratchCartesianV = new Cartesian3();\r\nvar scratchCartesianW = new Cartesian3();\r\nvar scratchValidAxis2 = new Cartesian3();\r\nvar scratchValidAxis3 = new Cartesian3();\r\nvar scratchPPrime = new Cartesian3();\r\n\r\n/**\r\n * Computes the estimated distance squared from the closest point on a bounding box to a point.\r\n *\r\n * @param {OrientedBoundingBox} box The box.\r\n * @param {Cartesian3} cartesian The point\r\n * @returns {Number} The distance squared from the oriented bounding box to the point. Returns 0 if the point is inside the box.\r\n *\r\n * @example\r\n * // Sort bounding boxes from back to front\r\n * boxes.sort(function(a, b) {\r\n *     return Cesium.OrientedBoundingBox.distanceSquaredTo(b, camera.positionWC) - Cesium.OrientedBoundingBox.distanceSquaredTo(a, camera.positionWC);\r\n * });\r\n */\r\nOrientedBoundingBox.distanceSquaredTo = function (box, cartesian) {\r\n    // See Geometric Tools for Computer Graphics 10.4.2\r\n\r\n    //>>includeStart('debug', pragmas.debug);\r\n    if (!defined(box)) {\r\n        throw new DeveloperError('box is required.');\r\n    }\r\n    if (!defined(cartesian)) {\r\n        throw new DeveloperError('cartesian is required.');\r\n    }\r\n    //>>includeEnd('debug');\r\n\r\n    var offset = Cartesian3.subtract(cartesian, box.center, scratchOffset);\r\n\r\n    var halfAxes = box.halfAxes;\r\n    var u = Matrix3.getColumn(halfAxes, 0, scratchCartesianU);\r\n    var v = Matrix3.getColumn(halfAxes, 1, scratchCartesianV);\r\n    var w = Matrix3.getColumn(halfAxes, 2, scratchCartesianW);\r\n\r\n    var uHalf = Cartesian3.magnitude(u);\r\n    var vHalf = Cartesian3.magnitude(v);\r\n    var wHalf = Cartesian3.magnitude(w);\r\n\r\n    var uValid = true;\r\n    var vValid = true;\r\n    var wValid = true;\r\n\r\n    if (uHalf > 0) {\r\n        Cartesian3.divideByScalar(u, uHalf, u);\r\n    } else {\r\n        uValid = false;\r\n    }\r\n\r\n    if (vHalf > 0) {\r\n        Cartesian3.divideByScalar(v, vHalf, v);\r\n    } else {\r\n        vValid = false;\r\n    }\r\n\r\n    if (wHalf > 0) {\r\n        Cartesian3.divideByScalar(w, wHalf, w);\r\n    } else {\r\n        wValid = false;\r\n    }\r\n\r\n    var numberOfDegenerateAxes = !uValid + !vValid + !wValid;\r\n    var validAxis1;\r\n    var validAxis2;\r\n    var validAxis3;\r\n\r\n    if (numberOfDegenerateAxes === 1) {\r\n        var degenerateAxis = u;\r\n        validAxis1 = v;\r\n        validAxis2 = w;\r\n        if (!vValid) {\r\n            degenerateAxis = v;\r\n            validAxis1 = u;\r\n        } else if (!wValid) {\r\n            degenerateAxis = w;\r\n            validAxis2 = u;\r\n        }\r\n\r\n        validAxis3 = Cartesian3.cross(validAxis1, validAxis2, scratchValidAxis3);\r\n\r\n        if (degenerateAxis === u) {\r\n            u = validAxis3;\r\n        } else if (degenerateAxis === v) {\r\n            v = validAxis3;\r\n        } else if (degenerateAxis === w) {\r\n            w = validAxis3;\r\n        }\r\n    } else if (numberOfDegenerateAxes === 2) {\r\n        validAxis1 = u;\r\n        if (vValid) {\r\n            validAxis1 = v;\r\n        } else if (wValid) {\r\n            validAxis1 = w;\r\n        }\r\n\r\n        var crossVector = Cartesian3.UNIT_Y;\r\n        if (crossVector.equalsEpsilon(validAxis1, CesiumMath.EPSILON3)) {\r\n            crossVector = Cartesian3.UNIT_X;\r\n        }\r\n\r\n        validAxis2 = Cartesian3.cross(validAxis1, crossVector, scratchValidAxis2);\r\n        Cartesian3.normalize(validAxis2, validAxis2);\r\n        validAxis3 = Cartesian3.cross(validAxis1, validAxis2, scratchValidAxis3);\r\n        Cartesian3.normalize(validAxis3, validAxis3);\r\n\r\n        if (validAxis1 === u) {\r\n            v = validAxis2;\r\n            w = validAxis3;\r\n        } else if (validAxis1 === v) {\r\n            w = validAxis2;\r\n            u = validAxis3;\r\n        } else if (validAxis1 === w) {\r\n            u = validAxis2;\r\n            v = validAxis3;\r\n        }\r\n    } else if (numberOfDegenerateAxes === 3) {\r\n        u = Cartesian3.UNIT_X;\r\n        v = Cartesian3.UNIT_Y;\r\n        w = Cartesian3.UNIT_Z;\r\n    }\r\n\r\n    var pPrime = scratchPPrime;\r\n    pPrime.x = Cartesian3.dot(offset, u);\r\n    pPrime.y = Cartesian3.dot(offset, v);\r\n    pPrime.z = Cartesian3.dot(offset, w);\r\n\r\n    var distanceSquared = 0.0;\r\n    var d;\r\n\r\n    if (pPrime.x < -uHalf) {\r\n        d = pPrime.x + uHalf;\r\n        distanceSquared += d * d;\r\n    } else if (pPrime.x > uHalf) {\r\n        d = pPrime.x - uHalf;\r\n        distanceSquared += d * d;\r\n    }\r\n\r\n    if (pPrime.y < -vHalf) {\r\n        d = pPrime.y + vHalf;\r\n        distanceSquared += d * d;\r\n    } else if (pPrime.y > vHalf) {\r\n        d = pPrime.y - vHalf;\r\n        distanceSquared += d * d;\r\n    }\r\n\r\n    if (pPrime.z < -wHalf) {\r\n        d = pPrime.z + wHalf;\r\n        distanceSquared += d * d;\r\n    } else if (pPrime.z > wHalf) {\r\n        d = pPrime.z - wHalf;\r\n        distanceSquared += d * d;\r\n    }\r\n\r\n    return distanceSquared;\r\n};\r\n\r\nvar scratchCorner = new Cartesian3();\r\nvar scratchToCenter = new Cartesian3();\r\n\r\n/**\r\n * The distances calculated by the vector from the center of the bounding box to position projected onto direction.\r\n * <br>\r\n * If you imagine the infinite number of planes with normal direction, this computes the smallest distance to the\r\n * closest and farthest planes from position that intersect the bounding box.\r\n *\r\n * @param {OrientedBoundingBox} box The bounding box to calculate the distance to.\r\n * @param {Cartesian3} position The position to calculate the distance from.\r\n * @param {Cartesian3} direction The direction from position.\r\n * @param {Interval} [result] A Interval to store the nearest and farthest distances.\r\n * @returns {Interval} The nearest and farthest distances on the bounding box from position in direction.\r\n */\r\nOrientedBoundingBox.computePlaneDistances = function (box, position, direction, result) {\r\n    //>>includeStart('debug', pragmas.debug);\r\n    if (!defined(box)) {\r\n        throw new DeveloperError('box is required.');\r\n    }\r\n\r\n    if (!defined(position)) {\r\n        throw new DeveloperError('position is required.');\r\n    }\r\n\r\n    if (!defined(direction)) {\r\n        throw new DeveloperError('direction is required.');\r\n    }\r\n    //>>includeEnd('debug');\r\n\r\n    if (!defined(result)) {\r\n        result = new Interval();\r\n    }\r\n\r\n    var minDist = Number.POSITIVE_INFINITY;\r\n    var maxDist = Number.NEGATIVE_INFINITY;\r\n\r\n    var center = box.center;\r\n    var halfAxes = box.halfAxes;\r\n\r\n    var u = Matrix3.getColumn(halfAxes, 0, scratchCartesianU);\r\n    var v = Matrix3.getColumn(halfAxes, 1, scratchCartesianV);\r\n    var w = Matrix3.getColumn(halfAxes, 2, scratchCartesianW);\r\n\r\n    // project first corner\r\n    var corner = Cartesian3.add(u, v, scratchCorner);\r\n    Cartesian3.add(corner, w, corner);\r\n    Cartesian3.add(corner, center, corner);\r\n\r\n    var toCenter = Cartesian3.subtract(corner, position, scratchToCenter);\r\n    var mag = Cartesian3.dot(direction, toCenter);\r\n\r\n    minDist = Math.min(mag, minDist);\r\n    maxDist = Math.max(mag, maxDist);\r\n\r\n    // project second corner\r\n    Cartesian3.add(center, u, corner);\r\n    Cartesian3.add(corner, v, corner);\r\n    Cartesian3.subtract(corner, w, corner);\r\n\r\n    Cartesian3.subtract(corner, position, toCenter);\r\n    mag = Cartesian3.dot(direction, toCenter);\r\n\r\n    minDist = Math.min(mag, minDist);\r\n    maxDist = Math.max(mag, maxDist);\r\n\r\n    // project third corner\r\n    Cartesian3.add(center, u, corner);\r\n    Cartesian3.subtract(corner, v, corner);\r\n    Cartesian3.add(corner, w, corner);\r\n\r\n    Cartesian3.subtract(corner, position, toCenter);\r\n    mag = Cartesian3.dot(direction, toCenter);\r\n\r\n    minDist = Math.min(mag, minDist);\r\n    maxDist = Math.max(mag, maxDist);\r\n\r\n    // project fourth corner\r\n    Cartesian3.add(center, u, corner);\r\n    Cartesian3.subtract(corner, v, corner);\r\n    Cartesian3.subtract(corner, w, corner);\r\n\r\n    Cartesian3.subtract(corner, position, toCenter);\r\n    mag = Cartesian3.dot(direction, toCenter);\r\n\r\n    minDist = Math.min(mag, minDist);\r\n    maxDist = Math.max(mag, maxDist);\r\n\r\n    // project fifth corner\r\n    Cartesian3.subtract(center, u, corner);\r\n    Cartesian3.add(corner, v, corner);\r\n    Cartesian3.add(corner, w, corner);\r\n\r\n    Cartesian3.subtract(corner, position, toCenter);\r\n    mag = Cartesian3.dot(direction, toCenter);\r\n\r\n    minDist = Math.min(mag, minDist);\r\n    maxDist = Math.max(mag, maxDist);\r\n\r\n    // project sixth corner\r\n    Cartesian3.subtract(center, u, corner);\r\n    Cartesian3.add(corner, v, corner);\r\n    Cartesian3.subtract(corner, w, corner);\r\n\r\n    Cartesian3.subtract(corner, position, toCenter);\r\n    mag = Cartesian3.dot(direction, toCenter);\r\n\r\n    minDist = Math.min(mag, minDist);\r\n    maxDist = Math.max(mag, maxDist);\r\n\r\n    // project seventh corner\r\n    Cartesian3.subtract(center, u, corner);\r\n    Cartesian3.subtract(corner, v, corner);\r\n    Cartesian3.add(corner, w, corner);\r\n\r\n    Cartesian3.subtract(corner, position, toCenter);\r\n    mag = Cartesian3.dot(direction, toCenter);\r\n\r\n    minDist = Math.min(mag, minDist);\r\n    maxDist = Math.max(mag, maxDist);\r\n\r\n    // project eighth corner\r\n    Cartesian3.subtract(center, u, corner);\r\n    Cartesian3.subtract(corner, v, corner);\r\n    Cartesian3.subtract(corner, w, corner);\r\n\r\n    Cartesian3.subtract(corner, position, toCenter);\r\n    mag = Cartesian3.dot(direction, toCenter);\r\n\r\n    minDist = Math.min(mag, minDist);\r\n    maxDist = Math.max(mag, maxDist);\r\n\r\n    result.start = minDist;\r\n    result.stop = maxDist;\r\n    return result;\r\n};\r\n\r\nvar scratchBoundingSphere = new BoundingSphere();\r\n\r\n/**\r\n * Determines whether or not a bounding box is hidden from view by the occluder.\r\n *\r\n * @param {OrientedBoundingBox} box The bounding box surrounding the occludee object.\r\n * @param {Occluder} occluder The occluder.\r\n * @returns {Boolean} <code>true</code> if the box is not visible; otherwise <code>false</code>.\r\n */\r\nOrientedBoundingBox.isOccluded = function (box, occluder) {\r\n    //>>includeStart('debug', pragmas.debug);\r\n    if (!defined(box)) {\r\n        throw new DeveloperError('box is required.');\r\n    }\r\n    if (!defined(occluder)) {\r\n        throw new DeveloperError('occluder is required.');\r\n    }\r\n    //>>includeEnd('debug');\r\n\r\n    var sphere = BoundingSphere.fromOrientedBoundingBox(box, scratchBoundingSphere);\r\n\r\n    return !occluder.isBoundingSphereVisible(sphere);\r\n};\r\n\r\n/**\r\n * Determines which side of a plane the oriented bounding box is located.\r\n *\r\n * @param {Plane} plane The plane to test against.\r\n * @returns {Intersect} {@link Intersect.INSIDE} if the entire box is on the side of the plane\r\n *                      the normal is pointing, {@link Intersect.OUTSIDE} if the entire box is\r\n *                      on the opposite side, and {@link Intersect.INTERSECTING} if the box\r\n *                      intersects the plane.\r\n */\r\nOrientedBoundingBox.prototype.intersectPlane = function (plane) {\r\n    return OrientedBoundingBox.intersectPlane(this, plane);\r\n};\r\n\r\n/**\r\n * Computes the estimated distance squared from the closest point on a bounding box to a point.\r\n *\r\n * @param {Cartesian3} cartesian The point\r\n * @returns {Number} The estimated distance squared from the bounding sphere to the point.\r\n *\r\n * @example\r\n * // Sort bounding boxes from back to front\r\n * boxes.sort(function(a, b) {\r\n *     return b.distanceSquaredTo(camera.positionWC) - a.distanceSquaredTo(camera.positionWC);\r\n * });\r\n */\r\nOrientedBoundingBox.prototype.distanceSquaredTo = function (cartesian) {\r\n    return OrientedBoundingBox.distanceSquaredTo(this, cartesian);\r\n};\r\n\r\n/**\r\n * The distances calculated by the vector from the center of the bounding box to position projected onto direction.\r\n * <br>\r\n * If you imagine the infinite number of planes with normal direction, this computes the smallest distance to the\r\n * closest and farthest planes from position that intersect the bounding box.\r\n *\r\n * @param {Cartesian3} position The position to calculate the distance from.\r\n * @param {Cartesian3} direction The direction from position.\r\n * @param {Interval} [result] A Interval to store the nearest and farthest distances.\r\n * @returns {Interval} The nearest and farthest distances on the bounding box from position in direction.\r\n */\r\nOrientedBoundingBox.prototype.computePlaneDistances = function (position, direction, result) {\r\n    return OrientedBoundingBox.computePlaneDistances(this, position, direction, result);\r\n};\r\n\r\n/**\r\n * Determines whether or not a bounding box is hidden from view by the occluder.\r\n *\r\n * @param {Occluder} occluder The occluder.\r\n * @returns {Boolean} <code>true</code> if the sphere is not visible; otherwise <code>false</code>.\r\n */\r\nOrientedBoundingBox.prototype.isOccluded = function (occluder) {\r\n    return OrientedBoundingBox.isOccluded(this, occluder);\r\n};\r\n\r\n/**\r\n * Compares the provided OrientedBoundingBox componentwise and returns\r\n * <code>true</code> if they are equal, <code>false</code> otherwise.\r\n *\r\n * @param {OrientedBoundingBox} left The first OrientedBoundingBox.\r\n * @param {OrientedBoundingBox} right The second OrientedBoundingBox.\r\n * @returns {Boolean} <code>true</code> if left and right are equal, <code>false</code> otherwise.\r\n */\r\nOrientedBoundingBox.equals = function (left, right) {\r\n    return left === right || (defined(left) && defined(right) && Cartesian3.equals(left.center, right.center) && Matrix3.equals(left.halfAxes, right.halfAxes));\r\n};\r\n\r\n/**\r\n * Duplicates this OrientedBoundingBox instance.\r\n *\r\n * @param {OrientedBoundingBox} [result] The object onto which to store the result.\r\n * @returns {OrientedBoundingBox} The modified result parameter or a new OrientedBoundingBox instance if one was not provided.\r\n */\r\nOrientedBoundingBox.prototype.clone = function (result) {\r\n    return OrientedBoundingBox.clone(this, result);\r\n};\r\n\r\n/**\r\n * Compares this OrientedBoundingBox against the provided OrientedBoundingBox componentwise and returns\r\n * <code>true</code> if they are equal, <code>false</code> otherwise.\r\n *\r\n * @param {OrientedBoundingBox} [right] The right hand side OrientedBoundingBox.\r\n * @returns {Boolean} <code>true</code> if they are equal, <code>false</code> otherwise.\r\n */\r\nOrientedBoundingBox.prototype.equals = function (right) {\r\n    return OrientedBoundingBox.equals(this, right);\r\n};\r\nexport default OrientedBoundingBox;\r\n"],"names":["Cartesian3","defaultValue","Matrix3","Check","defined","DeveloperError","Cartographic","Cartesian2","Plane","CesiumMath","Ellipsoid","Rectangle","EllipsoidTangentPlane","Intersect","Interval","BoundingSphere"],"mappings":"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"}