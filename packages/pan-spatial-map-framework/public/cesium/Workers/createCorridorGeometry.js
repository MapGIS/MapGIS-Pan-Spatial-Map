define(["./GeometryOffsetAttribute-b02d5bb9","./arrayRemoveDuplicates-bdf50aa0","./Transforms-07a9fab5","./Cartesian2-38b35910","./Check-f996273c","./ComponentDatatype-e44126e4","./PolylineVolumeGeometryLibrary-c00aade2","./CorridorGeometryLibrary-aa7b3a60","./when-ae2e0b60","./GeometryAttribute-586bf52c","./GeometryAttributes-5ce4955a","./IndexDatatype-516320ea","./Math-5bbcea10","./PolygonPipeline-06aa4301","./VertexFormat-90d15264","./combine-276652d0","./RuntimeError-ac2797b4","./WebGLConstants-35626ea2","./EllipsoidTangentPlane-19622103","./AxisAlignedBoundingBox-d272def4","./IntersectionTests-f49c7cd3","./Plane-45ad3143","./PolylinePipeline-f47a23a0","./EllipsoidGeodesic-0207b202","./EllipsoidRhumbLine-af7b5ebe"],function(V,c,d,rt,t,st,h,at,it,ot,lt,dt,ut,F,E,e,r,a,i,o,n,s,l,u,g){"use strict";var mt=new rt.Cartesian3,yt=new rt.Cartesian3,ft=new rt.Cartesian3,pt=new rt.Cartesian3,L=new rt.Cartesian3,ct=new rt.Cartesian3,ht=new rt.Cartesian3,gt=new rt.Cartesian3;function b(t,e){for(var r=0;r<t.length;r++)t[r]=e.scaleToGeodeticSurface(t[r],t[r]);return t}function nt(t,e,r,a,i,o){var n=t.normals,s=t.tangents,t=t.bitangents,l=rt.Cartesian3.normalize(rt.Cartesian3.cross(r,e,ht),ht);o.normal&&at.CorridorGeometryLibrary.addAttribute(n,e,a,i),o.tangent&&at.CorridorGeometryLibrary.addAttribute(s,l,a,i),o.bitangent&&at.CorridorGeometryLibrary.addAttribute(t,r,a,i)}function x(u,t,m){var y,f=u.positions,p=u.corners,c=u.endPositions,h=u.lefts,g=u.normals,u=new lt.GeometryAttributes,b=0,C=0,A=0;for(l=0;l<f.length;l+=2)b+=y=f[l].length-3,A+=2*y,C+=f[l+1].length-3;for(b+=3,C+=3,l=0;l<p.length;l++){var v=p[l],_=p[l].leftPositions;it.defined(_)?b+=y=_.length:C+=y=p[l].rightPositions.length,A+=y}var w,T,G,E,V,F=it.defined(c),L=(F&&(b+=w=c[0].length-3,C+=w,A+=6*(w/=3)),b+C),e=new Float64Array(L),x={normals:t.normal?new Float32Array(L):void 0,tangents:t.tangent?new Float32Array(L):void 0,bitangents:t.bitangent?new Float32Array(L):void 0},r=0,a=L-1,i=mt,o=yt,P=w/2,n=dt.IndexDatatype.createTypedArray(L/3,A),s=0;if(F)for(var N=ft,D=pt,M=c[0],i=rt.Cartesian3.fromArray(g,0,i),o=rt.Cartesian3.fromArray(h,0,o),l=0;l<P;l++)N=rt.Cartesian3.fromArray(M,3*(P-1-l),N),D=rt.Cartesian3.fromArray(M,3*(P+l),D),at.CorridorGeometryLibrary.addAttribute(e,D,r),at.CorridorGeometryLibrary.addAttribute(e,N,void 0,a),nt(x,i,o,r,a,t),V=(G=r/3)+1,E=(T=(a-2)/3)-1,n[s++]=T,n[s++]=G,n[s++]=E,n[s++]=E,n[s++]=G,n[s++]=V,r+=3,a-=3;var O,I,S=0,R=0,k=f[S++],H=f[S++];for(e.set(k,r),e.set(H,a-H.length+1),o=rt.Cartesian3.fromArray(h,R,o),y=H.length-3,l=0;l<y;l+=3)O=m.geodeticSurfaceNormal(rt.Cartesian3.fromArray(k,l,ht),ht),I=m.geodeticSurfaceNormal(rt.Cartesian3.fromArray(H,y-l,gt),gt),nt(x,i=rt.Cartesian3.normalize(rt.Cartesian3.add(O,I,i),i),o,r,a,t),V=(G=r/3)+1,E=(T=(a-2)/3)-1,n[s++]=T,n[s++]=G,n[s++]=E,n[s++]=E,n[s++]=G,n[s++]=V,r+=3,a-=3;for(O=m.geodeticSurfaceNormal(rt.Cartesian3.fromArray(k,y,ht),ht),I=m.geodeticSurfaceNormal(rt.Cartesian3.fromArray(H,y,gt),gt),i=rt.Cartesian3.normalize(rt.Cartesian3.add(O,I,i),i),R+=3,l=0;l<p.length;l++){var d,z,B,U=(v=p[l]).leftPositions,Y=v.rightPositions,W=ct,q=ft,J=pt;if(i=rt.Cartesian3.fromArray(g,R,i),it.defined(U)){for(nt(x,i,o,void 0,a,t),a-=3,z=V,B=E,d=0;d<U.length/3;d++)W=rt.Cartesian3.fromArray(U,3*d,W),n[s++]=z,n[s++]=B-d-1,n[s++]=B-d,at.CorridorGeometryLibrary.addAttribute(e,W,void 0,a),q=rt.Cartesian3.fromArray(e,3*(B-d-1),q),J=rt.Cartesian3.fromArray(e,3*z,J),nt(x,i,o=rt.Cartesian3.normalize(rt.Cartesian3.subtract(q,J,o),o),void 0,a,t),a-=3;W=rt.Cartesian3.fromArray(e,3*z,W),q=rt.Cartesian3.subtract(rt.Cartesian3.fromArray(e,3*B,q),W,q),J=rt.Cartesian3.subtract(rt.Cartesian3.fromArray(e,3*(B-d),J),W,J),nt(x,i,o=rt.Cartesian3.normalize(rt.Cartesian3.add(q,J,o),o),r,void 0,t),r+=3}else{for(nt(x,i,o,r,void 0,t),r+=3,z=E,B=V,d=0;d<Y.length/3;d++)W=rt.Cartesian3.fromArray(Y,3*d,W),n[s++]=z,n[s++]=B+d,n[s++]=B+d+1,at.CorridorGeometryLibrary.addAttribute(e,W,r),q=rt.Cartesian3.fromArray(e,3*z,q),J=rt.Cartesian3.fromArray(e,3*(B+d),J),nt(x,i,o=rt.Cartesian3.normalize(rt.Cartesian3.subtract(q,J,o),o),r,void 0,t),r+=3;W=rt.Cartesian3.fromArray(e,3*z,W),q=rt.Cartesian3.subtract(rt.Cartesian3.fromArray(e,3*(B+d),q),W,q),J=rt.Cartesian3.subtract(rt.Cartesian3.fromArray(e,3*B,J),W,J),nt(x,i,o=rt.Cartesian3.normalize(rt.Cartesian3.negate(rt.Cartesian3.add(J,q,o),o),o),void 0,a,t),a-=3}for(k=f[S++],H=f[S++],k.splice(0,3),H.splice(H.length-3,3),e.set(k,r),e.set(H,a-H.length+1),y=H.length-3,R+=3,o=rt.Cartesian3.fromArray(h,R,o),d=0;d<H.length;d+=3)O=m.geodeticSurfaceNormal(rt.Cartesian3.fromArray(k,d,ht),ht),I=m.geodeticSurfaceNormal(rt.Cartesian3.fromArray(H,y-d,gt),gt),nt(x,i=rt.Cartesian3.normalize(rt.Cartesian3.add(O,I,i),i),o,r,a,t),G=(V=r/3)-1,n[s++]=T=(E=(a-2)/3)+1,n[s++]=G,n[s++]=E,n[s++]=E,n[s++]=G,n[s++]=V,r+=3,a-=3;r-=3,a+=3}if(nt(x,i=rt.Cartesian3.fromArray(g,g.length-3,i),o,r,a,t),F){r+=3,a-=3,N=ft,D=pt;var j=c[1];for(l=0;l<P;l++)N=rt.Cartesian3.fromArray(j,3*(w-l-1),N),D=rt.Cartesian3.fromArray(j,3*l,D),at.CorridorGeometryLibrary.addAttribute(e,N,void 0,a),at.CorridorGeometryLibrary.addAttribute(e,D,r),nt(x,i,o,r,a,t),G=(V=r/3)-1,n[s++]=T=(E=(a-2)/3)+1,n[s++]=G,n[s++]=E,n[s++]=E,n[s++]=G,n[s++]=V,r+=3,a-=3}if(u.position=new ot.GeometryAttribute({componentDatatype:st.ComponentDatatype.DOUBLE,componentsPerAttribute:3,values:e}),t.st){var K=new Float32Array(L/3*2),Q=0;if(F){b/=3,C/=3;var X,Z=Math.PI/(w+1),$=1/(b-w+1),tt=1/(C-w+1),et=w/2;for(l=1+et;l<w+1;l++)X=ut.CesiumMath.PI_OVER_TWO+Z*l,K[Q++]=tt*(1+Math.cos(X)),K[Q++]=.5*(1+Math.sin(X));for(l=1;l<C-w+1;l++)K[Q++]=l*tt,K[Q++]=0;for(l=w;et<l;l--)X=ut.CesiumMath.PI_OVER_TWO-l*Z,K[Q++]=1-tt*(1+Math.cos(X)),K[Q++]=.5*(1+Math.sin(X));for(l=et;0<l;l--)X=ut.CesiumMath.PI_OVER_TWO-Z*l,K[Q++]=1-$*(1+Math.cos(X)),K[Q++]=.5*(1+Math.sin(X));for(l=b-w;0<l;l--)K[Q++]=l*$,K[Q++]=1;for(l=1;l<1+et;l++)X=ut.CesiumMath.PI_OVER_TWO+Z*l,K[Q++]=$*(1+Math.cos(X)),K[Q++]=.5*(1+Math.sin(X))}else{for($=1/((b/=3)-1),tt=1/((C/=3)-1),l=0;l<C;l++)K[Q++]=l*tt,K[Q++]=0;for(l=b;0<l;l--)K[Q++]=(l-1)*$,K[Q++]=1}u.st=new ot.GeometryAttribute({componentDatatype:st.ComponentDatatype.FLOAT,componentsPerAttribute:2,values:K})}return t.normal&&(u.normal=new ot.GeometryAttribute({componentDatatype:st.ComponentDatatype.FLOAT,componentsPerAttribute:3,values:x.normals})),t.tangent&&(u.tangent=new ot.GeometryAttribute({componentDatatype:st.ComponentDatatype.FLOAT,componentsPerAttribute:3,values:x.tangents})),t.bitangent&&(u.bitangent=new ot.GeometryAttribute({componentDatatype:st.ComponentDatatype.FLOAT,componentsPerAttribute:3,values:x.bitangents})),{attributes:u,indices:n}}function P(t,e,r){r[e++]=t[0],r[e++]=t[1],r[e++]=t[2];for(var a=3;a<t.length;a+=3){var i=t[a],o=t[a+1],n=t[a+2];r[e++]=i,r[e++]=o,r[e++]=n,r[e++]=i,r[e++]=o,r[e++]=n}return r[e++]=t[0],r[e++]=t[1],r[e++]=t[2],r}function C(t,e){var r=new E.VertexFormat({position:e.position,normal:e.normal||e.bitangent||t.shadowVolume,tangent:e.tangent,bitangent:e.normal||e.bitangent,st:e.st}),u=t.ellipsoid,r=x(at.CorridorGeometryLibrary.computePositions(t),r,u),m=t.height,a=t.extrudedHeight,i=r.attributes,y=r.indices,r=i.position.values,o=r.length,f=new Float64Array(6*o),p=new Float64Array(o),c=(p.set(r),new Float64Array(4*o)),c=P(r=F.PolygonPipeline.scaleToGeodeticHeight(r,m,u),0,c),i=(c=P(p=F.PolygonPipeline.scaleToGeodeticHeight(p,a,u),2*o,c),f.set(r),f.set(p,o),f.set(c,2*o),i.position.values=f,function(t,e){if(!(e.normal||e.tangent||e.bitangent||e.st))return t;var u,m,y=t.position.values,f=((e.normal||e.bitangent)&&(u=t.normal.values,m=t.bitangent.values),t.position.values.length/18),r=3*f,p=2*f,c=2*r;if(e.normal||e.bitangent||e.tangent){for(var a=e.normal?new Float32Array(6*r):void 0,h=e.tangent?new Float32Array(6*r):void 0,g=e.bitangent?new Float32Array(6*r):void 0,b=mt,C=yt,A=ft,i=pt,v=L,_=ct,o=c,n=0;n<r;n+=3){var w=o+c,b=rt.Cartesian3.fromArray(y,n,b),C=rt.Cartesian3.fromArray(y,n+r,C),A=rt.Cartesian3.fromArray(y,(n+3)%r,A);C=rt.Cartesian3.subtract(C,b,C),A=rt.Cartesian3.subtract(A,b,A),i=rt.Cartesian3.normalize(rt.Cartesian3.cross(C,A,i),i),e.normal&&(at.CorridorGeometryLibrary.addAttribute(a,i,w),at.CorridorGeometryLibrary.addAttribute(a,i,w+3),at.CorridorGeometryLibrary.addAttribute(a,i,o),at.CorridorGeometryLibrary.addAttribute(a,i,o+3)),(e.tangent||e.bitangent)&&(_=rt.Cartesian3.fromArray(u,n,_),e.bitangent&&(at.CorridorGeometryLibrary.addAttribute(g,_,w),at.CorridorGeometryLibrary.addAttribute(g,_,w+3),at.CorridorGeometryLibrary.addAttribute(g,_,o),at.CorridorGeometryLibrary.addAttribute(g,_,o+3)),e.tangent&&(v=rt.Cartesian3.normalize(rt.Cartesian3.cross(_,i,v),v),at.CorridorGeometryLibrary.addAttribute(h,v,w),at.CorridorGeometryLibrary.addAttribute(h,v,w+3),at.CorridorGeometryLibrary.addAttribute(h,v,o),at.CorridorGeometryLibrary.addAttribute(h,v,o+3))),o+=6}if(e.normal){for(a.set(u),n=0;n<r;n+=3)a[n+r]=-u[n],a[n+r+1]=-u[n+1],a[n+r+2]=-u[n+2];t.normal.values=a}else t.normal=void 0;e.bitangent?(g.set(m),g.set(m,r),t.bitangent.values=g):t.bitangent=void 0,e.tangent&&(f=t.tangent.values,h.set(f),h.set(f,r),t.tangent.values=h)}if(e.st){for(var s=t.st.values,l=new Float32Array(6*p),d=(l.set(s),l.set(s,p),2*p),T=0;T<2;T++){for(l[d++]=s[0],l[d++]=s[1],n=2;n<p;n+=2){var G=s[n],E=s[n+1];l[d++]=G,l[d++]=E,l[d++]=G,l[d++]=E}l[d++]=s[0],l[d++]=s[1]}t.st.values=l}return t}(i,e)),n=o/3;if(t.shadowVolume){for(var h=i.normal.values,o=h.length,m=new Float32Array(6*o),s=0;s<o;s++)h[s]=-h[s];m.set(h,o),m=P(h,4*o,m),i.extrudeDirection=new ot.GeometryAttribute({componentDatatype:st.ComponentDatatype.FLOAT,componentsPerAttribute:3,values:m}),e.normal||(i.normal=void 0)}it.defined(t.offsetAttribute)&&(a=new Uint8Array(6*n),a=t.offsetAttribute===V.GeometryOffsetAttribute.TOP?(a=V.arrayFill(a,1,0,n),V.arrayFill(a,1,2*n,4*n)):(u=t.offsetAttribute===V.GeometryOffsetAttribute.NONE?0:1,V.arrayFill(a,u)),i.applyOffset=new ot.GeometryAttribute({componentDatatype:st.ComponentDatatype.UNSIGNED_BYTE,componentsPerAttribute:1,values:a}));var g,b,C,A,v=y.length,_=n+n,l=dt.IndexDatatype.createTypedArray(f.length/3,2*v+3*_),d=(l.set(y),v);for(s=0;s<v;s+=3){var w=y[s],T=y[s+1],G=y[s+2];l[d++]=G+n,l[d++]=T+n,l[d++]=w+n}for(s=0;s<_;s+=2)C=(g=s+_)+1,A=(b=g+_)+1,l[d++]=g,l[d++]=b,l[d++]=C,l[d++]=C,l[d++]=b,l[d++]=A;return{attributes:i,indices:l}}var A=new rt.Cartesian3,v=new rt.Cartesian3,m=new rt.Cartographic;function _(t,e,u,r,a,i){var e=rt.Cartesian3.subtract(e,t,A),o=(rt.Cartesian3.normalize(e,e),u.geodeticSurfaceNormal(t,v)),e=rt.Cartesian3.cross(e,o,A),o=(rt.Cartesian3.multiplyByScalar(e,r,e),a.latitude),r=a.longitude,n=i.latitude,s=i.longitude,l=(rt.Cartesian3.add(t,e,v),u.cartesianToCartographic(v,m),m.latitude),d=m.longitude,o=Math.min(o,l),r=Math.min(r,d),n=Math.max(n,l),s=Math.max(s,d);rt.Cartesian3.subtract(t,e,v),u.cartesianToCartographic(v,m),l=m.latitude,d=m.longitude,o=Math.min(o,l),r=Math.min(r,d),n=Math.max(n,l),s=Math.max(s,d),a.latitude=o,a.longitude=r,i.latitude=n,i.longitude=s}var y=new rt.Cartesian3,w=new rt.Cartesian3,f=new rt.Cartographic,p=new rt.Cartographic;function T(t,e,r,a,u){t=b(t,e);var i=c.arrayRemoveDuplicates(t,rt.Cartesian3.equalsEpsilon),o=i.length;if(o<2||r<=0)return new rt.Rectangle;var n,s,l=.5*r;f.latitude=Number.POSITIVE_INFINITY,f.longitude=Number.POSITIVE_INFINITY,p.latitude=Number.NEGATIVE_INFINITY,p.longitude=Number.NEGATIVE_INFINITY,a===h.CornerType.ROUNDED&&(t=i[0],rt.Cartesian3.subtract(t,i[1],y),rt.Cartesian3.normalize(y,y),rt.Cartesian3.multiplyByScalar(y,l,y),rt.Cartesian3.add(t,y,w),e.cartesianToCartographic(w,m),n=m.latitude,s=m.longitude,f.latitude=Math.min(f.latitude,n),f.longitude=Math.min(f.longitude,s),p.latitude=Math.max(p.latitude,n),p.longitude=Math.max(p.longitude,s));for(var d=0;d<o-1;++d)_(i[d],i[d+1],e,l,f,p);r=i[o-1],rt.Cartesian3.subtract(r,i[o-2],y),rt.Cartesian3.normalize(y,y),rt.Cartesian3.multiplyByScalar(y,l,y),rt.Cartesian3.add(r,y,w),_(r,w,e,l,f,p),a===h.CornerType.ROUNDED&&(e.cartesianToCartographic(w,m),n=m.latitude,s=m.longitude,f.latitude=Math.min(f.latitude,n),f.longitude=Math.min(f.longitude,s),p.latitude=Math.max(p.latitude,n),p.longitude=Math.max(p.longitude,s)),t=it.defined(u)?u:new rt.Rectangle;return t.north=p.latitude,t.south=f.latitude,t.east=p.longitude,t.west=f.longitude,t}function G(t){var e=(t=it.defaultValue(t,it.defaultValue.EMPTY_OBJECT)).positions,r=t.width,a=it.defaultValue(t.height,0),i=it.defaultValue(t.extrudedHeight,a);this._positions=e,this._ellipsoid=rt.Ellipsoid.clone(it.defaultValue(t.ellipsoid,rt.Ellipsoid.WGS84)),this._vertexFormat=E.VertexFormat.clone(it.defaultValue(t.vertexFormat,E.VertexFormat.DEFAULT)),this._width=r,this._height=Math.max(a,i),this._extrudedHeight=Math.min(a,i),this._cornerType=it.defaultValue(t.cornerType,h.CornerType.ROUNDED),this._granularity=it.defaultValue(t.granularity,ut.CesiumMath.RADIANS_PER_DEGREE),this._shadowVolume=it.defaultValue(t.shadowVolume,!1),this._workerName="createCorridorGeometry",this._offsetAttribute=t.offsetAttribute,this._rectangle=void 0,this.packedLength=1+e.length*rt.Cartesian3.packedLength+rt.Ellipsoid.packedLength+E.VertexFormat.packedLength+7}G.pack=function(t,e,r){r=it.defaultValue(r,0);var a=t._positions,i=a.length;e[r++]=i;for(var o=0;o<i;++o,r+=rt.Cartesian3.packedLength)rt.Cartesian3.pack(a[o],e,r);return rt.Ellipsoid.pack(t._ellipsoid,e,r),r+=rt.Ellipsoid.packedLength,E.VertexFormat.pack(t._vertexFormat,e,r),r+=E.VertexFormat.packedLength,e[r++]=t._width,e[r++]=t._height,e[r++]=t._extrudedHeight,e[r++]=t._cornerType,e[r++]=t._granularity,e[r++]=t._shadowVolume?1:0,e[r]=it.defaultValue(t._offsetAttribute,-1),e};var N=rt.Ellipsoid.clone(rt.Ellipsoid.UNIT_SPHERE),D=new E.VertexFormat,M={positions:void 0,ellipsoid:N,vertexFormat:D,width:void 0,height:void 0,extrudedHeight:void 0,cornerType:void 0,granularity:void 0,shadowVolume:void 0,offsetAttribute:void 0};return G.unpack=function(t,e,r){e=it.defaultValue(e,0);for(var a=t[e++],i=new Array(a),o=0;o<a;++o,e+=rt.Cartesian3.packedLength)i[o]=rt.Cartesian3.unpack(t,e);var u=rt.Ellipsoid.unpack(t,e,N),m=(e+=rt.Ellipsoid.packedLength,E.VertexFormat.unpack(t,e,D)),n=(e+=E.VertexFormat.packedLength,t[e++]),s=t[e++],l=t[e++],y=t[e++],f=t[e++],p=1===t[e++],d=t[e];return it.defined(r)?(r._positions=i,r._ellipsoid=rt.Ellipsoid.clone(u,r._ellipsoid),r._vertexFormat=E.VertexFormat.clone(m,r._vertexFormat),r._width=n,r._height=s,r._extrudedHeight=l,r._cornerType=y,r._granularity=f,r._shadowVolume=p,r._offsetAttribute=-1===d?void 0:d,r):(M.positions=i,M.width=n,M.height=s,M.extrudedHeight=l,M.cornerType=y,M.granularity=f,M.shadowVolume=p,M.offsetAttribute=-1===d?void 0:d,new G(M))},G.computeRectangle=function(t,e){var r=(t=it.defaultValue(t,it.defaultValue.EMPTY_OBJECT)).positions,a=t.width;return T(r,it.defaultValue(t.ellipsoid,rt.Ellipsoid.WGS84),a,it.defaultValue(t.cornerType,h.CornerType.ROUNDED),e)},G.createGeometry=function(t){var e,r,a,i,o,n=t._positions,s=t._width,l=t._ellipsoid,n=b(n,l),n=c.arrayRemoveDuplicates(n,rt.Cartesian3.equalsEpsilon);if(!(n.length<2||s<=0))return o=t._height,a=t._extrudedHeight,r=!ut.CesiumMath.equalsEpsilon(o,a,0,ut.CesiumMath.EPSILON2),e=t._vertexFormat,n={ellipsoid:l,positions:n,width:s,cornerType:t._cornerType,granularity:t._granularity,saveAttributes:!0},r?(n.height=o,n.extrudedHeight=a,n.shadowVolume=t._shadowVolume,n.offsetAttribute=t._offsetAttribute,i=C(n,e)):((i=x(at.CorridorGeometryLibrary.computePositions(n),e,l)).attributes.position.values=F.PolygonPipeline.scaleToGeodeticHeight(i.attributes.position.values,o,l),it.defined(t._offsetAttribute)&&(s=t._offsetAttribute===V.GeometryOffsetAttribute.NONE?0:1,r=i.attributes.position.values.length,a=new Uint8Array(r/3),V.arrayFill(a,s),i.attributes.applyOffset=new ot.GeometryAttribute({componentDatatype:st.ComponentDatatype.UNSIGNED_BYTE,componentsPerAttribute:1,values:a}))),n=i.attributes,o=d.BoundingSphere.fromVertices(n.position.values,void 0,3),e.position||(i.attributes.position.values=void 0),new ot.Geometry({attributes:n,indices:i.indices,primitiveType:ot.PrimitiveType.TRIANGLES,boundingSphere:o,offsetAttribute:t._offsetAttribute})},G.createShadowVolume=function(t,e,r){var a=t._granularity,i=t._ellipsoid,e=e(a,i),r=r(a,i);return new G({positions:t._positions,width:t._width,cornerType:t._cornerType,ellipsoid:i,granularity:a,extrudedHeight:e,height:r,vertexFormat:E.VertexFormat.POSITION_ONLY,shadowVolume:!0})},Object.defineProperties(G.prototype,{rectangle:{get:function(){return it.defined(this._rectangle)||(this._rectangle=T(this._positions,this._ellipsoid,this._width,this._cornerType)),this._rectangle}},textureCoordinateRotationPoints:{get:function(){return[0,0,0,1,1,0]}}}),function(t,e){return(t=it.defined(e)?G.unpack(t,e):t)._ellipsoid=rt.Ellipsoid.clone(t._ellipsoid),G.createGeometry(t)}});
