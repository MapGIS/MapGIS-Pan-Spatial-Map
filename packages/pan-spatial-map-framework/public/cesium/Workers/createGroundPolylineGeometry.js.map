{"version":3,"file":"createGroundPolylineGeometry.js","sources":["../../../../Source/Core/GeographicTilingScheme.js","../../../../Source/Core/ApproximateTerrainHeights.js","../../../../Source/Core/GroundPolylineGeometry.js","../../../../Source/WorkersES6/createGroundPolylineGeometry.js"],"sourcesContent":["import Cartesian2 from './Cartesian2.js';\r\nimport Check from './Check.js';\r\nimport defaultValue from './defaultValue.js';\r\nimport defined from './defined.js';\r\nimport Ellipsoid from './Ellipsoid.js';\r\nimport GeographicProjection from './GeographicProjection.js';\r\nimport CesiumMath from './Math.js';\r\nimport Rectangle from './Rectangle.js';\r\n\r\n/**\r\n * A tiling scheme for geometry referenced to a simple {@link GeographicProjection} where\r\n * longitude and latitude are directly mapped to X and Y.  This projection is commonly\r\n * known as geographic, equirectangular, equidistant cylindrical, or plate carr√©e.\r\n *\r\n * @alias GeographicTilingScheme\r\n * @constructor\r\n *\r\n * @param {Object} [options] Object with the following properties:\r\n * @param {Ellipsoid} [options.ellipsoid=Ellipsoid.WGS84] The ellipsoid whose surface is being tiled. Defaults to\r\n * the WGS84 ellipsoid.\r\n * @param {Rectangle} [options.rectangle=Rectangle.MAX_VALUE] The rectangle, in radians, covered by the tiling scheme.\r\n * @param {Number} [options.numberOfLevelZeroTilesX=2] The number of tiles in the X direction at level zero of\r\n * the tile tree.\r\n * @param {Number} [options.numberOfLevelZeroTilesY=1] The number of tiles in the Y direction at level zero of\r\n * the tile tree.\r\n */\r\nfunction GeographicTilingScheme(options) {\r\n    options = defaultValue(options, defaultValue.EMPTY_OBJECT);\r\n\r\n    this._ellipsoid = defaultValue(options.ellipsoid, Ellipsoid.WGS84);\r\n    this._rectangle = defaultValue(options.rectangle, Rectangle.MAX_VALUE);\r\n    this._projection = new GeographicProjection(this._ellipsoid);\r\n    this._numberOfLevelZeroTilesX = defaultValue(options.numberOfLevelZeroTilesX, 2);\r\n    this._numberOfLevelZeroTilesY = defaultValue(options.numberOfLevelZeroTilesY, 1);\r\n}\r\n\r\nObject.defineProperties(GeographicTilingScheme.prototype, {\r\n    /**\r\n     * Gets the ellipsoid that is tiled by this tiling scheme.\r\n     * @memberof GeographicTilingScheme.prototype\r\n     * @type {Ellipsoid}\r\n     */\r\n    ellipsoid: {\r\n        get: function () {\r\n            return this._ellipsoid;\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Gets the rectangle, in radians, covered by this tiling scheme.\r\n     * @memberof GeographicTilingScheme.prototype\r\n     * @type {Rectangle}\r\n     */\r\n    rectangle: {\r\n        get: function () {\r\n            return this._rectangle;\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Gets the map projection used by this tiling scheme.\r\n     * @memberof GeographicTilingScheme.prototype\r\n     * @type {MapProjection}\r\n     */\r\n    projection: {\r\n        get: function () {\r\n            return this._projection;\r\n        }\r\n    }\r\n});\r\n\r\n/**\r\n * Gets the total number of tiles in the X direction at a specified level-of-detail.\r\n *\r\n * @param {Number} level The level-of-detail.\r\n * @returns {Number} The number of tiles in the X direction at the given level.\r\n */\r\nGeographicTilingScheme.prototype.getNumberOfXTilesAtLevel = function (level) {\r\n    return this._numberOfLevelZeroTilesX << level;\r\n};\r\n\r\n/**\r\n * Gets the total number of tiles in the Y direction at a specified level-of-detail.\r\n *\r\n * @param {Number} level The level-of-detail.\r\n * @returns {Number} The number of tiles in the Y direction at the given level.\r\n */\r\nGeographicTilingScheme.prototype.getNumberOfYTilesAtLevel = function (level) {\r\n    return this._numberOfLevelZeroTilesY << level;\r\n};\r\n\r\n/**\r\n * Transforms a rectangle specified in geodetic radians to the native coordinate system\r\n * of this tiling scheme.\r\n *\r\n * @param {Rectangle} rectangle The rectangle to transform.\r\n * @param {Rectangle} [result] The instance to which to copy the result, or undefined if a new instance\r\n *        should be created.\r\n * @returns {Rectangle} The specified 'result', or a new object containing the native rectangle if 'result'\r\n *          is undefined.\r\n */\r\nGeographicTilingScheme.prototype.rectangleToNativeRectangle = function (rectangle, result) {\r\n    //>>includeStart('debug', pragmas.debug);\r\n    Check.defined('rectangle', rectangle);\r\n    //>>includeEnd('debug');\r\n\r\n    var west = CesiumMath.toDegrees(rectangle.west);\r\n    var south = CesiumMath.toDegrees(rectangle.south);\r\n    var east = CesiumMath.toDegrees(rectangle.east);\r\n    var north = CesiumMath.toDegrees(rectangle.north);\r\n\r\n    if (!defined(result)) {\r\n        return new Rectangle(west, south, east, north);\r\n    }\r\n\r\n    result.west = west;\r\n    result.south = south;\r\n    result.east = east;\r\n    result.north = north;\r\n    return result;\r\n};\r\n\r\n/**\r\n * Converts tile x, y coordinates and level to a rectangle expressed in the native coordinates\r\n * of the tiling scheme.\r\n *\r\n * @param {Number} x The integer x coordinate of the tile.\r\n * @param {Number} y The integer y coordinate of the tile.\r\n * @param {Number} level The tile level-of-detail.  Zero is the least detailed.\r\n * @param {Object} [result] The instance to which to copy the result, or undefined if a new instance\r\n *        should be created.\r\n * @returns {Rectangle} The specified 'result', or a new object containing the rectangle\r\n *          if 'result' is undefined.\r\n */\r\nGeographicTilingScheme.prototype.tileXYToNativeRectangle = function (x, y, level, result) {\r\n    var rectangleRadians = this.tileXYToRectangle(x, y, level, result);\r\n    rectangleRadians.west = CesiumMath.toDegrees(rectangleRadians.west);\r\n    rectangleRadians.south = CesiumMath.toDegrees(rectangleRadians.south);\r\n    rectangleRadians.east = CesiumMath.toDegrees(rectangleRadians.east);\r\n    rectangleRadians.north = CesiumMath.toDegrees(rectangleRadians.north);\r\n    return rectangleRadians;\r\n};\r\n\r\n/**\r\n * Converts tile x, y coordinates and level to a cartographic rectangle in radians.\r\n *\r\n * @param {Number} x The integer x coordinate of the tile.\r\n * @param {Number} y The integer y coordinate of the tile.\r\n * @param {Number} level The tile level-of-detail.  Zero is the least detailed.\r\n * @param {Object} [result] The instance to which to copy the result, or undefined if a new instance\r\n *        should be created.\r\n * @returns {Rectangle} The specified 'result', or a new object containing the rectangle\r\n *          if 'result' is undefined.\r\n */\r\nGeographicTilingScheme.prototype.tileXYToRectangle = function (x, y, level, result) {\r\n    var rectangle = this._rectangle;\r\n\r\n    var xTiles = this.getNumberOfXTilesAtLevel(level);\r\n    var yTiles = this.getNumberOfYTilesAtLevel(level);\r\n\r\n    var xTileWidth = rectangle.width / xTiles;\r\n    var west = x * xTileWidth + rectangle.west;\r\n    var east = (x + 1) * xTileWidth + rectangle.west;\r\n\r\n    var yTileHeight = rectangle.height / yTiles;\r\n    var north = rectangle.north - y * yTileHeight;\r\n    var south = rectangle.north - (y + 1) * yTileHeight;\r\n\r\n    if (!defined(result)) {\r\n        result = new Rectangle(west, south, east, north);\r\n    }\r\n\r\n    result.west = west;\r\n    result.south = south;\r\n    result.east = east;\r\n    result.north = north;\r\n    return result;\r\n};\r\n\r\n/**\r\n * Calculates the tile x, y coordinates of the tile containing\r\n * a given cartographic position.\r\n *\r\n * @param {Cartographic} position The position.\r\n * @param {Number} level The tile level-of-detail.  Zero is the least detailed.\r\n * @param {Cartesian2} [result] The instance to which to copy the result, or undefined if a new instance\r\n *        should be created.\r\n * @returns {Cartesian2} The specified 'result', or a new object containing the tile x, y coordinates\r\n *          if 'result' is undefined.\r\n */\r\nGeographicTilingScheme.prototype.positionToTileXY = function (position, level, result) {\r\n    var rectangle = this._rectangle;\r\n    if (!Rectangle.contains(rectangle, position)) {\r\n        // outside the bounds of the tiling scheme\r\n        return undefined;\r\n    }\r\n\r\n    var xTiles = this.getNumberOfXTilesAtLevel(level);\r\n    var yTiles = this.getNumberOfYTilesAtLevel(level);\r\n\r\n    var xTileWidth = rectangle.width / xTiles;\r\n    var yTileHeight = rectangle.height / yTiles;\r\n\r\n    var longitude = position.longitude;\r\n    if (rectangle.east < rectangle.west) {\r\n        longitude += CesiumMath.TWO_PI;\r\n    }\r\n\r\n    var xTileCoordinate = ((longitude - rectangle.west) / xTileWidth) | 0;\r\n    if (xTileCoordinate >= xTiles) {\r\n        xTileCoordinate = xTiles - 1;\r\n    }\r\n\r\n    var yTileCoordinate = ((rectangle.north - position.latitude) / yTileHeight) | 0;\r\n    if (yTileCoordinate >= yTiles) {\r\n        yTileCoordinate = yTiles - 1;\r\n    }\r\n\r\n    if (!defined(result)) {\r\n        return new Cartesian2(xTileCoordinate, yTileCoordinate);\r\n    }\r\n\r\n    result.x = xTileCoordinate;\r\n    result.y = yTileCoordinate;\r\n    return result;\r\n};\r\nexport default GeographicTilingScheme;\r\n","import BoundingSphere from './BoundingSphere.js';\r\nimport buildModuleUrl from './buildModuleUrl.js';\r\nimport Cartesian2 from './Cartesian2.js';\r\nimport Cartesian3 from './Cartesian3.js';\r\nimport Cartographic from './Cartographic.js';\r\nimport Check from './Check.js';\r\nimport defaultValue from './defaultValue.js';\r\nimport defined from './defined.js';\r\nimport DeveloperError from './DeveloperError.js';\r\nimport Ellipsoid from './Ellipsoid.js';\r\nimport GeographicTilingScheme from './GeographicTilingScheme.js';\r\nimport Rectangle from './Rectangle.js';\r\nimport Resource from './Resource.js';\r\n\r\nvar scratchDiagonalCartesianNE = new Cartesian3();\r\nvar scratchDiagonalCartesianSW = new Cartesian3();\r\nvar scratchDiagonalCartographic = new Cartographic();\r\nvar scratchCenterCartesian = new Cartesian3();\r\nvar scratchSurfaceCartesian = new Cartesian3();\r\n\r\nvar scratchBoundingSphere = new BoundingSphere();\r\nvar tilingScheme = new GeographicTilingScheme();\r\nvar scratchCorners = [new Cartographic(), new Cartographic(), new Cartographic(), new Cartographic()];\r\nvar scratchTileXY = new Cartesian2();\r\n\r\n/**\r\n * A collection of functions for approximating terrain height\r\n * @private\r\n */\r\nvar ApproximateTerrainHeights = {};\r\n\r\n/**\r\n * Initializes the minimum and maximum terrain heights\r\n * @return {Promise<void>}\r\n */\r\nApproximateTerrainHeights.initialize = function () {\r\n    var initPromise = ApproximateTerrainHeights._initPromise;\r\n    if (defined(initPromise)) {\r\n        return initPromise;\r\n    }\r\n\r\n    initPromise = Resource.fetchJson(buildModuleUrl('Assets/approximateTerrainHeights.json')).then(function (json) {\r\n        ApproximateTerrainHeights._terrainHeights = json;\r\n    });\r\n    ApproximateTerrainHeights._initPromise = initPromise;\r\n\r\n    return initPromise;\r\n};\r\n\r\n/**\r\n * Computes the minimum and maximum terrain heights for a given rectangle\r\n * @param {Rectangle} rectangle The bounding rectangle\r\n * @param {Ellipsoid} [ellipsoid=Ellipsoid.WGS84] The ellipsoid\r\n * @return {{minimumTerrainHeight: Number, maximumTerrainHeight: Number}}\r\n */\r\nApproximateTerrainHeights.getMinimumMaximumHeights = function (rectangle, ellipsoid) {\r\n    //>>includeStart('debug', pragmas.debug);\r\n    Check.defined('rectangle', rectangle);\r\n    if (!defined(ApproximateTerrainHeights._terrainHeights)) {\r\n        throw new DeveloperError('You must call ApproximateTerrainHeights.initialize and wait for the promise to resolve before using this function');\r\n    }\r\n    //>>includeEnd('debug');\r\n    ellipsoid = defaultValue(ellipsoid, Ellipsoid.WGS84);\r\n\r\n    var xyLevel = getTileXYLevel(rectangle);\r\n\r\n    // Get the terrain min/max for that tile\r\n    var minTerrainHeight = ApproximateTerrainHeights._defaultMinTerrainHeight;\r\n    var maxTerrainHeight = ApproximateTerrainHeights._defaultMaxTerrainHeight;\r\n    if (defined(xyLevel)) {\r\n        var key = xyLevel.level + '-' + xyLevel.x + '-' + xyLevel.y;\r\n        var heights = ApproximateTerrainHeights._terrainHeights[key];\r\n        if (defined(heights)) {\r\n            minTerrainHeight = heights[0];\r\n            maxTerrainHeight = heights[1];\r\n        }\r\n\r\n        // Compute min by taking the center of the NE->SW diagonal and finding distance to the surface\r\n        ellipsoid.cartographicToCartesian(Rectangle.northeast(rectangle, scratchDiagonalCartographic), scratchDiagonalCartesianNE);\r\n        ellipsoid.cartographicToCartesian(Rectangle.southwest(rectangle, scratchDiagonalCartographic), scratchDiagonalCartesianSW);\r\n\r\n        Cartesian3.midpoint(scratchDiagonalCartesianSW, scratchDiagonalCartesianNE, scratchCenterCartesian);\r\n        var surfacePosition = ellipsoid.scaleToGeodeticSurface(scratchCenterCartesian, scratchSurfaceCartesian);\r\n        if (defined(surfacePosition)) {\r\n            var distance = Cartesian3.distance(scratchCenterCartesian, surfacePosition);\r\n            minTerrainHeight = Math.min(minTerrainHeight, -distance);\r\n        } else {\r\n            minTerrainHeight = ApproximateTerrainHeights._defaultMinTerrainHeight;\r\n        }\r\n    }\r\n\r\n    minTerrainHeight = Math.max(ApproximateTerrainHeights._defaultMinTerrainHeight, minTerrainHeight);\r\n\r\n    return {\r\n        minimumTerrainHeight: minTerrainHeight,\r\n        maximumTerrainHeight: maxTerrainHeight\r\n    };\r\n};\r\n\r\n/**\r\n * Computes the bounding sphere based on the tile heights in the rectangle\r\n * @param {Rectangle} rectangle The bounding rectangle\r\n * @param {Ellipsoid} [ellipsoid=Ellipsoid.WGS84] The ellipsoid\r\n * @return {BoundingSphere} The result bounding sphere\r\n */\r\nApproximateTerrainHeights.getBoundingSphere = function (rectangle, ellipsoid) {\r\n    //>>includeStart('debug', pragmas.debug);\r\n    Check.defined('rectangle', rectangle);\r\n    if (!defined(ApproximateTerrainHeights._terrainHeights)) {\r\n        throw new DeveloperError('You must call ApproximateTerrainHeights.initialize and wait for the promise to resolve before using this function');\r\n    }\r\n    //>>includeEnd('debug');\r\n    ellipsoid = defaultValue(ellipsoid, Ellipsoid.WGS84);\r\n\r\n    var xyLevel = getTileXYLevel(rectangle);\r\n\r\n    // Get the terrain max for that tile\r\n    var maxTerrainHeight = ApproximateTerrainHeights._defaultMaxTerrainHeight;\r\n    if (defined(xyLevel)) {\r\n        var key = xyLevel.level + '-' + xyLevel.x + '-' + xyLevel.y;\r\n        var heights = ApproximateTerrainHeights._terrainHeights[key];\r\n        if (defined(heights)) {\r\n            maxTerrainHeight = heights[1];\r\n        }\r\n    }\r\n\r\n    var result = BoundingSphere.fromRectangle3D(rectangle, ellipsoid, 0.0);\r\n    BoundingSphere.fromRectangle3D(rectangle, ellipsoid, maxTerrainHeight, scratchBoundingSphere);\r\n\r\n    return BoundingSphere.union(result, scratchBoundingSphere, result);\r\n};\r\n\r\nfunction getTileXYLevel(rectangle) {\r\n    Cartographic.fromRadians(rectangle.east, rectangle.north, 0.0, scratchCorners[0]);\r\n    Cartographic.fromRadians(rectangle.west, rectangle.north, 0.0, scratchCorners[1]);\r\n    Cartographic.fromRadians(rectangle.east, rectangle.south, 0.0, scratchCorners[2]);\r\n    Cartographic.fromRadians(rectangle.west, rectangle.south, 0.0, scratchCorners[3]);\r\n\r\n    // Determine which tile the bounding rectangle is in\r\n    var lastLevelX = 0,\r\n        lastLevelY = 0;\r\n    var currentX = 0,\r\n        currentY = 0;\r\n    var maxLevel = ApproximateTerrainHeights._terrainHeightsMaxLevel;\r\n    var i;\r\n    for (i = 0; i <= maxLevel; ++i) {\r\n        var failed = false;\r\n        for (var j = 0; j < 4; ++j) {\r\n            var corner = scratchCorners[j];\r\n            tilingScheme.positionToTileXY(corner, i, scratchTileXY);\r\n            if (j === 0) {\r\n                currentX = scratchTileXY.x;\r\n                currentY = scratchTileXY.y;\r\n            } else if (currentX !== scratchTileXY.x || currentY !== scratchTileXY.y) {\r\n                failed = true;\r\n                break;\r\n            }\r\n        }\r\n\r\n        if (failed) {\r\n            break;\r\n        }\r\n\r\n        lastLevelX = currentX;\r\n        lastLevelY = currentY;\r\n    }\r\n\r\n    if (i === 0) {\r\n        return undefined;\r\n    }\r\n\r\n    return {\r\n        x: lastLevelX,\r\n        y: lastLevelY,\r\n        level: i > maxLevel ? maxLevel : i - 1\r\n    };\r\n}\r\n\r\nApproximateTerrainHeights._terrainHeightsMaxLevel = 6;\r\nApproximateTerrainHeights._defaultMaxTerrainHeight = 9000.0;\r\nApproximateTerrainHeights._defaultMinTerrainHeight = -100000.0;\r\nApproximateTerrainHeights._terrainHeights = undefined;\r\nApproximateTerrainHeights._initPromise = undefined;\r\n\r\nObject.defineProperties(ApproximateTerrainHeights, {\r\n    /**\r\n     * Determines if the terrain heights are initialized and ready to use. To initialize the terrain heights,\r\n     * call {@link ApproximateTerrainHeights#initialize} and wait for the returned promise to resolve.\r\n     * @type {Boolean}\r\n     * @readonly\r\n     * @memberof ApproximateTerrainHeights\r\n     */\r\n    initialized: {\r\n        get: function () {\r\n            return defined(ApproximateTerrainHeights._terrainHeights);\r\n        }\r\n    }\r\n});\r\nexport default ApproximateTerrainHeights;\r\n","import ApproximateTerrainHeights from './ApproximateTerrainHeights.js';\r\nimport ArcType from './ArcType.js';\r\nimport arrayRemoveDuplicates from './arrayRemoveDuplicates.js';\r\nimport BoundingSphere from './BoundingSphere.js';\r\nimport Cartesian3 from './Cartesian3.js';\r\nimport Cartographic from './Cartographic.js';\r\nimport Check from './Check.js';\r\nimport ComponentDatatype from './ComponentDatatype.js';\r\nimport defaultValue from './defaultValue.js';\r\nimport defined from './defined.js';\r\nimport DeveloperError from './DeveloperError.js';\r\nimport Ellipsoid from './Ellipsoid.js';\r\nimport EllipsoidGeodesic from './EllipsoidGeodesic.js';\r\nimport EllipsoidRhumbLine from './EllipsoidRhumbLine.js';\r\nimport EncodedCartesian3 from './EncodedCartesian3.js';\r\nimport GeographicProjection from './GeographicProjection.js';\r\nimport Geometry from './Geometry.js';\r\nimport GeometryAttribute from './GeometryAttribute.js';\r\nimport IntersectionTests from './IntersectionTests.js';\r\nimport CesiumMath from './Math.js';\r\nimport Matrix3 from './Matrix3.js';\r\nimport Plane from './Plane.js';\r\nimport Quaternion from './Quaternion.js';\r\nimport Rectangle from './Rectangle.js';\r\nimport WebMercatorProjection from './WebMercatorProjection.js';\r\n\r\nvar PROJECTIONS = [GeographicProjection, WebMercatorProjection];\r\nvar PROJECTION_COUNT = PROJECTIONS.length;\r\n\r\nvar MITER_BREAK_SMALL = Math.cos(CesiumMath.toRadians(30.0));\r\nvar MITER_BREAK_LARGE = Math.cos(CesiumMath.toRadians(150.0));\r\n\r\n// Initial heights for constructing the wall.\r\n// Keeping WALL_INITIAL_MIN_HEIGHT near the ellipsoid surface helps\r\n// prevent precision problems with planes in the shader.\r\n// Putting the start point of a plane at ApproximateTerrainHeights._defaultMinTerrainHeight,\r\n// which is a highly conservative bound, usually puts the plane origin several thousands\r\n// of meters away from the actual terrain, causing floating point problems when checking\r\n// fragments on terrain against the plane.\r\n// Ellipsoid height is generally much closer.\r\n// The initial max height is arbitrary.\r\n// Both heights are corrected using ApproximateTerrainHeights for computing the actual volume geometry.\r\nvar WALL_INITIAL_MIN_HEIGHT = 0.0;\r\nvar WALL_INITIAL_MAX_HEIGHT = 1000.0;\r\n\r\n/**\r\n * A description of a polyline on terrain or 3D Tiles. Only to be used with {@link GroundPolylinePrimitive}.\r\n *\r\n * @alias GroundPolylineGeometry\r\n * @constructor\r\n *\r\n * @param {Object} options Options with the following properties:\r\n * @param {Cartesian3[]} options.positions An array of {@link Cartesian3} defining the polyline's points. Heights above the ellipsoid will be ignored.\r\n * @param {Number} [options.width=1.0] The screen space width in pixels.\r\n * @param {Number} [options.granularity=9999.0] The distance interval in meters used for interpolating options.points. Defaults to 9999.0 meters. Zero indicates no interpolation.\r\n * @param {Boolean} [options.loop=false] Whether during geometry creation a line segment will be added between the last and first line positions to make this Polyline a loop.\r\n * @param {ArcType} [options.arcType=ArcType.GEODESIC] The type of line the polyline segments must follow. Valid options are {@link ArcType.GEODESIC} and {@link ArcType.RHUMB}.\r\n *\r\n * @exception {DeveloperError} At least two positions are required.\r\n *\r\n * @see GroundPolylinePrimitive\r\n *\r\n * @example\r\n * var positions = Cesium.Cartesian3.fromDegreesArray([\r\n *   -112.1340164450331, 36.05494287836128,\r\n *   -112.08821010582645, 36.097804071380715,\r\n *   -112.13296079730024, 36.168769146801104\r\n * ]);\r\n *\r\n * var geometry = new Cesium.GroundPolylineGeometry({\r\n *   positions : positions\r\n * });\r\n */\r\nfunction GroundPolylineGeometry(options) {\r\n    options = defaultValue(options, defaultValue.EMPTY_OBJECT);\r\n    var positions = options.positions;\r\n\r\n    //>>includeStart('debug', pragmas.debug);\r\n    if (!defined(positions) || positions.length < 2) {\r\n        throw new DeveloperError('At least two positions are required.');\r\n    }\r\n    if (defined(options.arcType) && options.arcType !== ArcType.GEODESIC && options.arcType !== ArcType.RHUMB) {\r\n        throw new DeveloperError('Valid options for arcType are ArcType.GEODESIC and ArcType.RHUMB.');\r\n    }\r\n    //>>includeEnd('debug');\r\n\r\n    /**\r\n     * The screen space width in pixels.\r\n     * @type {Number}\r\n     */\r\n    this.width = defaultValue(options.width, 1.0); // Doesn't get packed, not necessary for computing geometry.\r\n\r\n    this._positions = positions;\r\n\r\n    /**\r\n     * The distance interval used for interpolating options.points. Zero indicates no interpolation.\r\n     * Default of 9999.0 allows centimeter accuracy with 32 bit floating point.\r\n     * @type {Boolean}\r\n     * @default 9999.0\r\n     */\r\n    this.granularity = defaultValue(options.granularity, 9999.0);\r\n\r\n    /**\r\n     * Whether during geometry creation a line segment will be added between the last and first line positions to make this Polyline a loop.\r\n     * If the geometry has two positions this parameter will be ignored.\r\n     * @type {Boolean}\r\n     * @default false\r\n     */\r\n    this.loop = defaultValue(options.loop, false);\r\n\r\n    /**\r\n     * The type of path the polyline must follow. Valid options are {@link ArcType.GEODESIC} and {@link ArcType.RHUMB}.\r\n     * @type {ArcType}\r\n     * @default ArcType.GEODESIC\r\n     */\r\n    this.arcType = defaultValue(options.arcType, ArcType.GEODESIC);\r\n\r\n    this._ellipsoid = Ellipsoid.WGS84;\r\n\r\n    // MapProjections can't be packed, so store the index to a known MapProjection.\r\n    this._projectionIndex = 0;\r\n    this._workerName = 'createGroundPolylineGeometry';\r\n\r\n    // Used by GroundPolylinePrimitive to signal worker that scenemode is 3D only.\r\n    this._scene3DOnly = false;\r\n}\r\n\r\nObject.defineProperties(GroundPolylineGeometry.prototype, {\r\n    /**\r\n     * The number of elements used to pack the object into an array.\r\n     * @memberof GroundPolylineGeometry.prototype\r\n     * @type {Number}\r\n     * @readonly\r\n     * @private\r\n     */\r\n    packedLength: {\r\n        get: function () {\r\n            return 1.0 + this._positions.length * 3 + 1.0 + 1.0 + 1.0 + Ellipsoid.packedLength + 1.0 + 1.0;\r\n        }\r\n    }\r\n});\r\n\r\n/**\r\n * Set the GroundPolylineGeometry's projection and ellipsoid.\r\n * Used by GroundPolylinePrimitive to signal scene information to the geometry for generating 2D attributes.\r\n *\r\n * @param {GroundPolylineGeometry} groundPolylineGeometry GroundPolylinGeometry describing a polyline on terrain or 3D Tiles.\r\n * @param {Projection} mapProjection A MapProjection used for projecting cartographic coordinates to 2D.\r\n * @private\r\n */\r\nGroundPolylineGeometry.setProjectionAndEllipsoid = function (groundPolylineGeometry, mapProjection) {\r\n    var projectionIndex = 0;\r\n    for (var i = 0; i < PROJECTION_COUNT; i++) {\r\n        if (mapProjection instanceof PROJECTIONS[i]) {\r\n            projectionIndex = i;\r\n            break;\r\n        }\r\n    }\r\n\r\n    groundPolylineGeometry._projectionIndex = projectionIndex;\r\n    groundPolylineGeometry._ellipsoid = mapProjection.ellipsoid;\r\n};\r\n\r\nvar cart3Scratch1 = new Cartesian3();\r\nvar cart3Scratch2 = new Cartesian3();\r\nvar cart3Scratch3 = new Cartesian3();\r\nfunction computeRightNormal(start, end, maxHeight, ellipsoid, result) {\r\n    var startBottom = getPosition(ellipsoid, start, 0.0, cart3Scratch1);\r\n    var startTop = getPosition(ellipsoid, start, maxHeight, cart3Scratch2);\r\n    var endBottom = getPosition(ellipsoid, end, 0.0, cart3Scratch3);\r\n\r\n    var up = direction(startTop, startBottom, cart3Scratch2);\r\n    var forward = direction(endBottom, startBottom, cart3Scratch3);\r\n\r\n    Cartesian3.cross(forward, up, result);\r\n    return Cartesian3.normalize(result, result);\r\n}\r\n\r\nvar interpolatedCartographicScratch = new Cartographic();\r\nvar interpolatedBottomScratch = new Cartesian3();\r\nvar interpolatedTopScratch = new Cartesian3();\r\nvar interpolatedNormalScratch = new Cartesian3();\r\nfunction interpolateSegment(start, end, minHeight, maxHeight, granularity, arcType, ellipsoid, normalsArray, bottomPositionsArray, topPositionsArray, cartographicsArray) {\r\n    if (granularity === 0.0) {\r\n        return;\r\n    }\r\n\r\n    var ellipsoidLine;\r\n    if (arcType === ArcType.GEODESIC) {\r\n        ellipsoidLine = new EllipsoidGeodesic(start, end, ellipsoid);\r\n    } else if (arcType === ArcType.RHUMB) {\r\n        ellipsoidLine = new EllipsoidRhumbLine(start, end, ellipsoid);\r\n    }\r\n\r\n    var surfaceDistance = ellipsoidLine.surfaceDistance;\r\n    if (surfaceDistance < granularity) {\r\n        return;\r\n    }\r\n\r\n    // Compute rightwards normal applicable at all interpolated points\r\n    var interpolatedNormal = computeRightNormal(start, end, maxHeight, ellipsoid, interpolatedNormalScratch);\r\n\r\n    var segments = Math.ceil(surfaceDistance / granularity);\r\n    var interpointDistance = surfaceDistance / segments;\r\n    var distanceFromStart = interpointDistance;\r\n    var pointsToAdd = segments - 1;\r\n    var packIndex = normalsArray.length;\r\n    for (var i = 0; i < pointsToAdd; i++) {\r\n        var interpolatedCartographic = ellipsoidLine.interpolateUsingSurfaceDistance(distanceFromStart, interpolatedCartographicScratch);\r\n        var interpolatedBottom = getPosition(ellipsoid, interpolatedCartographic, minHeight, interpolatedBottomScratch);\r\n        var interpolatedTop = getPosition(ellipsoid, interpolatedCartographic, maxHeight, interpolatedTopScratch);\r\n\r\n        Cartesian3.pack(interpolatedNormal, normalsArray, packIndex);\r\n        Cartesian3.pack(interpolatedBottom, bottomPositionsArray, packIndex);\r\n        Cartesian3.pack(interpolatedTop, topPositionsArray, packIndex);\r\n        cartographicsArray.push(interpolatedCartographic.latitude);\r\n        cartographicsArray.push(interpolatedCartographic.longitude);\r\n\r\n        packIndex += 3;\r\n        distanceFromStart += interpointDistance;\r\n    }\r\n}\r\n\r\nvar heightlessCartographicScratch = new Cartographic();\r\nfunction getPosition(ellipsoid, cartographic, height, result) {\r\n    Cartographic.clone(cartographic, heightlessCartographicScratch);\r\n    heightlessCartographicScratch.height = height;\r\n    return Cartographic.toCartesian(heightlessCartographicScratch, ellipsoid, result);\r\n}\r\n\r\n/**\r\n * Stores the provided instance into the provided array.\r\n *\r\n * @param {PolygonGeometry} value The value to pack.\r\n * @param {Number[]} array The array to pack into.\r\n * @param {Number} [startingIndex=0] The index into the array at which to start packing the elements.\r\n *\r\n * @returns {Number[]} The array that was packed into\r\n */\r\nGroundPolylineGeometry.pack = function (value, array, startingIndex) {\r\n    //>>includeStart('debug', pragmas.debug);\r\n    Check.typeOf.object('value', value);\r\n    Check.defined('array', array);\r\n    //>>includeEnd('debug');\r\n\r\n    var index = defaultValue(startingIndex, 0);\r\n\r\n    var positions = value._positions;\r\n    var positionsLength = positions.length;\r\n\r\n    array[index++] = positionsLength;\r\n\r\n    for (var i = 0; i < positionsLength; ++i) {\r\n        var cartesian = positions[i];\r\n        Cartesian3.pack(cartesian, array, index);\r\n        index += 3;\r\n    }\r\n\r\n    array[index++] = value.granularity;\r\n    array[index++] = value.loop ? 1.0 : 0.0;\r\n    array[index++] = value.arcType;\r\n\r\n    Ellipsoid.pack(value._ellipsoid, array, index);\r\n    index += Ellipsoid.packedLength;\r\n\r\n    array[index++] = value._projectionIndex;\r\n    array[index++] = value._scene3DOnly ? 1.0 : 0.0;\r\n\r\n    return array;\r\n};\r\n\r\n/**\r\n * Retrieves an instance from a packed array.\r\n *\r\n * @param {Number[]} array The packed array.\r\n * @param {Number} [startingIndex=0] The starting index of the element to be unpacked.\r\n * @param {PolygonGeometry} [result] The object into which to store the result.\r\n */\r\nGroundPolylineGeometry.unpack = function (array, startingIndex, result) {\r\n    //>>includeStart('debug', pragmas.debug);\r\n    Check.defined('array', array);\r\n    //>>includeEnd('debug');\r\n\r\n    var index = defaultValue(startingIndex, 0);\r\n    var positionsLength = array[index++];\r\n    var positions = new Array(positionsLength);\r\n\r\n    for (var i = 0; i < positionsLength; i++) {\r\n        positions[i] = Cartesian3.unpack(array, index);\r\n        index += 3;\r\n    }\r\n\r\n    var granularity = array[index++];\r\n    var loop = array[index++] === 1.0;\r\n    var arcType = array[index++];\r\n\r\n    var ellipsoid = Ellipsoid.unpack(array, index);\r\n    index += Ellipsoid.packedLength;\r\n\r\n    var projectionIndex = array[index++];\r\n    var scene3DOnly = array[index++] === 1.0;\r\n\r\n    if (!defined(result)) {\r\n        result = new GroundPolylineGeometry({\r\n            positions: positions\r\n        });\r\n    }\r\n\r\n    result._positions = positions;\r\n    result.granularity = granularity;\r\n    result.loop = loop;\r\n    result.arcType = arcType;\r\n    result._ellipsoid = ellipsoid;\r\n    result._projectionIndex = projectionIndex;\r\n    result._scene3DOnly = scene3DOnly;\r\n\r\n    return result;\r\n};\r\n\r\nfunction direction(target, origin, result) {\r\n    Cartesian3.subtract(target, origin, result);\r\n    Cartesian3.normalize(result, result);\r\n    return result;\r\n}\r\n\r\nfunction tangentDirection(target, origin, up, result) {\r\n    result = direction(target, origin, result);\r\n\r\n    // orthogonalize\r\n    result = Cartesian3.cross(result, up, result);\r\n    result = Cartesian3.normalize(result, result);\r\n    result = Cartesian3.cross(up, result, result);\r\n    return result;\r\n}\r\n\r\nvar toPreviousScratch = new Cartesian3();\r\nvar toNextScratch = new Cartesian3();\r\nvar forwardScratch = new Cartesian3();\r\nvar vertexUpScratch = new Cartesian3();\r\nvar cosine90 = 0.0;\r\nvar cosine180 = -1.0;\r\nfunction computeVertexMiterNormal(previousBottom, vertexBottom, vertexTop, nextBottom, result) {\r\n    var up = direction(vertexTop, vertexBottom, vertexUpScratch);\r\n\r\n    // Compute vectors pointing towards neighboring points but tangent to this point on the ellipsoid\r\n    var toPrevious = tangentDirection(previousBottom, vertexBottom, up, toPreviousScratch);\r\n    var toNext = tangentDirection(nextBottom, vertexBottom, up, toNextScratch);\r\n\r\n    // Check if tangents are almost opposite - if so, no need to miter.\r\n    if (CesiumMath.equalsEpsilon(Cartesian3.dot(toPrevious, toNext), cosine180, CesiumMath.EPSILON5)) {\r\n        result = Cartesian3.cross(up, toPrevious, result);\r\n        result = Cartesian3.normalize(result, result);\r\n        return result;\r\n    }\r\n\r\n    // Average directions to previous and to next in the plane of Up\r\n    result = Cartesian3.add(toNext, toPrevious, result);\r\n    result = Cartesian3.normalize(result, result);\r\n\r\n    // Flip the normal if it isn't pointing roughly bound right (aka if forward is pointing more \"backwards\")\r\n    var forward = Cartesian3.cross(up, result, forwardScratch);\r\n    if (Cartesian3.dot(toNext, forward) < cosine90) {\r\n        result = Cartesian3.negate(result, result);\r\n    }\r\n\r\n    return result;\r\n}\r\n\r\nvar XZ_PLANE = Plane.fromPointNormal(Cartesian3.ZERO, Cartesian3.UNIT_Y);\r\n\r\nvar previousBottomScratch = new Cartesian3();\r\nvar vertexBottomScratch = new Cartesian3();\r\nvar vertexTopScratch = new Cartesian3();\r\nvar nextBottomScratch = new Cartesian3();\r\nvar vertexNormalScratch = new Cartesian3();\r\nvar intersectionScratch = new Cartesian3();\r\nvar cartographicScratch0 = new Cartographic();\r\nvar cartographicScratch1 = new Cartographic();\r\nvar cartographicIntersectionScratch = new Cartographic();\r\n/**\r\n * Computes shadow volumes for the ground polyline, consisting of its vertices, indices, and a bounding sphere.\r\n * Vertices are \"fat,\" packing all the data needed in each volume to describe a line on terrain or 3D Tiles.\r\n * Should not be called independent of {@link GroundPolylinePrimitive}.\r\n *\r\n * @param {GroundPolylineGeometry} groundPolylineGeometry\r\n * @private\r\n */\r\nGroundPolylineGeometry.createGeometry = function (groundPolylineGeometry) {\r\n    var compute2dAttributes = !groundPolylineGeometry._scene3DOnly;\r\n    var loop = groundPolylineGeometry.loop;\r\n    var ellipsoid = groundPolylineGeometry._ellipsoid;\r\n    var granularity = groundPolylineGeometry.granularity;\r\n    var arcType = groundPolylineGeometry.arcType;\r\n    var projection = new PROJECTIONS[groundPolylineGeometry._projectionIndex](ellipsoid);\r\n\r\n    var minHeight = WALL_INITIAL_MIN_HEIGHT;\r\n    var maxHeight = WALL_INITIAL_MAX_HEIGHT;\r\n\r\n    var index;\r\n    var i;\r\n\r\n    var positions = groundPolylineGeometry._positions;\r\n    var positionsLength = positions.length;\r\n\r\n    if (positionsLength === 2) {\r\n        loop = false;\r\n    }\r\n\r\n    // Split positions across the IDL and the Prime Meridian as well.\r\n    // Split across prime meridian because very large geometries crossing the Prime Meridian but not the IDL\r\n    // may get split by the plane of IDL + Prime Meridian.\r\n    var p0;\r\n    var p1;\r\n    var c0;\r\n    var c1;\r\n    var rhumbLine = new EllipsoidRhumbLine(undefined, undefined, ellipsoid);\r\n    var intersection;\r\n    var intersectionCartographic;\r\n    var intersectionLongitude;\r\n    var splitPositions = [positions[0]];\r\n    for (i = 0; i < positionsLength - 1; i++) {\r\n        p0 = positions[i];\r\n        p1 = positions[i + 1];\r\n        intersection = IntersectionTests.lineSegmentPlane(p0, p1, XZ_PLANE, intersectionScratch);\r\n        if (defined(intersection) && !Cartesian3.equalsEpsilon(intersection, p0, CesiumMath.EPSILON7) && !Cartesian3.equalsEpsilon(intersection, p1, CesiumMath.EPSILON7)) {\r\n            if (groundPolylineGeometry.arcType === ArcType.GEODESIC) {\r\n                splitPositions.push(Cartesian3.clone(intersection));\r\n            } else if (groundPolylineGeometry.arcType === ArcType.RHUMB) {\r\n                intersectionLongitude = ellipsoid.cartesianToCartographic(intersection, cartographicScratch0).longitude;\r\n                c0 = ellipsoid.cartesianToCartographic(p0, cartographicScratch0);\r\n                c1 = ellipsoid.cartesianToCartographic(p1, cartographicScratch1);\r\n                rhumbLine.setEndPoints(c0, c1);\r\n                intersectionCartographic = rhumbLine.findIntersectionWithLongitude(intersectionLongitude, cartographicIntersectionScratch);\r\n                intersection = ellipsoid.cartographicToCartesian(intersectionCartographic, intersectionScratch);\r\n                if (defined(intersection) && !Cartesian3.equalsEpsilon(intersection, p0, CesiumMath.EPSILON7) && !Cartesian3.equalsEpsilon(intersection, p1, CesiumMath.EPSILON7)) {\r\n                    splitPositions.push(Cartesian3.clone(intersection));\r\n                }\r\n            }\r\n        }\r\n        splitPositions.push(p1);\r\n    }\r\n\r\n    if (loop) {\r\n        p0 = positions[positionsLength - 1];\r\n        p1 = positions[0];\r\n        intersection = IntersectionTests.lineSegmentPlane(p0, p1, XZ_PLANE, intersectionScratch);\r\n        if (defined(intersection) && !Cartesian3.equalsEpsilon(intersection, p0, CesiumMath.EPSILON7) && !Cartesian3.equalsEpsilon(intersection, p1, CesiumMath.EPSILON7)) {\r\n            if (groundPolylineGeometry.arcType === ArcType.GEODESIC) {\r\n                splitPositions.push(Cartesian3.clone(intersection));\r\n            } else if (groundPolylineGeometry.arcType === ArcType.RHUMB) {\r\n                intersectionLongitude = ellipsoid.cartesianToCartographic(intersection, cartographicScratch0).longitude;\r\n                c0 = ellipsoid.cartesianToCartographic(p0, cartographicScratch0);\r\n                c1 = ellipsoid.cartesianToCartographic(p1, cartographicScratch1);\r\n                rhumbLine.setEndPoints(c0, c1);\r\n                intersectionCartographic = rhumbLine.findIntersectionWithLongitude(intersectionLongitude, cartographicIntersectionScratch);\r\n                intersection = ellipsoid.cartographicToCartesian(intersectionCartographic, intersectionScratch);\r\n                if (defined(intersection) && !Cartesian3.equalsEpsilon(intersection, p0, CesiumMath.EPSILON7) && !Cartesian3.equalsEpsilon(intersection, p1, CesiumMath.EPSILON7)) {\r\n                    splitPositions.push(Cartesian3.clone(intersection));\r\n                }\r\n            }\r\n        }\r\n    }\r\n    var cartographicsLength = splitPositions.length;\r\n\r\n    var cartographics = new Array(cartographicsLength);\r\n    for (i = 0; i < cartographicsLength; i++) {\r\n        var cartographic = Cartographic.fromCartesian(splitPositions[i], ellipsoid);\r\n        cartographic.height = 0.0;\r\n        cartographics[i] = cartographic;\r\n    }\r\n\r\n    cartographics = arrayRemoveDuplicates(cartographics, Cartographic.equalsEpsilon);\r\n    cartographicsLength = cartographics.length;\r\n\r\n    if (cartographicsLength < 2) {\r\n        return undefined;\r\n    }\r\n\r\n    /**** Build heap-side arrays for positions, interpolated cartographics, and normals from which to compute vertices ****/\r\n    // We build a \"wall\" and then decompose it into separately connected component \"volumes\" because we need a lot\r\n    // of information about the wall. Also, this simplifies interpolation.\r\n    // Convention: \"next\" and \"end\" are locally forward to each segment of the wall,\r\n    // and we are computing normals pointing towards the local right side of the vertices in each segment.\r\n    var cartographicsArray = [];\r\n    var normalsArray = [];\r\n    var bottomPositionsArray = [];\r\n    var topPositionsArray = [];\r\n\r\n    var previousBottom = previousBottomScratch;\r\n    var vertexBottom = vertexBottomScratch;\r\n    var vertexTop = vertexTopScratch;\r\n    var nextBottom = nextBottomScratch;\r\n    var vertexNormal = vertexNormalScratch;\r\n\r\n    // First point - either loop or attach a \"perpendicular\" normal\r\n    var startCartographic = cartographics[0];\r\n    var nextCartographic = cartographics[1];\r\n\r\n    var prestartCartographic = cartographics[cartographicsLength - 1];\r\n    previousBottom = getPosition(ellipsoid, prestartCartographic, minHeight, previousBottom);\r\n    nextBottom = getPosition(ellipsoid, nextCartographic, minHeight, nextBottom);\r\n    vertexBottom = getPosition(ellipsoid, startCartographic, minHeight, vertexBottom);\r\n    vertexTop = getPosition(ellipsoid, startCartographic, maxHeight, vertexTop);\r\n\r\n    if (loop) {\r\n        vertexNormal = computeVertexMiterNormal(previousBottom, vertexBottom, vertexTop, nextBottom, vertexNormal);\r\n    } else {\r\n        vertexNormal = computeRightNormal(startCartographic, nextCartographic, maxHeight, ellipsoid, vertexNormal);\r\n    }\r\n\r\n    Cartesian3.pack(vertexNormal, normalsArray, 0);\r\n    Cartesian3.pack(vertexBottom, bottomPositionsArray, 0);\r\n    Cartesian3.pack(vertexTop, topPositionsArray, 0);\r\n    cartographicsArray.push(startCartographic.latitude);\r\n    cartographicsArray.push(startCartographic.longitude);\r\n\r\n    interpolateSegment(\r\n        startCartographic,\r\n        nextCartographic,\r\n        minHeight,\r\n        maxHeight,\r\n        granularity,\r\n        arcType,\r\n        ellipsoid,\r\n        normalsArray,\r\n        bottomPositionsArray,\r\n        topPositionsArray,\r\n        cartographicsArray\r\n    );\r\n\r\n    // All inbetween points\r\n    for (i = 1; i < cartographicsLength - 1; ++i) {\r\n        previousBottom = Cartesian3.clone(vertexBottom, previousBottom);\r\n        vertexBottom = Cartesian3.clone(nextBottom, vertexBottom);\r\n        var vertexCartographic = cartographics[i];\r\n        getPosition(ellipsoid, vertexCartographic, maxHeight, vertexTop);\r\n        getPosition(ellipsoid, cartographics[i + 1], minHeight, nextBottom);\r\n\r\n        computeVertexMiterNormal(previousBottom, vertexBottom, vertexTop, nextBottom, vertexNormal);\r\n\r\n        index = normalsArray.length;\r\n        Cartesian3.pack(vertexNormal, normalsArray, index);\r\n        Cartesian3.pack(vertexBottom, bottomPositionsArray, index);\r\n        Cartesian3.pack(vertexTop, topPositionsArray, index);\r\n        cartographicsArray.push(vertexCartographic.latitude);\r\n        cartographicsArray.push(vertexCartographic.longitude);\r\n\r\n        interpolateSegment(\r\n            cartographics[i],\r\n            cartographics[i + 1],\r\n            minHeight,\r\n            maxHeight,\r\n            granularity,\r\n            arcType,\r\n            ellipsoid,\r\n            normalsArray,\r\n            bottomPositionsArray,\r\n            topPositionsArray,\r\n            cartographicsArray\r\n        );\r\n    }\r\n\r\n    // Last point - either loop or attach a normal \"perpendicular\" to the wall.\r\n    var endCartographic = cartographics[cartographicsLength - 1];\r\n    var preEndCartographic = cartographics[cartographicsLength - 2];\r\n\r\n    vertexBottom = getPosition(ellipsoid, endCartographic, minHeight, vertexBottom);\r\n    vertexTop = getPosition(ellipsoid, endCartographic, maxHeight, vertexTop);\r\n\r\n    if (loop) {\r\n        var postEndCartographic = cartographics[0];\r\n        previousBottom = getPosition(ellipsoid, preEndCartographic, minHeight, previousBottom);\r\n        nextBottom = getPosition(ellipsoid, postEndCartographic, minHeight, nextBottom);\r\n\r\n        vertexNormal = computeVertexMiterNormal(previousBottom, vertexBottom, vertexTop, nextBottom, vertexNormal);\r\n    } else {\r\n        vertexNormal = computeRightNormal(preEndCartographic, endCartographic, maxHeight, ellipsoid, vertexNormal);\r\n    }\r\n\r\n    index = normalsArray.length;\r\n    Cartesian3.pack(vertexNormal, normalsArray, index);\r\n    Cartesian3.pack(vertexBottom, bottomPositionsArray, index);\r\n    Cartesian3.pack(vertexTop, topPositionsArray, index);\r\n    cartographicsArray.push(endCartographic.latitude);\r\n    cartographicsArray.push(endCartographic.longitude);\r\n\r\n    if (loop) {\r\n        interpolateSegment(\r\n            endCartographic,\r\n            startCartographic,\r\n            minHeight,\r\n            maxHeight,\r\n            granularity,\r\n            arcType,\r\n            ellipsoid,\r\n            normalsArray,\r\n            bottomPositionsArray,\r\n            topPositionsArray,\r\n            cartographicsArray\r\n        );\r\n        index = normalsArray.length;\r\n        for (i = 0; i < 3; ++i) {\r\n            normalsArray[index + i] = normalsArray[i];\r\n            bottomPositionsArray[index + i] = bottomPositionsArray[i];\r\n            topPositionsArray[index + i] = topPositionsArray[i];\r\n        }\r\n        cartographicsArray.push(startCartographic.latitude);\r\n        cartographicsArray.push(startCartographic.longitude);\r\n    }\r\n\r\n    return generateGeometryAttributes(loop, projection, bottomPositionsArray, topPositionsArray, normalsArray, cartographicsArray, compute2dAttributes);\r\n};\r\n\r\n// If the end normal angle is too steep compared to the direction of the line segment,\r\n// \"break\" the miter by rotating the normal 90 degrees around the \"up\" direction at the point\r\n// For ultra precision we would want to project into a plane, but in practice this is sufficient.\r\nvar lineDirectionScratch = new Cartesian3();\r\nvar matrix3Scratch = new Matrix3();\r\nvar quaternionScratch = new Quaternion();\r\nfunction breakMiter(endGeometryNormal, startBottom, endBottom, endTop) {\r\n    var lineDirection = direction(endBottom, startBottom, lineDirectionScratch);\r\n\r\n    var dot = Cartesian3.dot(lineDirection, endGeometryNormal);\r\n    if (dot > MITER_BREAK_SMALL || dot < MITER_BREAK_LARGE) {\r\n        var vertexUp = direction(endTop, endBottom, vertexUpScratch);\r\n        var angle = dot < MITER_BREAK_LARGE ? CesiumMath.PI_OVER_TWO : -CesiumMath.PI_OVER_TWO;\r\n        var quaternion = Quaternion.fromAxisAngle(vertexUp, angle, quaternionScratch);\r\n        var rotationMatrix = Matrix3.fromQuaternion(quaternion, matrix3Scratch);\r\n        Matrix3.multiplyByVector(rotationMatrix, endGeometryNormal, endGeometryNormal);\r\n        return true;\r\n    }\r\n    return false;\r\n}\r\n\r\nvar endPosCartographicScratch = new Cartographic();\r\nvar normalStartpointScratch = new Cartesian3();\r\nvar normalEndpointScratch = new Cartesian3();\r\nfunction projectNormal(projection, cartographic, normal, projectedPosition, result) {\r\n    var position = Cartographic.toCartesian(cartographic, projection._ellipsoid, normalStartpointScratch);\r\n    var normalEndpoint = Cartesian3.add(position, normal, normalEndpointScratch);\r\n    var flipNormal = false;\r\n\r\n    var ellipsoid = projection._ellipsoid;\r\n    var normalEndpointCartographic = ellipsoid.cartesianToCartographic(normalEndpoint, endPosCartographicScratch);\r\n    // If normal crosses the IDL, go the other way and flip the result.\r\n    // In practice this almost never happens because the cartographic start\r\n    // and end points of each segment are \"nudged\" to be on the same side\r\n    // of the IDL and slightly away from the IDL.\r\n    if (Math.abs(cartographic.longitude - normalEndpointCartographic.longitude) > CesiumMath.PI_OVER_TWO) {\r\n        flipNormal = true;\r\n        normalEndpoint = Cartesian3.subtract(position, normal, normalEndpointScratch);\r\n        normalEndpointCartographic = ellipsoid.cartesianToCartographic(normalEndpoint, endPosCartographicScratch);\r\n    }\r\n\r\n    normalEndpointCartographic.height = 0.0;\r\n    var normalEndpointProjected = projection.project(normalEndpointCartographic, result);\r\n    result = Cartesian3.subtract(normalEndpointProjected, projectedPosition, result);\r\n    result.z = 0.0;\r\n    result = Cartesian3.normalize(result, result);\r\n    if (flipNormal) {\r\n        Cartesian3.negate(result, result);\r\n    }\r\n    return result;\r\n}\r\n\r\nvar adjustHeightNormalScratch = new Cartesian3();\r\nvar adjustHeightOffsetScratch = new Cartesian3();\r\nfunction adjustHeights(bottom, top, minHeight, maxHeight, adjustHeightBottom, adjustHeightTop) {\r\n    // bottom and top should be at WALL_INITIAL_MIN_HEIGHT and WALL_INITIAL_MAX_HEIGHT, respectively\r\n    var adjustHeightNormal = Cartesian3.subtract(top, bottom, adjustHeightNormalScratch);\r\n    Cartesian3.normalize(adjustHeightNormal, adjustHeightNormal);\r\n\r\n    var distanceForBottom = minHeight - WALL_INITIAL_MIN_HEIGHT;\r\n    var adjustHeightOffset = Cartesian3.multiplyByScalar(adjustHeightNormal, distanceForBottom, adjustHeightOffsetScratch);\r\n    Cartesian3.add(bottom, adjustHeightOffset, adjustHeightBottom);\r\n\r\n    var distanceForTop = maxHeight - WALL_INITIAL_MAX_HEIGHT;\r\n    adjustHeightOffset = Cartesian3.multiplyByScalar(adjustHeightNormal, distanceForTop, adjustHeightOffsetScratch);\r\n    Cartesian3.add(top, adjustHeightOffset, adjustHeightTop);\r\n}\r\n\r\nvar nudgeDirectionScratch = new Cartesian3();\r\nfunction nudgeXZ(start, end) {\r\n    var startToXZdistance = Plane.getPointDistance(XZ_PLANE, start);\r\n    var endToXZdistance = Plane.getPointDistance(XZ_PLANE, end);\r\n    var offset = nudgeDirectionScratch;\r\n    // Larger epsilon than what's used in GeometryPipeline, a centimeter in world space\r\n    if (CesiumMath.equalsEpsilon(startToXZdistance, 0.0, CesiumMath.EPSILON2)) {\r\n        offset = direction(end, start, offset);\r\n        Cartesian3.multiplyByScalar(offset, CesiumMath.EPSILON2, offset);\r\n        Cartesian3.add(start, offset, start);\r\n    } else if (CesiumMath.equalsEpsilon(endToXZdistance, 0.0, CesiumMath.EPSILON2)) {\r\n        offset = direction(start, end, offset);\r\n        Cartesian3.multiplyByScalar(offset, CesiumMath.EPSILON2, offset);\r\n        Cartesian3.add(end, offset, end);\r\n    }\r\n}\r\n\r\n// \"Nudge\" cartographic coordinates so start and end are on the same side of the IDL.\r\n// Nudge amounts are tiny, basically just an IDL flip.\r\n// Only used for 2D/CV.\r\nfunction nudgeCartographic(start, end) {\r\n    var absStartLon = Math.abs(start.longitude);\r\n    var absEndLon = Math.abs(end.longitude);\r\n    if (CesiumMath.equalsEpsilon(absStartLon, CesiumMath.PI, CesiumMath.EPSILON11)) {\r\n        var endSign = CesiumMath.sign(end.longitude);\r\n        start.longitude = endSign * (absStartLon - CesiumMath.EPSILON11);\r\n        return 1;\r\n    } else if (CesiumMath.equalsEpsilon(absEndLon, CesiumMath.PI, CesiumMath.EPSILON11)) {\r\n        var startSign = CesiumMath.sign(start.longitude);\r\n        end.longitude = startSign * (absEndLon - CesiumMath.EPSILON11);\r\n        return 2;\r\n    }\r\n    return 0;\r\n}\r\n\r\nvar startCartographicScratch = new Cartographic();\r\nvar endCartographicScratch = new Cartographic();\r\n\r\nvar segmentStartTopScratch = new Cartesian3();\r\nvar segmentEndTopScratch = new Cartesian3();\r\nvar segmentStartBottomScratch = new Cartesian3();\r\nvar segmentEndBottomScratch = new Cartesian3();\r\nvar segmentStartNormalScratch = new Cartesian3();\r\nvar segmentEndNormalScratch = new Cartesian3();\r\n\r\nvar getHeightCartographics = [startCartographicScratch, endCartographicScratch];\r\nvar getHeightRectangleScratch = new Rectangle();\r\n\r\nvar adjustHeightStartTopScratch = new Cartesian3();\r\nvar adjustHeightEndTopScratch = new Cartesian3();\r\nvar adjustHeightStartBottomScratch = new Cartesian3();\r\nvar adjustHeightEndBottomScratch = new Cartesian3();\r\n\r\nvar segmentStart2DScratch = new Cartesian3();\r\nvar segmentEnd2DScratch = new Cartesian3();\r\nvar segmentStartNormal2DScratch = new Cartesian3();\r\nvar segmentEndNormal2DScratch = new Cartesian3();\r\n\r\nvar offsetScratch = new Cartesian3();\r\nvar startUpScratch = new Cartesian3();\r\nvar endUpScratch = new Cartesian3();\r\nvar rightScratch = new Cartesian3();\r\nvar startPlaneNormalScratch = new Cartesian3();\r\nvar endPlaneNormalScratch = new Cartesian3();\r\nvar encodeScratch = new EncodedCartesian3();\r\n\r\nvar encodeScratch2D = new EncodedCartesian3();\r\nvar forwardOffset2DScratch = new Cartesian3();\r\nvar right2DScratch = new Cartesian3();\r\n\r\nvar normalNudgeScratch = new Cartesian3();\r\n\r\nvar scratchBoundingSpheres = [new BoundingSphere(), new BoundingSphere()];\r\n\r\n// Winding order is reversed so each segment's volume is inside-out\r\nvar REFERENCE_INDICES = [\r\n    0,\r\n    2,\r\n    1,\r\n    0,\r\n    3,\r\n    2, // right\r\n    0,\r\n    7,\r\n    3,\r\n    0,\r\n    4,\r\n    7, // start\r\n    0,\r\n    5,\r\n    4,\r\n    0,\r\n    1,\r\n    5, // bottom\r\n    5,\r\n    7,\r\n    4,\r\n    5,\r\n    6,\r\n    7, // left\r\n    5,\r\n    2,\r\n    6,\r\n    5,\r\n    1,\r\n    2, // end\r\n    3,\r\n    6,\r\n    2,\r\n    3,\r\n    7,\r\n    6 // top\r\n];\r\nvar REFERENCE_INDICES_LENGTH = REFERENCE_INDICES.length;\r\n\r\n// Decompose the \"wall\" into a series of shadow volumes.\r\n// Each shadow volume's vertices encode a description of the line it contains,\r\n// including mitering planes at the end points, a plane along the line itself,\r\n// and attributes for computing length-wise texture coordinates.\r\nfunction generateGeometryAttributes(loop, projection, bottomPositionsArray, topPositionsArray, normalsArray, cartographicsArray, compute2dAttributes) {\r\n    var i;\r\n    var index;\r\n    var ellipsoid = projection._ellipsoid;\r\n\r\n    // Each segment will have 8 vertices\r\n    var segmentCount = bottomPositionsArray.length / 3 - 1;\r\n    var vertexCount = segmentCount * 8;\r\n    var arraySizeVec4 = vertexCount * 4;\r\n    var indexCount = segmentCount * 36;\r\n\r\n    var indices = vertexCount > 65535 ? new Uint32Array(indexCount) : new Uint16Array(indexCount);\r\n    var positionsArray = new Float64Array(vertexCount * 3);\r\n\r\n    var startHiAndForwardOffsetX = new Float32Array(arraySizeVec4);\r\n    var startLoAndForwardOffsetY = new Float32Array(arraySizeVec4);\r\n    var startNormalAndForwardOffsetZ = new Float32Array(arraySizeVec4);\r\n    var endNormalAndTextureCoordinateNormalizationX = new Float32Array(arraySizeVec4);\r\n    var rightNormalAndTextureCoordinateNormalizationY = new Float32Array(arraySizeVec4);\r\n\r\n    var startHiLo2D;\r\n    var offsetAndRight2D;\r\n    var startEndNormals2D;\r\n    var texcoordNormalization2D;\r\n\r\n    if (compute2dAttributes) {\r\n        startHiLo2D = new Float32Array(arraySizeVec4);\r\n        offsetAndRight2D = new Float32Array(arraySizeVec4);\r\n        startEndNormals2D = new Float32Array(arraySizeVec4);\r\n        texcoordNormalization2D = new Float32Array(vertexCount * 2);\r\n    }\r\n\r\n    /*** Compute total lengths for texture coordinate normalization ***/\r\n    // 2D\r\n    var cartographicsLength = cartographicsArray.length / 2;\r\n    var length2D = 0.0;\r\n\r\n    var startCartographic = startCartographicScratch;\r\n    startCartographic.height = 0.0;\r\n    var endCartographic = endCartographicScratch;\r\n    endCartographic.height = 0.0;\r\n\r\n    var segmentStartCartesian = segmentStartTopScratch;\r\n    var segmentEndCartesian = segmentEndTopScratch;\r\n\r\n    if (compute2dAttributes) {\r\n        index = 0;\r\n        for (i = 1; i < cartographicsLength; i++) {\r\n            // Don't clone anything from previous segment b/c possible IDL touch\r\n            startCartographic.latitude = cartographicsArray[index];\r\n            startCartographic.longitude = cartographicsArray[index + 1];\r\n            endCartographic.latitude = cartographicsArray[index + 2];\r\n            endCartographic.longitude = cartographicsArray[index + 3];\r\n\r\n            segmentStartCartesian = projection.project(startCartographic, segmentStartCartesian);\r\n            segmentEndCartesian = projection.project(endCartographic, segmentEndCartesian);\r\n            length2D += Cartesian3.distance(segmentStartCartesian, segmentEndCartesian);\r\n            index += 2;\r\n        }\r\n    }\r\n\r\n    // 3D\r\n    var positionsLength = topPositionsArray.length / 3;\r\n    segmentEndCartesian = Cartesian3.unpack(topPositionsArray, 0, segmentEndCartesian);\r\n    var length3D = 0.0;\r\n\r\n    index = 3;\r\n    for (i = 1; i < positionsLength; i++) {\r\n        segmentStartCartesian = Cartesian3.clone(segmentEndCartesian, segmentStartCartesian);\r\n        segmentEndCartesian = Cartesian3.unpack(topPositionsArray, index, segmentEndCartesian);\r\n        length3D += Cartesian3.distance(segmentStartCartesian, segmentEndCartesian);\r\n        index += 3;\r\n    }\r\n\r\n    /*** Generate segments ***/\r\n    var j;\r\n    index = 3;\r\n    var cartographicsIndex = 0;\r\n    var vec2sWriteIndex = 0;\r\n    var vec3sWriteIndex = 0;\r\n    var vec4sWriteIndex = 0;\r\n    var miterBroken = false;\r\n\r\n    var endBottom = Cartesian3.unpack(bottomPositionsArray, 0, segmentEndBottomScratch);\r\n    var endTop = Cartesian3.unpack(topPositionsArray, 0, segmentEndTopScratch);\r\n    var endGeometryNormal = Cartesian3.unpack(normalsArray, 0, segmentEndNormalScratch);\r\n\r\n    if (loop) {\r\n        var preEndBottom = Cartesian3.unpack(bottomPositionsArray, bottomPositionsArray.length - 6, segmentStartBottomScratch);\r\n        if (breakMiter(endGeometryNormal, preEndBottom, endBottom, endTop)) {\r\n            // Miter broken as if for the last point in the loop, needs to be inverted for first point (clone of endBottom)\r\n            endGeometryNormal = Cartesian3.negate(endGeometryNormal, endGeometryNormal);\r\n        }\r\n    }\r\n\r\n    var lengthSoFar3D = 0.0;\r\n    var lengthSoFar2D = 0.0;\r\n\r\n    // For translating bounding volume\r\n    var sumHeights = 0.0;\r\n\r\n    for (i = 0; i < segmentCount; i++) {\r\n        var startBottom = Cartesian3.clone(endBottom, segmentStartBottomScratch);\r\n        var startTop = Cartesian3.clone(endTop, segmentStartTopScratch);\r\n        var startGeometryNormal = Cartesian3.clone(endGeometryNormal, segmentStartNormalScratch);\r\n\r\n        if (miterBroken) {\r\n            startGeometryNormal = Cartesian3.negate(startGeometryNormal, startGeometryNormal);\r\n        }\r\n\r\n        endBottom = Cartesian3.unpack(bottomPositionsArray, index, segmentEndBottomScratch);\r\n        endTop = Cartesian3.unpack(topPositionsArray, index, segmentEndTopScratch);\r\n        endGeometryNormal = Cartesian3.unpack(normalsArray, index, segmentEndNormalScratch);\r\n\r\n        miterBroken = breakMiter(endGeometryNormal, startBottom, endBottom, endTop);\r\n\r\n        // 2D - don't clone anything from previous segment b/c possible IDL touch\r\n        startCartographic.latitude = cartographicsArray[cartographicsIndex];\r\n        startCartographic.longitude = cartographicsArray[cartographicsIndex + 1];\r\n        endCartographic.latitude = cartographicsArray[cartographicsIndex + 2];\r\n        endCartographic.longitude = cartographicsArray[cartographicsIndex + 3];\r\n        var start2D;\r\n        var end2D;\r\n        var startGeometryNormal2D;\r\n        var endGeometryNormal2D;\r\n\r\n        if (compute2dAttributes) {\r\n            var nudgeResult = nudgeCartographic(startCartographic, endCartographic);\r\n            start2D = projection.project(startCartographic, segmentStart2DScratch);\r\n            end2D = projection.project(endCartographic, segmentEnd2DScratch);\r\n            var direction2D = direction(end2D, start2D, forwardOffset2DScratch);\r\n            direction2D.y = Math.abs(direction2D.y);\r\n\r\n            startGeometryNormal2D = segmentStartNormal2DScratch;\r\n            endGeometryNormal2D = segmentEndNormal2DScratch;\r\n            if (nudgeResult === 0 || Cartesian3.dot(direction2D, Cartesian3.UNIT_Y) > MITER_BREAK_SMALL) {\r\n                // No nudge - project the original normal\r\n                // Or, if the line's angle relative to the IDL is very acute,\r\n                // in which case snapping will produce oddly shaped volumes.\r\n                startGeometryNormal2D = projectNormal(projection, startCartographic, startGeometryNormal, start2D, segmentStartNormal2DScratch);\r\n                endGeometryNormal2D = projectNormal(projection, endCartographic, endGeometryNormal, end2D, segmentEndNormal2DScratch);\r\n            } else if (nudgeResult === 1) {\r\n                // Start is close to IDL - snap start normal to align with IDL\r\n                endGeometryNormal2D = projectNormal(projection, endCartographic, endGeometryNormal, end2D, segmentEndNormal2DScratch);\r\n                startGeometryNormal2D.x = 0.0;\r\n                // If start longitude is negative and end longitude is less negative, relative right is unit -Y\r\n                // If start longitude is positive and end longitude is less positive, relative right is unit +Y\r\n                startGeometryNormal2D.y = CesiumMath.sign(startCartographic.longitude - Math.abs(endCartographic.longitude));\r\n                startGeometryNormal2D.z = 0.0;\r\n            } else {\r\n                // End is close to IDL - snap end normal to align with IDL\r\n                startGeometryNormal2D = projectNormal(projection, startCartographic, startGeometryNormal, start2D, segmentStartNormal2DScratch);\r\n                endGeometryNormal2D.x = 0.0;\r\n                // If end longitude is negative and start longitude is less negative, relative right is unit Y\r\n                // If end longitude is positive and start longitude is less positive, relative right is unit -Y\r\n                endGeometryNormal2D.y = CesiumMath.sign(startCartographic.longitude - endCartographic.longitude);\r\n                endGeometryNormal2D.z = 0.0;\r\n            }\r\n        }\r\n\r\n        /****************************************\r\n         * Geometry descriptors of a \"line on terrain,\"\r\n         * as opposed to the \"shadow volume used to draw\r\n         * the line on terrain\":\r\n         * - position of start + offset to end\r\n         * - start, end, and right-facing planes\r\n         * - encoded texture coordinate offsets\r\n         ****************************************/\r\n\r\n        /* 3D */\r\n        var segmentLength3D = Cartesian3.distance(startTop, endTop);\r\n\r\n        var encodedStart = EncodedCartesian3.fromCartesian(startBottom, encodeScratch);\r\n        var forwardOffset = Cartesian3.subtract(endBottom, startBottom, offsetScratch);\r\n        var forward = Cartesian3.normalize(forwardOffset, rightScratch);\r\n\r\n        var startUp = Cartesian3.subtract(startTop, startBottom, startUpScratch);\r\n        startUp = Cartesian3.normalize(startUp, startUp);\r\n        var rightNormal = Cartesian3.cross(forward, startUp, rightScratch);\r\n        rightNormal = Cartesian3.normalize(rightNormal, rightNormal);\r\n\r\n        var startPlaneNormal = Cartesian3.cross(startUp, startGeometryNormal, startPlaneNormalScratch);\r\n        startPlaneNormal = Cartesian3.normalize(startPlaneNormal, startPlaneNormal);\r\n\r\n        var endUp = Cartesian3.subtract(endTop, endBottom, endUpScratch);\r\n        endUp = Cartesian3.normalize(endUp, endUp);\r\n        var endPlaneNormal = Cartesian3.cross(endGeometryNormal, endUp, endPlaneNormalScratch);\r\n        endPlaneNormal = Cartesian3.normalize(endPlaneNormal, endPlaneNormal);\r\n\r\n        var texcoordNormalization3DX = segmentLength3D / length3D;\r\n        var texcoordNormalization3DY = lengthSoFar3D / length3D;\r\n\r\n        /* 2D */\r\n        var segmentLength2D = 0.0;\r\n        var encodedStart2D;\r\n        var forwardOffset2D;\r\n        var right2D;\r\n        var texcoordNormalization2DX = 0.0;\r\n        var texcoordNormalization2DY = 0.0;\r\n        if (compute2dAttributes) {\r\n            segmentLength2D = Cartesian3.distance(start2D, end2D);\r\n\r\n            encodedStart2D = EncodedCartesian3.fromCartesian(start2D, encodeScratch2D);\r\n            forwardOffset2D = Cartesian3.subtract(end2D, start2D, forwardOffset2DScratch);\r\n\r\n            // Right direction is just forward direction rotated by -90 degrees around Z\r\n            // Similarly with plane normals\r\n            right2D = Cartesian3.normalize(forwardOffset2D, right2DScratch);\r\n            var swap = right2D.x;\r\n            right2D.x = right2D.y;\r\n            right2D.y = -swap;\r\n\r\n            texcoordNormalization2DX = segmentLength2D / length2D;\r\n            texcoordNormalization2DY = lengthSoFar2D / length2D;\r\n        }\r\n        /** Pack **/\r\n        for (j = 0; j < 8; j++) {\r\n            var vec4Index = vec4sWriteIndex + j * 4;\r\n            var vec2Index = vec2sWriteIndex + j * 2;\r\n            var wIndex = vec4Index + 3;\r\n\r\n            // Encode sidedness of vertex relative to right plane in texture coordinate normalization X,\r\n            // whether vertex is top or bottom of volume in sign/magnitude of normalization Y.\r\n            var rightPlaneSide = j < 4 ? 1.0 : -1.0;\r\n            var topBottomSide = j === 2 || j === 3 || j === 6 || j === 7 ? 1.0 : -1.0;\r\n\r\n            // 3D\r\n            Cartesian3.pack(encodedStart.high, startHiAndForwardOffsetX, vec4Index);\r\n            startHiAndForwardOffsetX[wIndex] = forwardOffset.x;\r\n\r\n            Cartesian3.pack(encodedStart.low, startLoAndForwardOffsetY, vec4Index);\r\n            startLoAndForwardOffsetY[wIndex] = forwardOffset.y;\r\n\r\n            Cartesian3.pack(startPlaneNormal, startNormalAndForwardOffsetZ, vec4Index);\r\n            startNormalAndForwardOffsetZ[wIndex] = forwardOffset.z;\r\n\r\n            Cartesian3.pack(endPlaneNormal, endNormalAndTextureCoordinateNormalizationX, vec4Index);\r\n            endNormalAndTextureCoordinateNormalizationX[wIndex] = texcoordNormalization3DX * rightPlaneSide;\r\n\r\n            Cartesian3.pack(rightNormal, rightNormalAndTextureCoordinateNormalizationY, vec4Index);\r\n\r\n            var texcoordNormalization = texcoordNormalization3DY * topBottomSide;\r\n            if (texcoordNormalization === 0.0 && topBottomSide < 0.0) {\r\n                texcoordNormalization = 9.0; // some value greater than 1.0\r\n            }\r\n            rightNormalAndTextureCoordinateNormalizationY[wIndex] = texcoordNormalization;\r\n\r\n            // 2D\r\n            if (compute2dAttributes) {\r\n                startHiLo2D[vec4Index] = encodedStart2D.high.x;\r\n                startHiLo2D[vec4Index + 1] = encodedStart2D.high.y;\r\n                startHiLo2D[vec4Index + 2] = encodedStart2D.low.x;\r\n                startHiLo2D[vec4Index + 3] = encodedStart2D.low.y;\r\n\r\n                startEndNormals2D[vec4Index] = -startGeometryNormal2D.y;\r\n                startEndNormals2D[vec4Index + 1] = startGeometryNormal2D.x;\r\n                startEndNormals2D[vec4Index + 2] = endGeometryNormal2D.y;\r\n                startEndNormals2D[vec4Index + 3] = -endGeometryNormal2D.x;\r\n\r\n                offsetAndRight2D[vec4Index] = forwardOffset2D.x;\r\n                offsetAndRight2D[vec4Index + 1] = forwardOffset2D.y;\r\n                offsetAndRight2D[vec4Index + 2] = right2D.x;\r\n                offsetAndRight2D[vec4Index + 3] = right2D.y;\r\n\r\n                texcoordNormalization2D[vec2Index] = texcoordNormalization2DX * rightPlaneSide;\r\n\r\n                texcoordNormalization = texcoordNormalization2DY * topBottomSide;\r\n                if (texcoordNormalization === 0.0 && topBottomSide < 0.0) {\r\n                    texcoordNormalization = 9.0; // some value greater than 1.0\r\n                }\r\n                texcoordNormalization2D[vec2Index + 1] = texcoordNormalization;\r\n            }\r\n        }\r\n\r\n        // Adjust height of volume in 3D\r\n        var adjustHeightStartBottom = adjustHeightStartBottomScratch;\r\n        var adjustHeightEndBottom = adjustHeightEndBottomScratch;\r\n        var adjustHeightStartTop = adjustHeightStartTopScratch;\r\n        var adjustHeightEndTop = adjustHeightEndTopScratch;\r\n\r\n        var getHeightsRectangle = Rectangle.fromCartographicArray(getHeightCartographics, getHeightRectangleScratch);\r\n        var minMaxHeights = ApproximateTerrainHeights.getMinimumMaximumHeights(getHeightsRectangle, ellipsoid);\r\n        var minHeight = minMaxHeights.minimumTerrainHeight;\r\n        var maxHeight = minMaxHeights.maximumTerrainHeight;\r\n\r\n        sumHeights += minHeight;\r\n        sumHeights += maxHeight;\r\n\r\n        adjustHeights(startBottom, startTop, minHeight, maxHeight, adjustHeightStartBottom, adjustHeightStartTop);\r\n        adjustHeights(endBottom, endTop, minHeight, maxHeight, adjustHeightEndBottom, adjustHeightEndTop);\r\n\r\n        // Nudge the positions away from the \"polyline\" a little bit to prevent errors in GeometryPipeline\r\n        var normalNudge = Cartesian3.multiplyByScalar(rightNormal, CesiumMath.EPSILON5, normalNudgeScratch);\r\n        Cartesian3.add(adjustHeightStartBottom, normalNudge, adjustHeightStartBottom);\r\n        Cartesian3.add(adjustHeightEndBottom, normalNudge, adjustHeightEndBottom);\r\n        Cartesian3.add(adjustHeightStartTop, normalNudge, adjustHeightStartTop);\r\n        Cartesian3.add(adjustHeightEndTop, normalNudge, adjustHeightEndTop);\r\n\r\n        // If the segment is very close to the XZ plane, nudge the vertices slightly to avoid touching it.\r\n        nudgeXZ(adjustHeightStartBottom, adjustHeightEndBottom);\r\n        nudgeXZ(adjustHeightStartTop, adjustHeightEndTop);\r\n\r\n        Cartesian3.pack(adjustHeightStartBottom, positionsArray, vec3sWriteIndex);\r\n        Cartesian3.pack(adjustHeightEndBottom, positionsArray, vec3sWriteIndex + 3);\r\n        Cartesian3.pack(adjustHeightEndTop, positionsArray, vec3sWriteIndex + 6);\r\n        Cartesian3.pack(adjustHeightStartTop, positionsArray, vec3sWriteIndex + 9);\r\n\r\n        normalNudge = Cartesian3.multiplyByScalar(rightNormal, -2.0 * CesiumMath.EPSILON5, normalNudgeScratch);\r\n        Cartesian3.add(adjustHeightStartBottom, normalNudge, adjustHeightStartBottom);\r\n        Cartesian3.add(adjustHeightEndBottom, normalNudge, adjustHeightEndBottom);\r\n        Cartesian3.add(adjustHeightStartTop, normalNudge, adjustHeightStartTop);\r\n        Cartesian3.add(adjustHeightEndTop, normalNudge, adjustHeightEndTop);\r\n\r\n        nudgeXZ(adjustHeightStartBottom, adjustHeightEndBottom);\r\n        nudgeXZ(adjustHeightStartTop, adjustHeightEndTop);\r\n\r\n        Cartesian3.pack(adjustHeightStartBottom, positionsArray, vec3sWriteIndex + 12);\r\n        Cartesian3.pack(adjustHeightEndBottom, positionsArray, vec3sWriteIndex + 15);\r\n        Cartesian3.pack(adjustHeightEndTop, positionsArray, vec3sWriteIndex + 18);\r\n        Cartesian3.pack(adjustHeightStartTop, positionsArray, vec3sWriteIndex + 21);\r\n\r\n        cartographicsIndex += 2;\r\n        index += 3;\r\n\r\n        vec2sWriteIndex += 16;\r\n        vec3sWriteIndex += 24;\r\n        vec4sWriteIndex += 32;\r\n\r\n        lengthSoFar3D += segmentLength3D;\r\n        lengthSoFar2D += segmentLength2D;\r\n    }\r\n\r\n    index = 0;\r\n    var indexOffset = 0;\r\n    for (i = 0; i < segmentCount; i++) {\r\n        for (j = 0; j < REFERENCE_INDICES_LENGTH; j++) {\r\n            indices[index + j] = REFERENCE_INDICES[j] + indexOffset;\r\n        }\r\n        indexOffset += 8;\r\n        index += REFERENCE_INDICES_LENGTH;\r\n    }\r\n\r\n    var boundingSpheres = scratchBoundingSpheres;\r\n    BoundingSphere.fromVertices(bottomPositionsArray, Cartesian3.ZERO, 3, boundingSpheres[0]);\r\n    BoundingSphere.fromVertices(topPositionsArray, Cartesian3.ZERO, 3, boundingSpheres[1]);\r\n    var boundingSphere = BoundingSphere.fromBoundingSpheres(boundingSpheres);\r\n\r\n    // Adjust bounding sphere height and radius to cover more of the volume\r\n    boundingSphere.radius += sumHeights / (segmentCount * 2.0);\r\n\r\n    var attributes = {\r\n        position: new GeometryAttribute({\r\n            componentDatatype: ComponentDatatype.DOUBLE,\r\n            componentsPerAttribute: 3,\r\n            normalize: false,\r\n            values: positionsArray\r\n        }),\r\n        startHiAndForwardOffsetX: getVec4GeometryAttribute(startHiAndForwardOffsetX),\r\n        startLoAndForwardOffsetY: getVec4GeometryAttribute(startLoAndForwardOffsetY),\r\n        startNormalAndForwardOffsetZ: getVec4GeometryAttribute(startNormalAndForwardOffsetZ),\r\n        endNormalAndTextureCoordinateNormalizationX: getVec4GeometryAttribute(endNormalAndTextureCoordinateNormalizationX),\r\n        rightNormalAndTextureCoordinateNormalizationY: getVec4GeometryAttribute(rightNormalAndTextureCoordinateNormalizationY)\r\n    };\r\n\r\n    if (compute2dAttributes) {\r\n        attributes.startHiLo2D = getVec4GeometryAttribute(startHiLo2D);\r\n        attributes.offsetAndRight2D = getVec4GeometryAttribute(offsetAndRight2D);\r\n        attributes.startEndNormals2D = getVec4GeometryAttribute(startEndNormals2D);\r\n        attributes.texcoordNormalization2D = new GeometryAttribute({\r\n            componentDatatype: ComponentDatatype.FLOAT,\r\n            componentsPerAttribute: 2,\r\n            normalize: false,\r\n            values: texcoordNormalization2D\r\n        });\r\n    }\r\n\r\n    return new Geometry({\r\n        attributes: attributes,\r\n        indices: indices,\r\n        boundingSphere: boundingSphere\r\n    });\r\n}\r\n\r\nfunction getVec4GeometryAttribute(typedArray) {\r\n    return new GeometryAttribute({\r\n        componentDatatype: ComponentDatatype.FLOAT,\r\n        componentsPerAttribute: 4,\r\n        normalize: false,\r\n        values: typedArray\r\n    });\r\n}\r\n\r\n/**\r\n * Approximates an ellipsoid-tangent vector in 2D by projecting the end point into 2D.\r\n * Exposed for testing.\r\n *\r\n * @param {MapProjection} projection Map Projection for projecting coordinates to 2D.\r\n * @param {Cartographic} cartographic The cartographic origin point of the normal.\r\n *   Used to check if the normal crosses the IDL during projection.\r\n * @param {Cartesian3} normal The normal in 3D.\r\n * @param {Cartesian3} projectedPosition The projected origin point of the normal in 2D.\r\n * @param {Cartesian3} result Result parameter on which to store the projected normal.\r\n * @private\r\n */\r\nGroundPolylineGeometry._projectNormal = projectNormal;\r\nexport default GroundPolylineGeometry;\r\n","import ApproximateTerrainHeights from '../Core/ApproximateTerrainHeights.js';\r\nimport defined from '../Core/defined.js';\r\nimport GroundPolylineGeometry from '../Core/GroundPolylineGeometry.js';\r\n\r\nfunction createGroundPolylineGeometry(groundPolylineGeometry, offset) {\r\n    return ApproximateTerrainHeights.initialize().then(function () {\r\n        if (defined(offset)) {\r\n            groundPolylineGeometry = GroundPolylineGeometry.unpack(groundPolylineGeometry, offset);\r\n        }\r\n        return GroundPolylineGeometry.createGeometry(groundPolylineGeometry);\r\n    });\r\n}\r\nexport default createGroundPolylineGeometry;\r\n"],"names":["defaultValue","Ellipsoid","Rectangle","GeographicProjection","Check","CesiumMath","defined","Cartesian2","Cartesian3","Cartographic","BoundingSphere","Resource","buildModuleUrl","DeveloperError","WebMercatorProjection","ArcType","EllipsoidGeodesic","EllipsoidRhumbLine","Plane","IntersectionTests","arrayRemoveDuplicates","Matrix3","Quaternion","EncodedCartesian3","GeometryAttribute","ComponentDatatype","Geometry"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;IASA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA,SAAS,sBAAsB,CAAC,OAAO,EAAE;IACzC,IAAI,OAAO,GAAGA,iBAAY,CAAC,OAAO,EAAEA,iBAAY,CAAC,YAAY,CAAC,CAAC;AAC/D;IACA,IAAI,IAAI,CAAC,UAAU,GAAGA,iBAAY,CAAC,OAAO,CAAC,SAAS,EAAEC,oBAAS,CAAC,KAAK,CAAC,CAAC;IACvE,IAAI,IAAI,CAAC,UAAU,GAAGD,iBAAY,CAAC,OAAO,CAAC,SAAS,EAAEE,oBAAS,CAAC,SAAS,CAAC,CAAC;IAC3E,IAAI,IAAI,CAAC,WAAW,GAAG,IAAIC,+BAAoB,CAAC,IAAI,CAAC,UAAU,CAAC,CAAC;IACjE,IAAI,IAAI,CAAC,wBAAwB,GAAGH,iBAAY,CAAC,OAAO,CAAC,uBAAuB,EAAE,CAAC,CAAC,CAAC;IACrF,IAAI,IAAI,CAAC,wBAAwB,GAAGA,iBAAY,CAAC,OAAO,CAAC,uBAAuB,EAAE,CAAC,CAAC,CAAC;IACrF,CAAC;AACD;IACA,MAAM,CAAC,gBAAgB,CAAC,sBAAsB,CAAC,SAAS,EAAE;IAC1D;IACA;IACA;IACA;IACA;IACA,IAAI,SAAS,EAAE;IACf,QAAQ,GAAG,EAAE,YAAY;IACzB,YAAY,OAAO,IAAI,CAAC,UAAU,CAAC;IACnC,SAAS;IACT,KAAK;AACL;IACA;IACA;IACA;IACA;IACA;IACA,IAAI,SAAS,EAAE;IACf,QAAQ,GAAG,EAAE,YAAY;IACzB,YAAY,OAAO,IAAI,CAAC,UAAU,CAAC;IACnC,SAAS;IACT,KAAK;AACL;IACA;IACA;IACA;IACA;IACA;IACA,IAAI,UAAU,EAAE;IAChB,QAAQ,GAAG,EAAE,YAAY;IACzB,YAAY,OAAO,IAAI,CAAC,WAAW,CAAC;IACpC,SAAS;IACT,KAAK;IACL,CAAC,CAAC,CAAC;AACH;IACA;IACA;IACA;IACA;IACA;IACA;IACA,sBAAsB,CAAC,SAAS,CAAC,wBAAwB,GAAG,UAAU,KAAK,EAAE;IAC7E,IAAI,OAAO,IAAI,CAAC,wBAAwB,IAAI,KAAK,CAAC;IAClD,CAAC,CAAC;AACF;IACA;IACA;IACA;IACA;IACA;IACA;IACA,sBAAsB,CAAC,SAAS,CAAC,wBAAwB,GAAG,UAAU,KAAK,EAAE;IAC7E,IAAI,OAAO,IAAI,CAAC,wBAAwB,IAAI,KAAK,CAAC;IAClD,CAAC,CAAC;AACF;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA,sBAAsB,CAAC,SAAS,CAAC,0BAA0B,GAAG,UAAU,SAAS,EAAE,MAAM,EAAE;IAC3F;IACA,IAAII,WAAK,CAAC,OAAO,CAAC,WAAW,EAAE,SAAS,CAAC,CAAC;IAC1C;AACA;IACA,IAAI,IAAI,IAAI,GAAGC,iBAAU,CAAC,SAAS,CAAC,SAAS,CAAC,IAAI,CAAC,CAAC;IACpD,IAAI,IAAI,KAAK,GAAGA,iBAAU,CAAC,SAAS,CAAC,SAAS,CAAC,KAAK,CAAC,CAAC;IACtD,IAAI,IAAI,IAAI,GAAGA,iBAAU,CAAC,SAAS,CAAC,SAAS,CAAC,IAAI,CAAC,CAAC;IACpD,IAAI,IAAI,KAAK,GAAGA,iBAAU,CAAC,SAAS,CAAC,SAAS,CAAC,KAAK,CAAC,CAAC;AACtD;IACA,IAAI,IAAI,CAACC,YAAO,CAAC,MAAM,CAAC,EAAE;IAC1B,QAAQ,OAAO,IAAIJ,oBAAS,CAAC,IAAI,EAAE,KAAK,EAAE,IAAI,EAAE,KAAK,CAAC,CAAC;IACvD,KAAK;AACL;IACA,IAAI,MAAM,CAAC,IAAI,GAAG,IAAI,CAAC;IACvB,IAAI,MAAM,CAAC,KAAK,GAAG,KAAK,CAAC;IACzB,IAAI,MAAM,CAAC,IAAI,GAAG,IAAI,CAAC;IACvB,IAAI,MAAM,CAAC,KAAK,GAAG,KAAK,CAAC;IACzB,IAAI,OAAO,MAAM,CAAC;IAClB,CAAC,CAAC;AACF;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA,sBAAsB,CAAC,SAAS,CAAC,uBAAuB,GAAG,UAAU,CAAC,EAAE,CAAC,EAAE,KAAK,EAAE,MAAM,EAAE;IAC1F,IAAI,IAAI,gBAAgB,GAAG,IAAI,CAAC,iBAAiB,CAAC,CAAC,EAAE,CAAC,EAAE,KAAK,EAAE,MAAM,CAAC,CAAC;IACvE,IAAI,gBAAgB,CAAC,IAAI,GAAGG,iBAAU,CAAC,SAAS,CAAC,gBAAgB,CAAC,IAAI,CAAC,CAAC;IACxE,IAAI,gBAAgB,CAAC,KAAK,GAAGA,iBAAU,CAAC,SAAS,CAAC,gBAAgB,CAAC,KAAK,CAAC,CAAC;IAC1E,IAAI,gBAAgB,CAAC,IAAI,GAAGA,iBAAU,CAAC,SAAS,CAAC,gBAAgB,CAAC,IAAI,CAAC,CAAC;IACxE,IAAI,gBAAgB,CAAC,KAAK,GAAGA,iBAAU,CAAC,SAAS,CAAC,gBAAgB,CAAC,KAAK,CAAC,CAAC;IAC1E,IAAI,OAAO,gBAAgB,CAAC;IAC5B,CAAC,CAAC;AACF;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA,sBAAsB,CAAC,SAAS,CAAC,iBAAiB,GAAG,UAAU,CAAC,EAAE,CAAC,EAAE,KAAK,EAAE,MAAM,EAAE;IACpF,IAAI,IAAI,SAAS,GAAG,IAAI,CAAC,UAAU,CAAC;AACpC;IACA,IAAI,IAAI,MAAM,GAAG,IAAI,CAAC,wBAAwB,CAAC,KAAK,CAAC,CAAC;IACtD,IAAI,IAAI,MAAM,GAAG,IAAI,CAAC,wBAAwB,CAAC,KAAK,CAAC,CAAC;AACtD;IACA,IAAI,IAAI,UAAU,GAAG,SAAS,CAAC,KAAK,GAAG,MAAM,CAAC;IAC9C,IAAI,IAAI,IAAI,GAAG,CAAC,GAAG,UAAU,GAAG,SAAS,CAAC,IAAI,CAAC;IAC/C,IAAI,IAAI,IAAI,GAAG,CAAC,CAAC,GAAG,CAAC,IAAI,UAAU,GAAG,SAAS,CAAC,IAAI,CAAC;AACrD;IACA,IAAI,IAAI,WAAW,GAAG,SAAS,CAAC,MAAM,GAAG,MAAM,CAAC;IAChD,IAAI,IAAI,KAAK,GAAG,SAAS,CAAC,KAAK,GAAG,CAAC,GAAG,WAAW,CAAC;IAClD,IAAI,IAAI,KAAK,GAAG,SAAS,CAAC,KAAK,GAAG,CAAC,CAAC,GAAG,CAAC,IAAI,WAAW,CAAC;AACxD;IACA,IAAI,IAAI,CAACC,YAAO,CAAC,MAAM,CAAC,EAAE;IAC1B,QAAQ,MAAM,GAAG,IAAIJ,oBAAS,CAAC,IAAI,EAAE,KAAK,EAAE,IAAI,EAAE,KAAK,CAAC,CAAC;IACzD,KAAK;AACL;IACA,IAAI,MAAM,CAAC,IAAI,GAAG,IAAI,CAAC;IACvB,IAAI,MAAM,CAAC,KAAK,GAAG,KAAK,CAAC;IACzB,IAAI,MAAM,CAAC,IAAI,GAAG,IAAI,CAAC;IACvB,IAAI,MAAM,CAAC,KAAK,GAAG,KAAK,CAAC;IACzB,IAAI,OAAO,MAAM,CAAC;IAClB,CAAC,CAAC;AACF;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA,sBAAsB,CAAC,SAAS,CAAC,gBAAgB,GAAG,UAAU,QAAQ,EAAE,KAAK,EAAE,MAAM,EAAE;IACvF,IAAI,IAAI,SAAS,GAAG,IAAI,CAAC,UAAU,CAAC;IACpC,IAAI,IAAI,CAACA,oBAAS,CAAC,QAAQ,CAAC,SAAS,EAAE,QAAQ,CAAC,EAAE;IAClD;IACA,QAAQ,OAAO,SAAS,CAAC;IACzB,KAAK;AACL;IACA,IAAI,IAAI,MAAM,GAAG,IAAI,CAAC,wBAAwB,CAAC,KAAK,CAAC,CAAC;IACtD,IAAI,IAAI,MAAM,GAAG,IAAI,CAAC,wBAAwB,CAAC,KAAK,CAAC,CAAC;AACtD;IACA,IAAI,IAAI,UAAU,GAAG,SAAS,CAAC,KAAK,GAAG,MAAM,CAAC;IAC9C,IAAI,IAAI,WAAW,GAAG,SAAS,CAAC,MAAM,GAAG,MAAM,CAAC;AAChD;IACA,IAAI,IAAI,SAAS,GAAG,QAAQ,CAAC,SAAS,CAAC;IACvC,IAAI,IAAI,SAAS,CAAC,IAAI,GAAG,SAAS,CAAC,IAAI,EAAE;IACzC,QAAQ,SAAS,IAAIG,iBAAU,CAAC,MAAM,CAAC;IACvC,KAAK;AACL;IACA,IAAI,IAAI,eAAe,GAAG,CAAC,CAAC,SAAS,GAAG,SAAS,CAAC,IAAI,IAAI,UAAU,IAAI,CAAC,CAAC;IAC1E,IAAI,IAAI,eAAe,IAAI,MAAM,EAAE;IACnC,QAAQ,eAAe,GAAG,MAAM,GAAG,CAAC,CAAC;IACrC,KAAK;AACL;IACA,IAAI,IAAI,eAAe,GAAG,CAAC,CAAC,SAAS,CAAC,KAAK,GAAG,QAAQ,CAAC,QAAQ,IAAI,WAAW,IAAI,CAAC,CAAC;IACpF,IAAI,IAAI,eAAe,IAAI,MAAM,EAAE;IACnC,QAAQ,eAAe,GAAG,MAAM,GAAG,CAAC,CAAC;IACrC,KAAK;AACL;IACA,IAAI,IAAI,CAACC,YAAO,CAAC,MAAM,CAAC,EAAE;IAC1B,QAAQ,OAAO,IAAIC,qBAAU,CAAC,eAAe,EAAE,eAAe,CAAC,CAAC;IAChE,KAAK;AACL;IACA,IAAI,MAAM,CAAC,CAAC,GAAG,eAAe,CAAC;IAC/B,IAAI,MAAM,CAAC,CAAC,GAAG,eAAe,CAAC;IAC/B,IAAI,OAAO,MAAM,CAAC;IAClB,CAAC;;ICnND,IAAI,0BAA0B,GAAG,IAAIC,qBAAU,EAAE,CAAC;IAClD,IAAI,0BAA0B,GAAG,IAAIA,qBAAU,EAAE,CAAC;IAClD,IAAI,2BAA2B,GAAG,IAAIC,uBAAY,EAAE,CAAC;IACrD,IAAI,sBAAsB,GAAG,IAAID,qBAAU,EAAE,CAAC;IAC9C,IAAI,uBAAuB,GAAG,IAAIA,qBAAU,EAAE,CAAC;AAC/C;IACA,IAAI,qBAAqB,GAAG,IAAIE,yBAAc,EAAE,CAAC;IACjD,IAAI,YAAY,GAAG,IAAI,sBAAsB,EAAE,CAAC;IAChD,IAAI,cAAc,GAAG,CAAC,IAAID,uBAAY,EAAE,EAAE,IAAIA,uBAAY,EAAE,EAAE,IAAIA,uBAAY,EAAE,EAAE,IAAIA,uBAAY,EAAE,CAAC,CAAC;IACtG,IAAI,aAAa,GAAG,IAAIF,qBAAU,EAAE,CAAC;AACrC;IACA;IACA;IACA;IACA;IACA,IAAI,yBAAyB,GAAG,EAAE,CAAC;AACnC;IACA;IACA;IACA;IACA;IACA,yBAAyB,CAAC,UAAU,GAAG,YAAY;IACnD,IAAI,IAAI,WAAW,GAAG,yBAAyB,CAAC,YAAY,CAAC;IAC7D,IAAI,IAAID,YAAO,CAAC,WAAW,CAAC,EAAE;IAC9B,QAAQ,OAAO,WAAW,CAAC;IAC3B,KAAK;AACL;IACA,IAAI,WAAW,GAAGK,mBAAQ,CAAC,SAAS,CAACC,yBAAc,CAAC,uCAAuC,CAAC,CAAC,CAAC,IAAI,CAAC,UAAU,IAAI,EAAE;IACnH,QAAQ,yBAAyB,CAAC,eAAe,GAAG,IAAI,CAAC;IACzD,KAAK,CAAC,CAAC;IACP,IAAI,yBAAyB,CAAC,YAAY,GAAG,WAAW,CAAC;AACzD;IACA,IAAI,OAAO,WAAW,CAAC;IACvB,CAAC,CAAC;AACF;IACA;IACA;IACA;IACA;IACA;IACA;IACA,yBAAyB,CAAC,wBAAwB,GAAG,UAAU,SAAS,EAAE,SAAS,EAAE;IACrF;IACA,IAAIR,WAAK,CAAC,OAAO,CAAC,WAAW,EAAE,SAAS,CAAC,CAAC;IAC1C,IAAI,IAAI,CAACE,YAAO,CAAC,yBAAyB,CAAC,eAAe,CAAC,EAAE;IAC7D,QAAQ,MAAM,IAAIO,oBAAc,CAAC,mHAAmH,CAAC,CAAC;IACtJ,KAAK;IACL;IACA,IAAI,SAAS,GAAGb,iBAAY,CAAC,SAAS,EAAEC,oBAAS,CAAC,KAAK,CAAC,CAAC;AACzD;IACA,IAAI,IAAI,OAAO,GAAG,cAAc,CAAC,SAAS,CAAC,CAAC;AAC5C;IACA;IACA,IAAI,IAAI,gBAAgB,GAAG,yBAAyB,CAAC,wBAAwB,CAAC;IAC9E,IAAI,IAAI,gBAAgB,GAAG,yBAAyB,CAAC,wBAAwB,CAAC;IAC9E,IAAI,IAAIK,YAAO,CAAC,OAAO,CAAC,EAAE;IAC1B,QAAQ,IAAI,GAAG,GAAG,OAAO,CAAC,KAAK,GAAG,GAAG,GAAG,OAAO,CAAC,CAAC,GAAG,GAAG,GAAG,OAAO,CAAC,CAAC,CAAC;IACpE,QAAQ,IAAI,OAAO,GAAG,yBAAyB,CAAC,eAAe,CAAC,GAAG,CAAC,CAAC;IACrE,QAAQ,IAAIA,YAAO,CAAC,OAAO,CAAC,EAAE;IAC9B,YAAY,gBAAgB,GAAG,OAAO,CAAC,CAAC,CAAC,CAAC;IAC1C,YAAY,gBAAgB,GAAG,OAAO,CAAC,CAAC,CAAC,CAAC;IAC1C,SAAS;AACT;IACA;IACA,QAAQ,SAAS,CAAC,uBAAuB,CAACJ,oBAAS,CAAC,SAAS,CAAC,SAAS,EAAE,2BAA2B,CAAC,EAAE,0BAA0B,CAAC,CAAC;IACnI,QAAQ,SAAS,CAAC,uBAAuB,CAACA,oBAAS,CAAC,SAAS,CAAC,SAAS,EAAE,2BAA2B,CAAC,EAAE,0BAA0B,CAAC,CAAC;AACnI;IACA,QAAQM,qBAAU,CAAC,QAAQ,CAAC,0BAA0B,EAAE,0BAA0B,EAAE,sBAAsB,CAAC,CAAC;IAC5G,QAAQ,IAAI,eAAe,GAAG,SAAS,CAAC,sBAAsB,CAAC,sBAAsB,EAAE,uBAAuB,CAAC,CAAC;IAChH,QAAQ,IAAIF,YAAO,CAAC,eAAe,CAAC,EAAE;IACtC,YAAY,IAAI,QAAQ,GAAGE,qBAAU,CAAC,QAAQ,CAAC,sBAAsB,EAAE,eAAe,CAAC,CAAC;IACxF,YAAY,gBAAgB,GAAG,IAAI,CAAC,GAAG,CAAC,gBAAgB,EAAE,CAAC,QAAQ,CAAC,CAAC;IACrE,SAAS,MAAM;IACf,YAAY,gBAAgB,GAAG,yBAAyB,CAAC,wBAAwB,CAAC;IAClF,SAAS;IACT,KAAK;AACL;IACA,IAAI,gBAAgB,GAAG,IAAI,CAAC,GAAG,CAAC,yBAAyB,CAAC,wBAAwB,EAAE,gBAAgB,CAAC,CAAC;AACtG;IACA,IAAI,OAAO;IACX,QAAQ,oBAAoB,EAAE,gBAAgB;IAC9C,QAAQ,oBAAoB,EAAE,gBAAgB;IAC9C,KAAK,CAAC;IACN,CAAC,CAAC;AACF;IACA;IACA;IACA;IACA;IACA;IACA;IACA,yBAAyB,CAAC,iBAAiB,GAAG,UAAU,SAAS,EAAE,SAAS,EAAE;IAC9E;IACA,IAAIJ,WAAK,CAAC,OAAO,CAAC,WAAW,EAAE,SAAS,CAAC,CAAC;IAC1C,IAAI,IAAI,CAACE,YAAO,CAAC,yBAAyB,CAAC,eAAe,CAAC,EAAE;IAC7D,QAAQ,MAAM,IAAIO,oBAAc,CAAC,mHAAmH,CAAC,CAAC;IACtJ,KAAK;IACL;IACA,IAAI,SAAS,GAAGb,iBAAY,CAAC,SAAS,EAAEC,oBAAS,CAAC,KAAK,CAAC,CAAC;AACzD;IACA,IAAI,IAAI,OAAO,GAAG,cAAc,CAAC,SAAS,CAAC,CAAC;AAC5C;IACA;IACA,IAAI,IAAI,gBAAgB,GAAG,yBAAyB,CAAC,wBAAwB,CAAC;IAC9E,IAAI,IAAIK,YAAO,CAAC,OAAO,CAAC,EAAE;IAC1B,QAAQ,IAAI,GAAG,GAAG,OAAO,CAAC,KAAK,GAAG,GAAG,GAAG,OAAO,CAAC,CAAC,GAAG,GAAG,GAAG,OAAO,CAAC,CAAC,CAAC;IACpE,QAAQ,IAAI,OAAO,GAAG,yBAAyB,CAAC,eAAe,CAAC,GAAG,CAAC,CAAC;IACrE,QAAQ,IAAIA,YAAO,CAAC,OAAO,CAAC,EAAE;IAC9B,YAAY,gBAAgB,GAAG,OAAO,CAAC,CAAC,CAAC,CAAC;IAC1C,SAAS;IACT,KAAK;AACL;IACA,IAAI,IAAI,MAAM,GAAGI,yBAAc,CAAC,eAAe,CAAC,SAAS,EAAE,SAAS,EAAE,GAAG,CAAC,CAAC;IAC3E,IAAIA,yBAAc,CAAC,eAAe,CAAC,SAAS,EAAE,SAAS,EAAE,gBAAgB,EAAE,qBAAqB,CAAC,CAAC;AAClG;IACA,IAAI,OAAOA,yBAAc,CAAC,KAAK,CAAC,MAAM,EAAE,qBAAqB,EAAE,MAAM,CAAC,CAAC;IACvE,CAAC,CAAC;AACF;IACA,SAAS,cAAc,CAAC,SAAS,EAAE;IACnC,IAAID,uBAAY,CAAC,WAAW,CAAC,SAAS,CAAC,IAAI,EAAE,SAAS,CAAC,KAAK,EAAE,GAAG,EAAE,cAAc,CAAC,CAAC,CAAC,CAAC,CAAC;IACtF,IAAIA,uBAAY,CAAC,WAAW,CAAC,SAAS,CAAC,IAAI,EAAE,SAAS,CAAC,KAAK,EAAE,GAAG,EAAE,cAAc,CAAC,CAAC,CAAC,CAAC,CAAC;IACtF,IAAIA,uBAAY,CAAC,WAAW,CAAC,SAAS,CAAC,IAAI,EAAE,SAAS,CAAC,KAAK,EAAE,GAAG,EAAE,cAAc,CAAC,CAAC,CAAC,CAAC,CAAC;IACtF,IAAIA,uBAAY,CAAC,WAAW,CAAC,SAAS,CAAC,IAAI,EAAE,SAAS,CAAC,KAAK,EAAE,GAAG,EAAE,cAAc,CAAC,CAAC,CAAC,CAAC,CAAC;AACtF;IACA;IACA,IAAI,IAAI,UAAU,GAAG,CAAC;IACtB,QAAQ,UAAU,GAAG,CAAC,CAAC;IACvB,IAAI,IAAI,QAAQ,GAAG,CAAC;IACpB,QAAQ,QAAQ,GAAG,CAAC,CAAC;IACrB,IAAI,IAAI,QAAQ,GAAG,yBAAyB,CAAC,uBAAuB,CAAC;IACrE,IAAI,IAAI,CAAC,CAAC;IACV,IAAI,KAAK,CAAC,GAAG,CAAC,EAAE,CAAC,IAAI,QAAQ,EAAE,EAAE,CAAC,EAAE;IACpC,QAAQ,IAAI,MAAM,GAAG,KAAK,CAAC;IAC3B,QAAQ,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,CAAC,EAAE,EAAE,CAAC,EAAE;IACpC,YAAY,IAAI,MAAM,GAAG,cAAc,CAAC,CAAC,CAAC,CAAC;IAC3C,YAAY,YAAY,CAAC,gBAAgB,CAAC,MAAM,EAAE,CAAC,EAAE,aAAa,CAAC,CAAC;IACpE,YAAY,IAAI,CAAC,KAAK,CAAC,EAAE;IACzB,gBAAgB,QAAQ,GAAG,aAAa,CAAC,CAAC,CAAC;IAC3C,gBAAgB,QAAQ,GAAG,aAAa,CAAC,CAAC,CAAC;IAC3C,aAAa,MAAM,IAAI,QAAQ,KAAK,aAAa,CAAC,CAAC,IAAI,QAAQ,KAAK,aAAa,CAAC,CAAC,EAAE;IACrF,gBAAgB,MAAM,GAAG,IAAI,CAAC;IAC9B,gBAAgB,MAAM;IACtB,aAAa;IACb,SAAS;AACT;IACA,QAAQ,IAAI,MAAM,EAAE;IACpB,YAAY,MAAM;IAClB,SAAS;AACT;IACA,QAAQ,UAAU,GAAG,QAAQ,CAAC;IAC9B,QAAQ,UAAU,GAAG,QAAQ,CAAC;IAC9B,KAAK;AACL;IACA,IAAI,IAAI,CAAC,KAAK,CAAC,EAAE;IACjB,QAAQ,OAAO,SAAS,CAAC;IACzB,KAAK;AACL;IACA,IAAI,OAAO;IACX,QAAQ,CAAC,EAAE,UAAU;IACrB,QAAQ,CAAC,EAAE,UAAU;IACrB,QAAQ,KAAK,EAAE,CAAC,GAAG,QAAQ,GAAG,QAAQ,GAAG,CAAC,GAAG,CAAC;IAC9C,KAAK,CAAC;IACN,CAAC;AACD;IACA,yBAAyB,CAAC,uBAAuB,GAAG,CAAC,CAAC;IACtD,yBAAyB,CAAC,wBAAwB,GAAG,MAAM,CAAC;IAC5D,yBAAyB,CAAC,wBAAwB,GAAG,CAAC,QAAQ,CAAC;IAC/D,yBAAyB,CAAC,eAAe,GAAG,SAAS,CAAC;IACtD,yBAAyB,CAAC,YAAY,GAAG,SAAS,CAAC;AACnD;IACA,MAAM,CAAC,gBAAgB,CAAC,yBAAyB,EAAE;IACnD;IACA;IACA;IACA;IACA;IACA;IACA;IACA,IAAI,WAAW,EAAE;IACjB,QAAQ,GAAG,EAAE,YAAY;IACzB,YAAY,OAAOH,YAAO,CAAC,yBAAyB,CAAC,eAAe,CAAC,CAAC;IACtE,SAAS;IACT,KAAK;IACL,CAAC,CAAC;;IC3KF,IAAI,WAAW,GAAG,CAACH,+BAAoB,EAAEW,2CAAqB,CAAC,CAAC;IAChE,IAAI,gBAAgB,GAAG,WAAW,CAAC,MAAM,CAAC;AAC1C;IACA,IAAI,iBAAiB,GAAG,IAAI,CAAC,GAAG,CAACT,iBAAU,CAAC,SAAS,CAAC,IAAI,CAAC,CAAC,CAAC;IAC7D,IAAI,iBAAiB,GAAG,IAAI,CAAC,GAAG,CAACA,iBAAU,CAAC,SAAS,CAAC,KAAK,CAAC,CAAC,CAAC;AAC9D;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA,IAAI,uBAAuB,GAAG,GAAG,CAAC;IAClC,IAAI,uBAAuB,GAAG,MAAM,CAAC;AACrC;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA,SAAS,sBAAsB,CAAC,OAAO,EAAE;IACzC,IAAI,OAAO,GAAGL,iBAAY,CAAC,OAAO,EAAEA,iBAAY,CAAC,YAAY,CAAC,CAAC;IAC/D,IAAI,IAAI,SAAS,GAAG,OAAO,CAAC,SAAS,CAAC;AACtC;IACA;IACA,IAAI,IAAI,CAACM,YAAO,CAAC,SAAS,CAAC,IAAI,SAAS,CAAC,MAAM,GAAG,CAAC,EAAE;IACrD,QAAQ,MAAM,IAAIO,oBAAc,CAAC,sCAAsC,CAAC,CAAC;IACzE,KAAK;IACL,IAAI,IAAIP,YAAO,CAAC,OAAO,CAAC,OAAO,CAAC,IAAI,OAAO,CAAC,OAAO,KAAKS,eAAO,CAAC,QAAQ,IAAI,OAAO,CAAC,OAAO,KAAKA,eAAO,CAAC,KAAK,EAAE;IAC/G,QAAQ,MAAM,IAAIF,oBAAc,CAAC,mEAAmE,CAAC,CAAC;IACtG,KAAK;IACL;AACA;IACA;IACA;IACA;IACA;IACA,IAAI,IAAI,CAAC,KAAK,GAAGb,iBAAY,CAAC,OAAO,CAAC,KAAK,EAAE,GAAG,CAAC,CAAC;AAClD;IACA,IAAI,IAAI,CAAC,UAAU,GAAG,SAAS,CAAC;AAChC;IACA;IACA;IACA;IACA;IACA;IACA;IACA,IAAI,IAAI,CAAC,WAAW,GAAGA,iBAAY,CAAC,OAAO,CAAC,WAAW,EAAE,MAAM,CAAC,CAAC;AACjE;IACA;IACA;IACA;IACA;IACA;IACA;IACA,IAAI,IAAI,CAAC,IAAI,GAAGA,iBAAY,CAAC,OAAO,CAAC,IAAI,EAAE,KAAK,CAAC,CAAC;AAClD;IACA;IACA;IACA;IACA;IACA;IACA,IAAI,IAAI,CAAC,OAAO,GAAGA,iBAAY,CAAC,OAAO,CAAC,OAAO,EAAEe,eAAO,CAAC,QAAQ,CAAC,CAAC;AACnE;IACA,IAAI,IAAI,CAAC,UAAU,GAAGd,oBAAS,CAAC,KAAK,CAAC;AACtC;IACA;IACA,IAAI,IAAI,CAAC,gBAAgB,GAAG,CAAC,CAAC;IAC9B,IAAI,IAAI,CAAC,WAAW,GAAG,8BAA8B,CAAC;AACtD;IACA;IACA,IAAI,IAAI,CAAC,YAAY,GAAG,KAAK,CAAC;IAC9B,CAAC;AACD;IACA,MAAM,CAAC,gBAAgB,CAAC,sBAAsB,CAAC,SAAS,EAAE;IAC1D;IACA;IACA;IACA;IACA;IACA;IACA;IACA,IAAI,YAAY,EAAE;IAClB,QAAQ,GAAG,EAAE,YAAY;IACzB,YAAY,OAAO,GAAG,GAAG,IAAI,CAAC,UAAU,CAAC,MAAM,GAAG,CAAC,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAGA,oBAAS,CAAC,YAAY,GAAG,GAAG,GAAG,GAAG,CAAC;IAC3G,SAAS;IACT,KAAK;IACL,CAAC,CAAC,CAAC;AACH;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA,sBAAsB,CAAC,yBAAyB,GAAG,UAAU,sBAAsB,EAAE,aAAa,EAAE;IACpG,IAAI,IAAI,eAAe,GAAG,CAAC,CAAC;IAC5B,IAAI,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,gBAAgB,EAAE,CAAC,EAAE,EAAE;IAC/C,QAAQ,IAAI,aAAa,YAAY,WAAW,CAAC,CAAC,CAAC,EAAE;IACrD,YAAY,eAAe,GAAG,CAAC,CAAC;IAChC,YAAY,MAAM;IAClB,SAAS;IACT,KAAK;AACL;IACA,IAAI,sBAAsB,CAAC,gBAAgB,GAAG,eAAe,CAAC;IAC9D,IAAI,sBAAsB,CAAC,UAAU,GAAG,aAAa,CAAC,SAAS,CAAC;IAChE,CAAC,CAAC;AACF;IACA,IAAI,aAAa,GAAG,IAAIO,qBAAU,EAAE,CAAC;IACrC,IAAI,aAAa,GAAG,IAAIA,qBAAU,EAAE,CAAC;IACrC,IAAI,aAAa,GAAG,IAAIA,qBAAU,EAAE,CAAC;IACrC,SAAS,kBAAkB,CAAC,KAAK,EAAE,GAAG,EAAE,SAAS,EAAE,SAAS,EAAE,MAAM,EAAE;IACtE,IAAI,IAAI,WAAW,GAAG,WAAW,CAAC,SAAS,EAAE,KAAK,EAAE,GAAG,EAAE,aAAa,CAAC,CAAC;IACxE,IAAI,IAAI,QAAQ,GAAG,WAAW,CAAC,SAAS,EAAE,KAAK,EAAE,SAAS,EAAE,aAAa,CAAC,CAAC;IAC3E,IAAI,IAAI,SAAS,GAAG,WAAW,CAAC,SAAS,EAAE,GAAG,EAAE,GAAG,EAAE,aAAa,CAAC,CAAC;AACpE;IACA,IAAI,IAAI,EAAE,GAAG,SAAS,CAAC,QAAQ,EAAE,WAAW,EAAE,aAAa,CAAC,CAAC;IAC7D,IAAI,IAAI,OAAO,GAAG,SAAS,CAAC,SAAS,EAAE,WAAW,EAAE,aAAa,CAAC,CAAC;AACnE;IACA,IAAIA,qBAAU,CAAC,KAAK,CAAC,OAAO,EAAE,EAAE,EAAE,MAAM,CAAC,CAAC;IAC1C,IAAI,OAAOA,qBAAU,CAAC,SAAS,CAAC,MAAM,EAAE,MAAM,CAAC,CAAC;IAChD,CAAC;AACD;IACA,IAAI,+BAA+B,GAAG,IAAIC,uBAAY,EAAE,CAAC;IACzD,IAAI,yBAAyB,GAAG,IAAID,qBAAU,EAAE,CAAC;IACjD,IAAI,sBAAsB,GAAG,IAAIA,qBAAU,EAAE,CAAC;IAC9C,IAAI,yBAAyB,GAAG,IAAIA,qBAAU,EAAE,CAAC;IACjD,SAAS,kBAAkB,CAAC,KAAK,EAAE,GAAG,EAAE,SAAS,EAAE,SAAS,EAAE,WAAW,EAAE,OAAO,EAAE,SAAS,EAAE,YAAY,EAAE,oBAAoB,EAAE,iBAAiB,EAAE,kBAAkB,EAAE;IAC1K,IAAI,IAAI,WAAW,KAAK,GAAG,EAAE;IAC7B,QAAQ,OAAO;IACf,KAAK;AACL;IACA,IAAI,IAAI,aAAa,CAAC;IACtB,IAAI,IAAI,OAAO,KAAKO,eAAO,CAAC,QAAQ,EAAE;IACtC,QAAQ,aAAa,GAAG,IAAIC,mCAAiB,CAAC,KAAK,EAAE,GAAG,EAAE,SAAS,CAAC,CAAC;IACrE,KAAK,MAAM,IAAI,OAAO,KAAKD,eAAO,CAAC,KAAK,EAAE;IAC1C,QAAQ,aAAa,GAAG,IAAIE,qCAAkB,CAAC,KAAK,EAAE,GAAG,EAAE,SAAS,CAAC,CAAC;IACtE,KAAK;AACL;IACA,IAAI,IAAI,eAAe,GAAG,aAAa,CAAC,eAAe,CAAC;IACxD,IAAI,IAAI,eAAe,GAAG,WAAW,EAAE;IACvC,QAAQ,OAAO;IACf,KAAK;AACL;IACA;IACA,IAAI,IAAI,kBAAkB,GAAG,kBAAkB,CAAC,KAAK,EAAE,GAAG,EAAE,SAAS,EAAE,SAAS,EAAE,yBAAyB,CAAC,CAAC;AAC7G;IACA,IAAI,IAAI,QAAQ,GAAG,IAAI,CAAC,IAAI,CAAC,eAAe,GAAG,WAAW,CAAC,CAAC;IAC5D,IAAI,IAAI,kBAAkB,GAAG,eAAe,GAAG,QAAQ,CAAC;IACxD,IAAI,IAAI,iBAAiB,GAAG,kBAAkB,CAAC;IAC/C,IAAI,IAAI,WAAW,GAAG,QAAQ,GAAG,CAAC,CAAC;IACnC,IAAI,IAAI,SAAS,GAAG,YAAY,CAAC,MAAM,CAAC;IACxC,IAAI,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,WAAW,EAAE,CAAC,EAAE,EAAE;IAC1C,QAAQ,IAAI,wBAAwB,GAAG,aAAa,CAAC,+BAA+B,CAAC,iBAAiB,EAAE,+BAA+B,CAAC,CAAC;IACzI,QAAQ,IAAI,kBAAkB,GAAG,WAAW,CAAC,SAAS,EAAE,wBAAwB,EAAE,SAAS,EAAE,yBAAyB,CAAC,CAAC;IACxH,QAAQ,IAAI,eAAe,GAAG,WAAW,CAAC,SAAS,EAAE,wBAAwB,EAAE,SAAS,EAAE,sBAAsB,CAAC,CAAC;AAClH;IACA,QAAQT,qBAAU,CAAC,IAAI,CAAC,kBAAkB,EAAE,YAAY,EAAE,SAAS,CAAC,CAAC;IACrE,QAAQA,qBAAU,CAAC,IAAI,CAAC,kBAAkB,EAAE,oBAAoB,EAAE,SAAS,CAAC,CAAC;IAC7E,QAAQA,qBAAU,CAAC,IAAI,CAAC,eAAe,EAAE,iBAAiB,EAAE,SAAS,CAAC,CAAC;IACvE,QAAQ,kBAAkB,CAAC,IAAI,CAAC,wBAAwB,CAAC,QAAQ,CAAC,CAAC;IACnE,QAAQ,kBAAkB,CAAC,IAAI,CAAC,wBAAwB,CAAC,SAAS,CAAC,CAAC;AACpE;IACA,QAAQ,SAAS,IAAI,CAAC,CAAC;IACvB,QAAQ,iBAAiB,IAAI,kBAAkB,CAAC;IAChD,KAAK;IACL,CAAC;AACD;IACA,IAAI,6BAA6B,GAAG,IAAIC,uBAAY,EAAE,CAAC;IACvD,SAAS,WAAW,CAAC,SAAS,EAAE,YAAY,EAAE,MAAM,EAAE,MAAM,EAAE;IAC9D,IAAIA,uBAAY,CAAC,KAAK,CAAC,YAAY,EAAE,6BAA6B,CAAC,CAAC;IACpE,IAAI,6BAA6B,CAAC,MAAM,GAAG,MAAM,CAAC;IAClD,IAAI,OAAOA,uBAAY,CAAC,WAAW,CAAC,6BAA6B,EAAE,SAAS,EAAE,MAAM,CAAC,CAAC;IACtF,CAAC;AACD;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA,sBAAsB,CAAC,IAAI,GAAG,UAAU,KAAK,EAAE,KAAK,EAAE,aAAa,EAAE;IACrE;IACA,IAAIL,WAAK,CAAC,MAAM,CAAC,MAAM,CAAC,OAAO,EAAE,KAAK,CAAC,CAAC;IACxC,IAAIA,WAAK,CAAC,OAAO,CAAC,OAAO,EAAE,KAAK,CAAC,CAAC;IAClC;AACA;IACA,IAAI,IAAI,KAAK,GAAGJ,iBAAY,CAAC,aAAa,EAAE,CAAC,CAAC,CAAC;AAC/C;IACA,IAAI,IAAI,SAAS,GAAG,KAAK,CAAC,UAAU,CAAC;IACrC,IAAI,IAAI,eAAe,GAAG,SAAS,CAAC,MAAM,CAAC;AAC3C;IACA,IAAI,KAAK,CAAC,KAAK,EAAE,CAAC,GAAG,eAAe,CAAC;AACrC;IACA,IAAI,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,eAAe,EAAE,EAAE,CAAC,EAAE;IAC9C,QAAQ,IAAI,SAAS,GAAG,SAAS,CAAC,CAAC,CAAC,CAAC;IACrC,QAAQQ,qBAAU,CAAC,IAAI,CAAC,SAAS,EAAE,KAAK,EAAE,KAAK,CAAC,CAAC;IACjD,QAAQ,KAAK,IAAI,CAAC,CAAC;IACnB,KAAK;AACL;IACA,IAAI,KAAK,CAAC,KAAK,EAAE,CAAC,GAAG,KAAK,CAAC,WAAW,CAAC;IACvC,IAAI,KAAK,CAAC,KAAK,EAAE,CAAC,GAAG,KAAK,CAAC,IAAI,GAAG,GAAG,GAAG,GAAG,CAAC;IAC5C,IAAI,KAAK,CAAC,KAAK,EAAE,CAAC,GAAG,KAAK,CAAC,OAAO,CAAC;AACnC;IACA,IAAIP,oBAAS,CAAC,IAAI,CAAC,KAAK,CAAC,UAAU,EAAE,KAAK,EAAE,KAAK,CAAC,CAAC;IACnD,IAAI,KAAK,IAAIA,oBAAS,CAAC,YAAY,CAAC;AACpC;IACA,IAAI,KAAK,CAAC,KAAK,EAAE,CAAC,GAAG,KAAK,CAAC,gBAAgB,CAAC;IAC5C,IAAI,KAAK,CAAC,KAAK,EAAE,CAAC,GAAG,KAAK,CAAC,YAAY,GAAG,GAAG,GAAG,GAAG,CAAC;AACpD;IACA,IAAI,OAAO,KAAK,CAAC;IACjB,CAAC,CAAC;AACF;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA,sBAAsB,CAAC,MAAM,GAAG,UAAU,KAAK,EAAE,aAAa,EAAE,MAAM,EAAE;IACxE;IACA,IAAIG,WAAK,CAAC,OAAO,CAAC,OAAO,EAAE,KAAK,CAAC,CAAC;IAClC;AACA;IACA,IAAI,IAAI,KAAK,GAAGJ,iBAAY,CAAC,aAAa,EAAE,CAAC,CAAC,CAAC;IAC/C,IAAI,IAAI,eAAe,GAAG,KAAK,CAAC,KAAK,EAAE,CAAC,CAAC;IACzC,IAAI,IAAI,SAAS,GAAG,IAAI,KAAK,CAAC,eAAe,CAAC,CAAC;AAC/C;IACA,IAAI,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,eAAe,EAAE,CAAC,EAAE,EAAE;IAC9C,QAAQ,SAAS,CAAC,CAAC,CAAC,GAAGQ,qBAAU,CAAC,MAAM,CAAC,KAAK,EAAE,KAAK,CAAC,CAAC;IACvD,QAAQ,KAAK,IAAI,CAAC,CAAC;IACnB,KAAK;AACL;IACA,IAAI,IAAI,WAAW,GAAG,KAAK,CAAC,KAAK,EAAE,CAAC,CAAC;IACrC,IAAI,IAAI,IAAI,GAAG,KAAK,CAAC,KAAK,EAAE,CAAC,KAAK,GAAG,CAAC;IACtC,IAAI,IAAI,OAAO,GAAG,KAAK,CAAC,KAAK,EAAE,CAAC,CAAC;AACjC;IACA,IAAI,IAAI,SAAS,GAAGP,oBAAS,CAAC,MAAM,CAAC,KAAK,EAAE,KAAK,CAAC,CAAC;IACnD,IAAI,KAAK,IAAIA,oBAAS,CAAC,YAAY,CAAC;AACpC;IACA,IAAI,IAAI,eAAe,GAAG,KAAK,CAAC,KAAK,EAAE,CAAC,CAAC;IACzC,IAAI,IAAI,WAAW,GAAG,KAAK,CAAC,KAAK,EAAE,CAAC,KAAK,GAAG,CAAC;AAC7C;IACA,IAAI,IAAI,CAACK,YAAO,CAAC,MAAM,CAAC,EAAE;IAC1B,QAAQ,MAAM,GAAG,IAAI,sBAAsB,CAAC;IAC5C,YAAY,SAAS,EAAE,SAAS;IAChC,SAAS,CAAC,CAAC;IACX,KAAK;AACL;IACA,IAAI,MAAM,CAAC,UAAU,GAAG,SAAS,CAAC;IAClC,IAAI,MAAM,CAAC,WAAW,GAAG,WAAW,CAAC;IACrC,IAAI,MAAM,CAAC,IAAI,GAAG,IAAI,CAAC;IACvB,IAAI,MAAM,CAAC,OAAO,GAAG,OAAO,CAAC;IAC7B,IAAI,MAAM,CAAC,UAAU,GAAG,SAAS,CAAC;IAClC,IAAI,MAAM,CAAC,gBAAgB,GAAG,eAAe,CAAC;IAC9C,IAAI,MAAM,CAAC,YAAY,GAAG,WAAW,CAAC;AACtC;IACA,IAAI,OAAO,MAAM,CAAC;IAClB,CAAC,CAAC;AACF;IACA,SAAS,SAAS,CAAC,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE;IAC3C,IAAIE,qBAAU,CAAC,QAAQ,CAAC,MAAM,EAAE,MAAM,EAAE,MAAM,CAAC,CAAC;IAChD,IAAIA,qBAAU,CAAC,SAAS,CAAC,MAAM,EAAE,MAAM,CAAC,CAAC;IACzC,IAAI,OAAO,MAAM,CAAC;IAClB,CAAC;AACD;IACA,SAAS,gBAAgB,CAAC,MAAM,EAAE,MAAM,EAAE,EAAE,EAAE,MAAM,EAAE;IACtD,IAAI,MAAM,GAAG,SAAS,CAAC,MAAM,EAAE,MAAM,EAAE,MAAM,CAAC,CAAC;AAC/C;IACA;IACA,IAAI,MAAM,GAAGA,qBAAU,CAAC,KAAK,CAAC,MAAM,EAAE,EAAE,EAAE,MAAM,CAAC,CAAC;IAClD,IAAI,MAAM,GAAGA,qBAAU,CAAC,SAAS,CAAC,MAAM,EAAE,MAAM,CAAC,CAAC;IAClD,IAAI,MAAM,GAAGA,qBAAU,CAAC,KAAK,CAAC,EAAE,EAAE,MAAM,EAAE,MAAM,CAAC,CAAC;IAClD,IAAI,OAAO,MAAM,CAAC;IAClB,CAAC;AACD;IACA,IAAI,iBAAiB,GAAG,IAAIA,qBAAU,EAAE,CAAC;IACzC,IAAI,aAAa,GAAG,IAAIA,qBAAU,EAAE,CAAC;IACrC,IAAI,cAAc,GAAG,IAAIA,qBAAU,EAAE,CAAC;IACtC,IAAI,eAAe,GAAG,IAAIA,qBAAU,EAAE,CAAC;IACvC,IAAI,QAAQ,GAAG,GAAG,CAAC;IACnB,IAAI,SAAS,GAAG,CAAC,GAAG,CAAC;IACrB,SAAS,wBAAwB,CAAC,cAAc,EAAE,YAAY,EAAE,SAAS,EAAE,UAAU,EAAE,MAAM,EAAE;IAC/F,IAAI,IAAI,EAAE,GAAG,SAAS,CAAC,SAAS,EAAE,YAAY,EAAE,eAAe,CAAC,CAAC;AACjE;IACA;IACA,IAAI,IAAI,UAAU,GAAG,gBAAgB,CAAC,cAAc,EAAE,YAAY,EAAE,EAAE,EAAE,iBAAiB,CAAC,CAAC;IAC3F,IAAI,IAAI,MAAM,GAAG,gBAAgB,CAAC,UAAU,EAAE,YAAY,EAAE,EAAE,EAAE,aAAa,CAAC,CAAC;AAC/E;IACA;IACA,IAAI,IAAIH,iBAAU,CAAC,aAAa,CAACG,qBAAU,CAAC,GAAG,CAAC,UAAU,EAAE,MAAM,CAAC,EAAE,SAAS,EAAEH,iBAAU,CAAC,QAAQ,CAAC,EAAE;IACtG,QAAQ,MAAM,GAAGG,qBAAU,CAAC,KAAK,CAAC,EAAE,EAAE,UAAU,EAAE,MAAM,CAAC,CAAC;IAC1D,QAAQ,MAAM,GAAGA,qBAAU,CAAC,SAAS,CAAC,MAAM,EAAE,MAAM,CAAC,CAAC;IACtD,QAAQ,OAAO,MAAM,CAAC;IACtB,KAAK;AACL;IACA;IACA,IAAI,MAAM,GAAGA,qBAAU,CAAC,GAAG,CAAC,MAAM,EAAE,UAAU,EAAE,MAAM,CAAC,CAAC;IACxD,IAAI,MAAM,GAAGA,qBAAU,CAAC,SAAS,CAAC,MAAM,EAAE,MAAM,CAAC,CAAC;AAClD;IACA;IACA,IAAI,IAAI,OAAO,GAAGA,qBAAU,CAAC,KAAK,CAAC,EAAE,EAAE,MAAM,EAAE,cAAc,CAAC,CAAC;IAC/D,IAAI,IAAIA,qBAAU,CAAC,GAAG,CAAC,MAAM,EAAE,OAAO,CAAC,GAAG,QAAQ,EAAE;IACpD,QAAQ,MAAM,GAAGA,qBAAU,CAAC,MAAM,CAAC,MAAM,EAAE,MAAM,CAAC,CAAC;IACnD,KAAK;AACL;IACA,IAAI,OAAO,MAAM,CAAC;IAClB,CAAC;AACD;IACA,IAAI,QAAQ,GAAGU,WAAK,CAAC,eAAe,CAACV,qBAAU,CAAC,IAAI,EAAEA,qBAAU,CAAC,MAAM,CAAC,CAAC;AACzE;IACA,IAAI,qBAAqB,GAAG,IAAIA,qBAAU,EAAE,CAAC;IAC7C,IAAI,mBAAmB,GAAG,IAAIA,qBAAU,EAAE,CAAC;IAC3C,IAAI,gBAAgB,GAAG,IAAIA,qBAAU,EAAE,CAAC;IACxC,IAAI,iBAAiB,GAAG,IAAIA,qBAAU,EAAE,CAAC;IACzC,IAAI,mBAAmB,GAAG,IAAIA,qBAAU,EAAE,CAAC;IAC3C,IAAI,mBAAmB,GAAG,IAAIA,qBAAU,EAAE,CAAC;IAC3C,IAAI,oBAAoB,GAAG,IAAIC,uBAAY,EAAE,CAAC;IAC9C,IAAI,oBAAoB,GAAG,IAAIA,uBAAY,EAAE,CAAC;IAC9C,IAAI,+BAA+B,GAAG,IAAIA,uBAAY,EAAE,CAAC;IACzD;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA,sBAAsB,CAAC,cAAc,GAAG,UAAU,sBAAsB,EAAE;IAC1E,IAAI,IAAI,mBAAmB,GAAG,CAAC,sBAAsB,CAAC,YAAY,CAAC;IACnE,IAAI,IAAI,IAAI,GAAG,sBAAsB,CAAC,IAAI,CAAC;IAC3C,IAAI,IAAI,SAAS,GAAG,sBAAsB,CAAC,UAAU,CAAC;IACtD,IAAI,IAAI,WAAW,GAAG,sBAAsB,CAAC,WAAW,CAAC;IACzD,IAAI,IAAI,OAAO,GAAG,sBAAsB,CAAC,OAAO,CAAC;IACjD,IAAI,IAAI,UAAU,GAAG,IAAI,WAAW,CAAC,sBAAsB,CAAC,gBAAgB,CAAC,CAAC,SAAS,CAAC,CAAC;AACzF;IACA,IAAI,IAAI,SAAS,GAAG,uBAAuB,CAAC;IAC5C,IAAI,IAAI,SAAS,GAAG,uBAAuB,CAAC;AAC5C;IACA,IAAI,IAAI,KAAK,CAAC;IACd,IAAI,IAAI,CAAC,CAAC;AACV;IACA,IAAI,IAAI,SAAS,GAAG,sBAAsB,CAAC,UAAU,CAAC;IACtD,IAAI,IAAI,eAAe,GAAG,SAAS,CAAC,MAAM,CAAC;AAC3C;IACA,IAAI,IAAI,eAAe,KAAK,CAAC,EAAE;IAC/B,QAAQ,IAAI,GAAG,KAAK,CAAC;IACrB,KAAK;AACL;IACA;IACA;IACA;IACA,IAAI,IAAI,EAAE,CAAC;IACX,IAAI,IAAI,EAAE,CAAC;IACX,IAAI,IAAI,EAAE,CAAC;IACX,IAAI,IAAI,EAAE,CAAC;IACX,IAAI,IAAI,SAAS,GAAG,IAAIQ,qCAAkB,CAAC,SAAS,EAAE,SAAS,EAAE,SAAS,CAAC,CAAC;IAC5E,IAAI,IAAI,YAAY,CAAC;IACrB,IAAI,IAAI,wBAAwB,CAAC;IACjC,IAAI,IAAI,qBAAqB,CAAC;IAC9B,IAAI,IAAI,cAAc,GAAG,CAAC,SAAS,CAAC,CAAC,CAAC,CAAC,CAAC;IACxC,IAAI,KAAK,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,eAAe,GAAG,CAAC,EAAE,CAAC,EAAE,EAAE;IAC9C,QAAQ,EAAE,GAAG,SAAS,CAAC,CAAC,CAAC,CAAC;IAC1B,QAAQ,EAAE,GAAG,SAAS,CAAC,CAAC,GAAG,CAAC,CAAC,CAAC;IAC9B,QAAQ,YAAY,GAAGE,mCAAiB,CAAC,gBAAgB,CAAC,EAAE,EAAE,EAAE,EAAE,QAAQ,EAAE,mBAAmB,CAAC,CAAC;IACjG,QAAQ,IAAIb,YAAO,CAAC,YAAY,CAAC,IAAI,CAACE,qBAAU,CAAC,aAAa,CAAC,YAAY,EAAE,EAAE,EAAEH,iBAAU,CAAC,QAAQ,CAAC,IAAI,CAACG,qBAAU,CAAC,aAAa,CAAC,YAAY,EAAE,EAAE,EAAEH,iBAAU,CAAC,QAAQ,CAAC,EAAE;IAC3K,YAAY,IAAI,sBAAsB,CAAC,OAAO,KAAKU,eAAO,CAAC,QAAQ,EAAE;IACrE,gBAAgB,cAAc,CAAC,IAAI,CAACP,qBAAU,CAAC,KAAK,CAAC,YAAY,CAAC,CAAC,CAAC;IACpE,aAAa,MAAM,IAAI,sBAAsB,CAAC,OAAO,KAAKO,eAAO,CAAC,KAAK,EAAE;IACzE,gBAAgB,qBAAqB,GAAG,SAAS,CAAC,uBAAuB,CAAC,YAAY,EAAE,oBAAoB,CAAC,CAAC,SAAS,CAAC;IACxH,gBAAgB,EAAE,GAAG,SAAS,CAAC,uBAAuB,CAAC,EAAE,EAAE,oBAAoB,CAAC,CAAC;IACjF,gBAAgB,EAAE,GAAG,SAAS,CAAC,uBAAuB,CAAC,EAAE,EAAE,oBAAoB,CAAC,CAAC;IACjF,gBAAgB,SAAS,CAAC,YAAY,CAAC,EAAE,EAAE,EAAE,CAAC,CAAC;IAC/C,gBAAgB,wBAAwB,GAAG,SAAS,CAAC,6BAA6B,CAAC,qBAAqB,EAAE,+BAA+B,CAAC,CAAC;IAC3I,gBAAgB,YAAY,GAAG,SAAS,CAAC,uBAAuB,CAAC,wBAAwB,EAAE,mBAAmB,CAAC,CAAC;IAChH,gBAAgB,IAAIT,YAAO,CAAC,YAAY,CAAC,IAAI,CAACE,qBAAU,CAAC,aAAa,CAAC,YAAY,EAAE,EAAE,EAAEH,iBAAU,CAAC,QAAQ,CAAC,IAAI,CAACG,qBAAU,CAAC,aAAa,CAAC,YAAY,EAAE,EAAE,EAAEH,iBAAU,CAAC,QAAQ,CAAC,EAAE;IACnL,oBAAoB,cAAc,CAAC,IAAI,CAACG,qBAAU,CAAC,KAAK,CAAC,YAAY,CAAC,CAAC,CAAC;IACxE,iBAAiB;IACjB,aAAa;IACb,SAAS;IACT,QAAQ,cAAc,CAAC,IAAI,CAAC,EAAE,CAAC,CAAC;IAChC,KAAK;AACL;IACA,IAAI,IAAI,IAAI,EAAE;IACd,QAAQ,EAAE,GAAG,SAAS,CAAC,eAAe,GAAG,CAAC,CAAC,CAAC;IAC5C,QAAQ,EAAE,GAAG,SAAS,CAAC,CAAC,CAAC,CAAC;IAC1B,QAAQ,YAAY,GAAGW,mCAAiB,CAAC,gBAAgB,CAAC,EAAE,EAAE,EAAE,EAAE,QAAQ,EAAE,mBAAmB,CAAC,CAAC;IACjG,QAAQ,IAAIb,YAAO,CAAC,YAAY,CAAC,IAAI,CAACE,qBAAU,CAAC,aAAa,CAAC,YAAY,EAAE,EAAE,EAAEH,iBAAU,CAAC,QAAQ,CAAC,IAAI,CAACG,qBAAU,CAAC,aAAa,CAAC,YAAY,EAAE,EAAE,EAAEH,iBAAU,CAAC,QAAQ,CAAC,EAAE;IAC3K,YAAY,IAAI,sBAAsB,CAAC,OAAO,KAAKU,eAAO,CAAC,QAAQ,EAAE;IACrE,gBAAgB,cAAc,CAAC,IAAI,CAACP,qBAAU,CAAC,KAAK,CAAC,YAAY,CAAC,CAAC,CAAC;IACpE,aAAa,MAAM,IAAI,sBAAsB,CAAC,OAAO,KAAKO,eAAO,CAAC,KAAK,EAAE;IACzE,gBAAgB,qBAAqB,GAAG,SAAS,CAAC,uBAAuB,CAAC,YAAY,EAAE,oBAAoB,CAAC,CAAC,SAAS,CAAC;IACxH,gBAAgB,EAAE,GAAG,SAAS,CAAC,uBAAuB,CAAC,EAAE,EAAE,oBAAoB,CAAC,CAAC;IACjF,gBAAgB,EAAE,GAAG,SAAS,CAAC,uBAAuB,CAAC,EAAE,EAAE,oBAAoB,CAAC,CAAC;IACjF,gBAAgB,SAAS,CAAC,YAAY,CAAC,EAAE,EAAE,EAAE,CAAC,CAAC;IAC/C,gBAAgB,wBAAwB,GAAG,SAAS,CAAC,6BAA6B,CAAC,qBAAqB,EAAE,+BAA+B,CAAC,CAAC;IAC3I,gBAAgB,YAAY,GAAG,SAAS,CAAC,uBAAuB,CAAC,wBAAwB,EAAE,mBAAmB,CAAC,CAAC;IAChH,gBAAgB,IAAIT,YAAO,CAAC,YAAY,CAAC,IAAI,CAACE,qBAAU,CAAC,aAAa,CAAC,YAAY,EAAE,EAAE,EAAEH,iBAAU,CAAC,QAAQ,CAAC,IAAI,CAACG,qBAAU,CAAC,aAAa,CAAC,YAAY,EAAE,EAAE,EAAEH,iBAAU,CAAC,QAAQ,CAAC,EAAE;IACnL,oBAAoB,cAAc,CAAC,IAAI,CAACG,qBAAU,CAAC,KAAK,CAAC,YAAY,CAAC,CAAC,CAAC;IACxE,iBAAiB;IACjB,aAAa;IACb,SAAS;IACT,KAAK;IACL,IAAI,IAAI,mBAAmB,GAAG,cAAc,CAAC,MAAM,CAAC;AACpD;IACA,IAAI,IAAI,aAAa,GAAG,IAAI,KAAK,CAAC,mBAAmB,CAAC,CAAC;IACvD,IAAI,KAAK,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,mBAAmB,EAAE,CAAC,EAAE,EAAE;IAC9C,QAAQ,IAAI,YAAY,GAAGC,uBAAY,CAAC,aAAa,CAAC,cAAc,CAAC,CAAC,CAAC,EAAE,SAAS,CAAC,CAAC;IACpF,QAAQ,YAAY,CAAC,MAAM,GAAG,GAAG,CAAC;IAClC,QAAQ,aAAa,CAAC,CAAC,CAAC,GAAG,YAAY,CAAC;IACxC,KAAK;AACL;IACA,IAAI,aAAa,GAAGW,2CAAqB,CAAC,aAAa,EAAEX,uBAAY,CAAC,aAAa,CAAC,CAAC;IACrF,IAAI,mBAAmB,GAAG,aAAa,CAAC,MAAM,CAAC;AAC/C;IACA,IAAI,IAAI,mBAAmB,GAAG,CAAC,EAAE;IACjC,QAAQ,OAAO,SAAS,CAAC;IACzB,KAAK;AACL;IACA;IACA;IACA;IACA;IACA;IACA,IAAI,IAAI,kBAAkB,GAAG,EAAE,CAAC;IAChC,IAAI,IAAI,YAAY,GAAG,EAAE,CAAC;IAC1B,IAAI,IAAI,oBAAoB,GAAG,EAAE,CAAC;IAClC,IAAI,IAAI,iBAAiB,GAAG,EAAE,CAAC;AAC/B;IACA,IAAI,IAAI,cAAc,GAAG,qBAAqB,CAAC;IAC/C,IAAI,IAAI,YAAY,GAAG,mBAAmB,CAAC;IAC3C,IAAI,IAAI,SAAS,GAAG,gBAAgB,CAAC;IACrC,IAAI,IAAI,UAAU,GAAG,iBAAiB,CAAC;IACvC,IAAI,IAAI,YAAY,GAAG,mBAAmB,CAAC;AAC3C;IACA;IACA,IAAI,IAAI,iBAAiB,GAAG,aAAa,CAAC,CAAC,CAAC,CAAC;IAC7C,IAAI,IAAI,gBAAgB,GAAG,aAAa,CAAC,CAAC,CAAC,CAAC;AAC5C;IACA,IAAI,IAAI,oBAAoB,GAAG,aAAa,CAAC,mBAAmB,GAAG,CAAC,CAAC,CAAC;IACtE,IAAI,cAAc,GAAG,WAAW,CAAC,SAAS,EAAE,oBAAoB,EAAE,SAAS,EAAE,cAAc,CAAC,CAAC;IAC7F,IAAI,UAAU,GAAG,WAAW,CAAC,SAAS,EAAE,gBAAgB,EAAE,SAAS,EAAE,UAAU,CAAC,CAAC;IACjF,IAAI,YAAY,GAAG,WAAW,CAAC,SAAS,EAAE,iBAAiB,EAAE,SAAS,EAAE,YAAY,CAAC,CAAC;IACtF,IAAI,SAAS,GAAG,WAAW,CAAC,SAAS,EAAE,iBAAiB,EAAE,SAAS,EAAE,SAAS,CAAC,CAAC;AAChF;IACA,IAAI,IAAI,IAAI,EAAE;IACd,QAAQ,YAAY,GAAG,wBAAwB,CAAC,cAAc,EAAE,YAAY,EAAE,SAAS,EAAE,UAAU,EAAE,YAAY,CAAC,CAAC;IACnH,KAAK,MAAM;IACX,QAAQ,YAAY,GAAG,kBAAkB,CAAC,iBAAiB,EAAE,gBAAgB,EAAE,SAAS,EAAE,SAAS,EAAE,YAAY,CAAC,CAAC;IACnH,KAAK;AACL;IACA,IAAID,qBAAU,CAAC,IAAI,CAAC,YAAY,EAAE,YAAY,EAAE,CAAC,CAAC,CAAC;IACnD,IAAIA,qBAAU,CAAC,IAAI,CAAC,YAAY,EAAE,oBAAoB,EAAE,CAAC,CAAC,CAAC;IAC3D,IAAIA,qBAAU,CAAC,IAAI,CAAC,SAAS,EAAE,iBAAiB,EAAE,CAAC,CAAC,CAAC;IACrD,IAAI,kBAAkB,CAAC,IAAI,CAAC,iBAAiB,CAAC,QAAQ,CAAC,CAAC;IACxD,IAAI,kBAAkB,CAAC,IAAI,CAAC,iBAAiB,CAAC,SAAS,CAAC,CAAC;AACzD;IACA,IAAI,kBAAkB;IACtB,QAAQ,iBAAiB;IACzB,QAAQ,gBAAgB;IACxB,QAAQ,SAAS;IACjB,QAAQ,SAAS;IACjB,QAAQ,WAAW;IACnB,QAAQ,OAAO;IACf,QAAQ,SAAS;IACjB,QAAQ,YAAY;IACpB,QAAQ,oBAAoB;IAC5B,QAAQ,iBAAiB;IACzB,QAAQ,kBAAkB;IAC1B,KAAK,CAAC;AACN;IACA;IACA,IAAI,KAAK,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,mBAAmB,GAAG,CAAC,EAAE,EAAE,CAAC,EAAE;IAClD,QAAQ,cAAc,GAAGA,qBAAU,CAAC,KAAK,CAAC,YAAY,EAAE,cAAc,CAAC,CAAC;IACxE,QAAQ,YAAY,GAAGA,qBAAU,CAAC,KAAK,CAAC,UAAU,EAAE,YAAY,CAAC,CAAC;IAClE,QAAQ,IAAI,kBAAkB,GAAG,aAAa,CAAC,CAAC,CAAC,CAAC;IAClD,QAAQ,WAAW,CAAC,SAAS,EAAE,kBAAkB,EAAE,SAAS,EAAE,SAAS,CAAC,CAAC;IACzE,QAAQ,WAAW,CAAC,SAAS,EAAE,aAAa,CAAC,CAAC,GAAG,CAAC,CAAC,EAAE,SAAS,EAAE,UAAU,CAAC,CAAC;AAC5E;IACA,QAAQ,wBAAwB,CAAC,cAAc,EAAE,YAAY,EAAE,SAAS,EAAE,UAAU,EAAE,YAAY,CAAC,CAAC;AACpG;IACA,QAAQ,KAAK,GAAG,YAAY,CAAC,MAAM,CAAC;IACpC,QAAQA,qBAAU,CAAC,IAAI,CAAC,YAAY,EAAE,YAAY,EAAE,KAAK,CAAC,CAAC;IAC3D,QAAQA,qBAAU,CAAC,IAAI,CAAC,YAAY,EAAE,oBAAoB,EAAE,KAAK,CAAC,CAAC;IACnE,QAAQA,qBAAU,CAAC,IAAI,CAAC,SAAS,EAAE,iBAAiB,EAAE,KAAK,CAAC,CAAC;IAC7D,QAAQ,kBAAkB,CAAC,IAAI,CAAC,kBAAkB,CAAC,QAAQ,CAAC,CAAC;IAC7D,QAAQ,kBAAkB,CAAC,IAAI,CAAC,kBAAkB,CAAC,SAAS,CAAC,CAAC;AAC9D;IACA,QAAQ,kBAAkB;IAC1B,YAAY,aAAa,CAAC,CAAC,CAAC;IAC5B,YAAY,aAAa,CAAC,CAAC,GAAG,CAAC,CAAC;IAChC,YAAY,SAAS;IACrB,YAAY,SAAS;IACrB,YAAY,WAAW;IACvB,YAAY,OAAO;IACnB,YAAY,SAAS;IACrB,YAAY,YAAY;IACxB,YAAY,oBAAoB;IAChC,YAAY,iBAAiB;IAC7B,YAAY,kBAAkB;IAC9B,SAAS,CAAC;IACV,KAAK;AACL;IACA;IACA,IAAI,IAAI,eAAe,GAAG,aAAa,CAAC,mBAAmB,GAAG,CAAC,CAAC,CAAC;IACjE,IAAI,IAAI,kBAAkB,GAAG,aAAa,CAAC,mBAAmB,GAAG,CAAC,CAAC,CAAC;AACpE;IACA,IAAI,YAAY,GAAG,WAAW,CAAC,SAAS,EAAE,eAAe,EAAE,SAAS,EAAE,YAAY,CAAC,CAAC;IACpF,IAAI,SAAS,GAAG,WAAW,CAAC,SAAS,EAAE,eAAe,EAAE,SAAS,EAAE,SAAS,CAAC,CAAC;AAC9E;IACA,IAAI,IAAI,IAAI,EAAE;IACd,QAAQ,IAAI,mBAAmB,GAAG,aAAa,CAAC,CAAC,CAAC,CAAC;IACnD,QAAQ,cAAc,GAAG,WAAW,CAAC,SAAS,EAAE,kBAAkB,EAAE,SAAS,EAAE,cAAc,CAAC,CAAC;IAC/F,QAAQ,UAAU,GAAG,WAAW,CAAC,SAAS,EAAE,mBAAmB,EAAE,SAAS,EAAE,UAAU,CAAC,CAAC;AACxF;IACA,QAAQ,YAAY,GAAG,wBAAwB,CAAC,cAAc,EAAE,YAAY,EAAE,SAAS,EAAE,UAAU,EAAE,YAAY,CAAC,CAAC;IACnH,KAAK,MAAM;IACX,QAAQ,YAAY,GAAG,kBAAkB,CAAC,kBAAkB,EAAE,eAAe,EAAE,SAAS,EAAE,SAAS,EAAE,YAAY,CAAC,CAAC;IACnH,KAAK;AACL;IACA,IAAI,KAAK,GAAG,YAAY,CAAC,MAAM,CAAC;IAChC,IAAIA,qBAAU,CAAC,IAAI,CAAC,YAAY,EAAE,YAAY,EAAE,KAAK,CAAC,CAAC;IACvD,IAAIA,qBAAU,CAAC,IAAI,CAAC,YAAY,EAAE,oBAAoB,EAAE,KAAK,CAAC,CAAC;IAC/D,IAAIA,qBAAU,CAAC,IAAI,CAAC,SAAS,EAAE,iBAAiB,EAAE,KAAK,CAAC,CAAC;IACzD,IAAI,kBAAkB,CAAC,IAAI,CAAC,eAAe,CAAC,QAAQ,CAAC,CAAC;IACtD,IAAI,kBAAkB,CAAC,IAAI,CAAC,eAAe,CAAC,SAAS,CAAC,CAAC;AACvD;IACA,IAAI,IAAI,IAAI,EAAE;IACd,QAAQ,kBAAkB;IAC1B,YAAY,eAAe;IAC3B,YAAY,iBAAiB;IAC7B,YAAY,SAAS;IACrB,YAAY,SAAS;IACrB,YAAY,WAAW;IACvB,YAAY,OAAO;IACnB,YAAY,SAAS;IACrB,YAAY,YAAY;IACxB,YAAY,oBAAoB;IAChC,YAAY,iBAAiB;IAC7B,YAAY,kBAAkB;IAC9B,SAAS,CAAC;IACV,QAAQ,KAAK,GAAG,YAAY,CAAC,MAAM,CAAC;IACpC,QAAQ,KAAK,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,CAAC,EAAE,EAAE,CAAC,EAAE;IAChC,YAAY,YAAY,CAAC,KAAK,GAAG,CAAC,CAAC,GAAG,YAAY,CAAC,CAAC,CAAC,CAAC;IACtD,YAAY,oBAAoB,CAAC,KAAK,GAAG,CAAC,CAAC,GAAG,oBAAoB,CAAC,CAAC,CAAC,CAAC;IACtE,YAAY,iBAAiB,CAAC,KAAK,GAAG,CAAC,CAAC,GAAG,iBAAiB,CAAC,CAAC,CAAC,CAAC;IAChE,SAAS;IACT,QAAQ,kBAAkB,CAAC,IAAI,CAAC,iBAAiB,CAAC,QAAQ,CAAC,CAAC;IAC5D,QAAQ,kBAAkB,CAAC,IAAI,CAAC,iBAAiB,CAAC,SAAS,CAAC,CAAC;IAC7D,KAAK;AACL;IACA,IAAI,OAAO,0BAA0B,CAAC,IAAI,EAAE,UAAU,EAAE,oBAAoB,EAAE,iBAAiB,EAAE,YAAY,EAAE,kBAAkB,EAAE,mBAAmB,CAAC,CAAC;IACxJ,CAAC,CAAC;AACF;IACA;IACA;IACA;IACA,IAAI,oBAAoB,GAAG,IAAIA,qBAAU,EAAE,CAAC;IAC5C,IAAI,cAAc,GAAG,IAAIa,kBAAO,EAAE,CAAC;IACnC,IAAI,iBAAiB,GAAG,IAAIC,qBAAU,EAAE,CAAC;IACzC,SAAS,UAAU,CAAC,iBAAiB,EAAE,WAAW,EAAE,SAAS,EAAE,MAAM,EAAE;IACvE,IAAI,IAAI,aAAa,GAAG,SAAS,CAAC,SAAS,EAAE,WAAW,EAAE,oBAAoB,CAAC,CAAC;AAChF;IACA,IAAI,IAAI,GAAG,GAAGd,qBAAU,CAAC,GAAG,CAAC,aAAa,EAAE,iBAAiB,CAAC,CAAC;IAC/D,IAAI,IAAI,GAAG,GAAG,iBAAiB,IAAI,GAAG,GAAG,iBAAiB,EAAE;IAC5D,QAAQ,IAAI,QAAQ,GAAG,SAAS,CAAC,MAAM,EAAE,SAAS,EAAE,eAAe,CAAC,CAAC;IACrE,QAAQ,IAAI,KAAK,GAAG,GAAG,GAAG,iBAAiB,GAAGH,iBAAU,CAAC,WAAW,GAAG,CAACA,iBAAU,CAAC,WAAW,CAAC;IAC/F,QAAQ,IAAI,UAAU,GAAGiB,qBAAU,CAAC,aAAa,CAAC,QAAQ,EAAE,KAAK,EAAE,iBAAiB,CAAC,CAAC;IACtF,QAAQ,IAAI,cAAc,GAAGD,kBAAO,CAAC,cAAc,CAAC,UAAU,EAAE,cAAc,CAAC,CAAC;IAChF,QAAQA,kBAAO,CAAC,gBAAgB,CAAC,cAAc,EAAE,iBAAiB,EAAE,iBAAiB,CAAC,CAAC;IACvF,QAAQ,OAAO,IAAI,CAAC;IACpB,KAAK;IACL,IAAI,OAAO,KAAK,CAAC;IACjB,CAAC;AACD;IACA,IAAI,yBAAyB,GAAG,IAAIZ,uBAAY,EAAE,CAAC;IACnD,IAAI,uBAAuB,GAAG,IAAID,qBAAU,EAAE,CAAC;IAC/C,IAAI,qBAAqB,GAAG,IAAIA,qBAAU,EAAE,CAAC;IAC7C,SAAS,aAAa,CAAC,UAAU,EAAE,YAAY,EAAE,MAAM,EAAE,iBAAiB,EAAE,MAAM,EAAE;IACpF,IAAI,IAAI,QAAQ,GAAGC,uBAAY,CAAC,WAAW,CAAC,YAAY,EAAE,UAAU,CAAC,UAAU,EAAE,uBAAuB,CAAC,CAAC;IAC1G,IAAI,IAAI,cAAc,GAAGD,qBAAU,CAAC,GAAG,CAAC,QAAQ,EAAE,MAAM,EAAE,qBAAqB,CAAC,CAAC;IACjF,IAAI,IAAI,UAAU,GAAG,KAAK,CAAC;AAC3B;IACA,IAAI,IAAI,SAAS,GAAG,UAAU,CAAC,UAAU,CAAC;IAC1C,IAAI,IAAI,0BAA0B,GAAG,SAAS,CAAC,uBAAuB,CAAC,cAAc,EAAE,yBAAyB,CAAC,CAAC;IAClH;IACA;IACA;IACA;IACA,IAAI,IAAI,IAAI,CAAC,GAAG,CAAC,YAAY,CAAC,SAAS,GAAG,0BAA0B,CAAC,SAAS,CAAC,GAAGH,iBAAU,CAAC,WAAW,EAAE;IAC1G,QAAQ,UAAU,GAAG,IAAI,CAAC;IAC1B,QAAQ,cAAc,GAAGG,qBAAU,CAAC,QAAQ,CAAC,QAAQ,EAAE,MAAM,EAAE,qBAAqB,CAAC,CAAC;IACtF,QAAQ,0BAA0B,GAAG,SAAS,CAAC,uBAAuB,CAAC,cAAc,EAAE,yBAAyB,CAAC,CAAC;IAClH,KAAK;AACL;IACA,IAAI,0BAA0B,CAAC,MAAM,GAAG,GAAG,CAAC;IAC5C,IAAI,IAAI,uBAAuB,GAAG,UAAU,CAAC,OAAO,CAAC,0BAA0B,EAAE,MAAM,CAAC,CAAC;IACzF,IAAI,MAAM,GAAGA,qBAAU,CAAC,QAAQ,CAAC,uBAAuB,EAAE,iBAAiB,EAAE,MAAM,CAAC,CAAC;IACrF,IAAI,MAAM,CAAC,CAAC,GAAG,GAAG,CAAC;IACnB,IAAI,MAAM,GAAGA,qBAAU,CAAC,SAAS,CAAC,MAAM,EAAE,MAAM,CAAC,CAAC;IAClD,IAAI,IAAI,UAAU,EAAE;IACpB,QAAQA,qBAAU,CAAC,MAAM,CAAC,MAAM,EAAE,MAAM,CAAC,CAAC;IAC1C,KAAK;IACL,IAAI,OAAO,MAAM,CAAC;IAClB,CAAC;AACD;IACA,IAAI,yBAAyB,GAAG,IAAIA,qBAAU,EAAE,CAAC;IACjD,IAAI,yBAAyB,GAAG,IAAIA,qBAAU,EAAE,CAAC;IACjD,SAAS,aAAa,CAAC,MAAM,EAAE,GAAG,EAAE,SAAS,EAAE,SAAS,EAAE,kBAAkB,EAAE,eAAe,EAAE;IAC/F;IACA,IAAI,IAAI,kBAAkB,GAAGA,qBAAU,CAAC,QAAQ,CAAC,GAAG,EAAE,MAAM,EAAE,yBAAyB,CAAC,CAAC;IACzF,IAAIA,qBAAU,CAAC,SAAS,CAAC,kBAAkB,EAAE,kBAAkB,CAAC,CAAC;AACjE;IACA,IAAI,IAAI,iBAAiB,GAAG,SAAS,GAAG,uBAAuB,CAAC;IAChE,IAAI,IAAI,kBAAkB,GAAGA,qBAAU,CAAC,gBAAgB,CAAC,kBAAkB,EAAE,iBAAiB,EAAE,yBAAyB,CAAC,CAAC;IAC3H,IAAIA,qBAAU,CAAC,GAAG,CAAC,MAAM,EAAE,kBAAkB,EAAE,kBAAkB,CAAC,CAAC;AACnE;IACA,IAAI,IAAI,cAAc,GAAG,SAAS,GAAG,uBAAuB,CAAC;IAC7D,IAAI,kBAAkB,GAAGA,qBAAU,CAAC,gBAAgB,CAAC,kBAAkB,EAAE,cAAc,EAAE,yBAAyB,CAAC,CAAC;IACpH,IAAIA,qBAAU,CAAC,GAAG,CAAC,GAAG,EAAE,kBAAkB,EAAE,eAAe,CAAC,CAAC;IAC7D,CAAC;AACD;IACA,IAAI,qBAAqB,GAAG,IAAIA,qBAAU,EAAE,CAAC;IAC7C,SAAS,OAAO,CAAC,KAAK,EAAE,GAAG,EAAE;IAC7B,IAAI,IAAI,iBAAiB,GAAGU,WAAK,CAAC,gBAAgB,CAAC,QAAQ,EAAE,KAAK,CAAC,CAAC;IACpE,IAAI,IAAI,eAAe,GAAGA,WAAK,CAAC,gBAAgB,CAAC,QAAQ,EAAE,GAAG,CAAC,CAAC;IAChE,IAAI,IAAI,MAAM,GAAG,qBAAqB,CAAC;IACvC;IACA,IAAI,IAAIb,iBAAU,CAAC,aAAa,CAAC,iBAAiB,EAAE,GAAG,EAAEA,iBAAU,CAAC,QAAQ,CAAC,EAAE;IAC/E,QAAQ,MAAM,GAAG,SAAS,CAAC,GAAG,EAAE,KAAK,EAAE,MAAM,CAAC,CAAC;IAC/C,QAAQG,qBAAU,CAAC,gBAAgB,CAAC,MAAM,EAAEH,iBAAU,CAAC,QAAQ,EAAE,MAAM,CAAC,CAAC;IACzE,QAAQG,qBAAU,CAAC,GAAG,CAAC,KAAK,EAAE,MAAM,EAAE,KAAK,CAAC,CAAC;IAC7C,KAAK,MAAM,IAAIH,iBAAU,CAAC,aAAa,CAAC,eAAe,EAAE,GAAG,EAAEA,iBAAU,CAAC,QAAQ,CAAC,EAAE;IACpF,QAAQ,MAAM,GAAG,SAAS,CAAC,KAAK,EAAE,GAAG,EAAE,MAAM,CAAC,CAAC;IAC/C,QAAQG,qBAAU,CAAC,gBAAgB,CAAC,MAAM,EAAEH,iBAAU,CAAC,QAAQ,EAAE,MAAM,CAAC,CAAC;IACzE,QAAQG,qBAAU,CAAC,GAAG,CAAC,GAAG,EAAE,MAAM,EAAE,GAAG,CAAC,CAAC;IACzC,KAAK;IACL,CAAC;AACD;IACA;IACA;IACA;IACA,SAAS,iBAAiB,CAAC,KAAK,EAAE,GAAG,EAAE;IACvC,IAAI,IAAI,WAAW,GAAG,IAAI,CAAC,GAAG,CAAC,KAAK,CAAC,SAAS,CAAC,CAAC;IAChD,IAAI,IAAI,SAAS,GAAG,IAAI,CAAC,GAAG,CAAC,GAAG,CAAC,SAAS,CAAC,CAAC;IAC5C,IAAI,IAAIH,iBAAU,CAAC,aAAa,CAAC,WAAW,EAAEA,iBAAU,CAAC,EAAE,EAAEA,iBAAU,CAAC,SAAS,CAAC,EAAE;IACpF,QAAQ,IAAI,OAAO,GAAGA,iBAAU,CAAC,IAAI,CAAC,GAAG,CAAC,SAAS,CAAC,CAAC;IACrD,QAAQ,KAAK,CAAC,SAAS,GAAG,OAAO,IAAI,WAAW,GAAGA,iBAAU,CAAC,SAAS,CAAC,CAAC;IACzE,QAAQ,OAAO,CAAC,CAAC;IACjB,KAAK,MAAM,IAAIA,iBAAU,CAAC,aAAa,CAAC,SAAS,EAAEA,iBAAU,CAAC,EAAE,EAAEA,iBAAU,CAAC,SAAS,CAAC,EAAE;IACzF,QAAQ,IAAI,SAAS,GAAGA,iBAAU,CAAC,IAAI,CAAC,KAAK,CAAC,SAAS,CAAC,CAAC;IACzD,QAAQ,GAAG,CAAC,SAAS,GAAG,SAAS,IAAI,SAAS,GAAGA,iBAAU,CAAC,SAAS,CAAC,CAAC;IACvE,QAAQ,OAAO,CAAC,CAAC;IACjB,KAAK;IACL,IAAI,OAAO,CAAC,CAAC;IACb,CAAC;AACD;IACA,IAAI,wBAAwB,GAAG,IAAII,uBAAY,EAAE,CAAC;IAClD,IAAI,sBAAsB,GAAG,IAAIA,uBAAY,EAAE,CAAC;AAChD;IACA,IAAI,sBAAsB,GAAG,IAAID,qBAAU,EAAE,CAAC;IAC9C,IAAI,oBAAoB,GAAG,IAAIA,qBAAU,EAAE,CAAC;IAC5C,IAAI,yBAAyB,GAAG,IAAIA,qBAAU,EAAE,CAAC;IACjD,IAAI,uBAAuB,GAAG,IAAIA,qBAAU,EAAE,CAAC;IAC/C,IAAI,yBAAyB,GAAG,IAAIA,qBAAU,EAAE,CAAC;IACjD,IAAI,uBAAuB,GAAG,IAAIA,qBAAU,EAAE,CAAC;AAC/C;IACA,IAAI,sBAAsB,GAAG,CAAC,wBAAwB,EAAE,sBAAsB,CAAC,CAAC;IAChF,IAAI,yBAAyB,GAAG,IAAIN,oBAAS,EAAE,CAAC;AAChD;IACA,IAAI,2BAA2B,GAAG,IAAIM,qBAAU,EAAE,CAAC;IACnD,IAAI,yBAAyB,GAAG,IAAIA,qBAAU,EAAE,CAAC;IACjD,IAAI,8BAA8B,GAAG,IAAIA,qBAAU,EAAE,CAAC;IACtD,IAAI,4BAA4B,GAAG,IAAIA,qBAAU,EAAE,CAAC;AACpD;IACA,IAAI,qBAAqB,GAAG,IAAIA,qBAAU,EAAE,CAAC;IAC7C,IAAI,mBAAmB,GAAG,IAAIA,qBAAU,EAAE,CAAC;IAC3C,IAAI,2BAA2B,GAAG,IAAIA,qBAAU,EAAE,CAAC;IACnD,IAAI,yBAAyB,GAAG,IAAIA,qBAAU,EAAE,CAAC;AACjD;IACA,IAAI,aAAa,GAAG,IAAIA,qBAAU,EAAE,CAAC;IACrC,IAAI,cAAc,GAAG,IAAIA,qBAAU,EAAE,CAAC;IACtC,IAAI,YAAY,GAAG,IAAIA,qBAAU,EAAE,CAAC;IACpC,IAAI,YAAY,GAAG,IAAIA,qBAAU,EAAE,CAAC;IACpC,IAAI,uBAAuB,GAAG,IAAIA,qBAAU,EAAE,CAAC;IAC/C,IAAI,qBAAqB,GAAG,IAAIA,qBAAU,EAAE,CAAC;IAC7C,IAAI,aAAa,GAAG,IAAIe,mCAAiB,EAAE,CAAC;AAC5C;IACA,IAAI,eAAe,GAAG,IAAIA,mCAAiB,EAAE,CAAC;IAC9C,IAAI,sBAAsB,GAAG,IAAIf,qBAAU,EAAE,CAAC;IAC9C,IAAI,cAAc,GAAG,IAAIA,qBAAU,EAAE,CAAC;AACtC;IACA,IAAI,kBAAkB,GAAG,IAAIA,qBAAU,EAAE,CAAC;AAC1C;IACA,IAAI,sBAAsB,GAAG,CAAC,IAAIE,yBAAc,EAAE,EAAE,IAAIA,yBAAc,EAAE,CAAC,CAAC;AAC1E;IACA;IACA,IAAI,iBAAiB,GAAG;IACxB,IAAI,CAAC;IACL,IAAI,CAAC;IACL,IAAI,CAAC;IACL,IAAI,CAAC;IACL,IAAI,CAAC;IACL,IAAI,CAAC;IACL,IAAI,CAAC;IACL,IAAI,CAAC;IACL,IAAI,CAAC;IACL,IAAI,CAAC;IACL,IAAI,CAAC;IACL,IAAI,CAAC;IACL,IAAI,CAAC;IACL,IAAI,CAAC;IACL,IAAI,CAAC;IACL,IAAI,CAAC;IACL,IAAI,CAAC;IACL,IAAI,CAAC;IACL,IAAI,CAAC;IACL,IAAI,CAAC;IACL,IAAI,CAAC;IACL,IAAI,CAAC;IACL,IAAI,CAAC;IACL,IAAI,CAAC;IACL,IAAI,CAAC;IACL,IAAI,CAAC;IACL,IAAI,CAAC;IACL,IAAI,CAAC;IACL,IAAI,CAAC;IACL,IAAI,CAAC;IACL,IAAI,CAAC;IACL,IAAI,CAAC;IACL,IAAI,CAAC;IACL,IAAI,CAAC;IACL,IAAI,CAAC;IACL,IAAI,CAAC;IACL,CAAC,CAAC;IACF,IAAI,wBAAwB,GAAG,iBAAiB,CAAC,MAAM,CAAC;AACxD;IACA;IACA;IACA;IACA;IACA,SAAS,0BAA0B,CAAC,IAAI,EAAE,UAAU,EAAE,oBAAoB,EAAE,iBAAiB,EAAE,YAAY,EAAE,kBAAkB,EAAE,mBAAmB,EAAE;IACtJ,IAAI,IAAI,CAAC,CAAC;IACV,IAAI,IAAI,KAAK,CAAC;IACd,IAAI,IAAI,SAAS,GAAG,UAAU,CAAC,UAAU,CAAC;AAC1C;IACA;IACA,IAAI,IAAI,YAAY,GAAG,oBAAoB,CAAC,MAAM,GAAG,CAAC,GAAG,CAAC,CAAC;IAC3D,IAAI,IAAI,WAAW,GAAG,YAAY,GAAG,CAAC,CAAC;IACvC,IAAI,IAAI,aAAa,GAAG,WAAW,GAAG,CAAC,CAAC;IACxC,IAAI,IAAI,UAAU,GAAG,YAAY,GAAG,EAAE,CAAC;AACvC;IACA,IAAI,IAAI,OAAO,GAAG,WAAW,GAAG,KAAK,GAAG,IAAI,WAAW,CAAC,UAAU,CAAC,GAAG,IAAI,WAAW,CAAC,UAAU,CAAC,CAAC;IAClG,IAAI,IAAI,cAAc,GAAG,IAAI,YAAY,CAAC,WAAW,GAAG,CAAC,CAAC,CAAC;AAC3D;IACA,IAAI,IAAI,wBAAwB,GAAG,IAAI,YAAY,CAAC,aAAa,CAAC,CAAC;IACnE,IAAI,IAAI,wBAAwB,GAAG,IAAI,YAAY,CAAC,aAAa,CAAC,CAAC;IACnE,IAAI,IAAI,4BAA4B,GAAG,IAAI,YAAY,CAAC,aAAa,CAAC,CAAC;IACvE,IAAI,IAAI,2CAA2C,GAAG,IAAI,YAAY,CAAC,aAAa,CAAC,CAAC;IACtF,IAAI,IAAI,6CAA6C,GAAG,IAAI,YAAY,CAAC,aAAa,CAAC,CAAC;AACxF;IACA,IAAI,IAAI,WAAW,CAAC;IACpB,IAAI,IAAI,gBAAgB,CAAC;IACzB,IAAI,IAAI,iBAAiB,CAAC;IAC1B,IAAI,IAAI,uBAAuB,CAAC;AAChC;IACA,IAAI,IAAI,mBAAmB,EAAE;IAC7B,QAAQ,WAAW,GAAG,IAAI,YAAY,CAAC,aAAa,CAAC,CAAC;IACtD,QAAQ,gBAAgB,GAAG,IAAI,YAAY,CAAC,aAAa,CAAC,CAAC;IAC3D,QAAQ,iBAAiB,GAAG,IAAI,YAAY,CAAC,aAAa,CAAC,CAAC;IAC5D,QAAQ,uBAAuB,GAAG,IAAI,YAAY,CAAC,WAAW,GAAG,CAAC,CAAC,CAAC;IACpE,KAAK;AACL;IACA;IACA;IACA,IAAI,IAAI,mBAAmB,GAAG,kBAAkB,CAAC,MAAM,GAAG,CAAC,CAAC;IAC5D,IAAI,IAAI,QAAQ,GAAG,GAAG,CAAC;AACvB;IACA,IAAI,IAAI,iBAAiB,GAAG,wBAAwB,CAAC;IACrD,IAAI,iBAAiB,CAAC,MAAM,GAAG,GAAG,CAAC;IACnC,IAAI,IAAI,eAAe,GAAG,sBAAsB,CAAC;IACjD,IAAI,eAAe,CAAC,MAAM,GAAG,GAAG,CAAC;AACjC;IACA,IAAI,IAAI,qBAAqB,GAAG,sBAAsB,CAAC;IACvD,IAAI,IAAI,mBAAmB,GAAG,oBAAoB,CAAC;AACnD;IACA,IAAI,IAAI,mBAAmB,EAAE;IAC7B,QAAQ,KAAK,GAAG,CAAC,CAAC;IAClB,QAAQ,KAAK,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,mBAAmB,EAAE,CAAC,EAAE,EAAE;IAClD;IACA,YAAY,iBAAiB,CAAC,QAAQ,GAAG,kBAAkB,CAAC,KAAK,CAAC,CAAC;IACnE,YAAY,iBAAiB,CAAC,SAAS,GAAG,kBAAkB,CAAC,KAAK,GAAG,CAAC,CAAC,CAAC;IACxE,YAAY,eAAe,CAAC,QAAQ,GAAG,kBAAkB,CAAC,KAAK,GAAG,CAAC,CAAC,CAAC;IACrE,YAAY,eAAe,CAAC,SAAS,GAAG,kBAAkB,CAAC,KAAK,GAAG,CAAC,CAAC,CAAC;AACtE;IACA,YAAY,qBAAqB,GAAG,UAAU,CAAC,OAAO,CAAC,iBAAiB,EAAE,qBAAqB,CAAC,CAAC;IACjG,YAAY,mBAAmB,GAAG,UAAU,CAAC,OAAO,CAAC,eAAe,EAAE,mBAAmB,CAAC,CAAC;IAC3F,YAAY,QAAQ,IAAIF,qBAAU,CAAC,QAAQ,CAAC,qBAAqB,EAAE,mBAAmB,CAAC,CAAC;IACxF,YAAY,KAAK,IAAI,CAAC,CAAC;IACvB,SAAS;IACT,KAAK;AACL;IACA;IACA,IAAI,IAAI,eAAe,GAAG,iBAAiB,CAAC,MAAM,GAAG,CAAC,CAAC;IACvD,IAAI,mBAAmB,GAAGA,qBAAU,CAAC,MAAM,CAAC,iBAAiB,EAAE,CAAC,EAAE,mBAAmB,CAAC,CAAC;IACvF,IAAI,IAAI,QAAQ,GAAG,GAAG,CAAC;AACvB;IACA,IAAI,KAAK,GAAG,CAAC,CAAC;IACd,IAAI,KAAK,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,eAAe,EAAE,CAAC,EAAE,EAAE;IAC1C,QAAQ,qBAAqB,GAAGA,qBAAU,CAAC,KAAK,CAAC,mBAAmB,EAAE,qBAAqB,CAAC,CAAC;IAC7F,QAAQ,mBAAmB,GAAGA,qBAAU,CAAC,MAAM,CAAC,iBAAiB,EAAE,KAAK,EAAE,mBAAmB,CAAC,CAAC;IAC/F,QAAQ,QAAQ,IAAIA,qBAAU,CAAC,QAAQ,CAAC,qBAAqB,EAAE,mBAAmB,CAAC,CAAC;IACpF,QAAQ,KAAK,IAAI,CAAC,CAAC;IACnB,KAAK;AACL;IACA;IACA,IAAI,IAAI,CAAC,CAAC;IACV,IAAI,KAAK,GAAG,CAAC,CAAC;IACd,IAAI,IAAI,kBAAkB,GAAG,CAAC,CAAC;IAC/B,IAAI,IAAI,eAAe,GAAG,CAAC,CAAC;IAC5B,IAAI,IAAI,eAAe,GAAG,CAAC,CAAC;IAC5B,IAAI,IAAI,eAAe,GAAG,CAAC,CAAC;IAC5B,IAAI,IAAI,WAAW,GAAG,KAAK,CAAC;AAC5B;IACA,IAAI,IAAI,SAAS,GAAGA,qBAAU,CAAC,MAAM,CAAC,oBAAoB,EAAE,CAAC,EAAE,uBAAuB,CAAC,CAAC;IACxF,IAAI,IAAI,MAAM,GAAGA,qBAAU,CAAC,MAAM,CAAC,iBAAiB,EAAE,CAAC,EAAE,oBAAoB,CAAC,CAAC;IAC/E,IAAI,IAAI,iBAAiB,GAAGA,qBAAU,CAAC,MAAM,CAAC,YAAY,EAAE,CAAC,EAAE,uBAAuB,CAAC,CAAC;AACxF;IACA,IAAI,IAAI,IAAI,EAAE;IACd,QAAQ,IAAI,YAAY,GAAGA,qBAAU,CAAC,MAAM,CAAC,oBAAoB,EAAE,oBAAoB,CAAC,MAAM,GAAG,CAAC,EAAE,yBAAyB,CAAC,CAAC;IAC/H,QAAQ,IAAI,UAAU,CAAC,iBAAiB,EAAE,YAAY,EAAE,SAAS,EAAE,MAAM,CAAC,EAAE;IAC5E;IACA,YAAY,iBAAiB,GAAGA,qBAAU,CAAC,MAAM,CAAC,iBAAiB,EAAE,iBAAiB,CAAC,CAAC;IACxF,SAAS;IACT,KAAK;AACL;IACA,IAAI,IAAI,aAAa,GAAG,GAAG,CAAC;IAC5B,IAAI,IAAI,aAAa,GAAG,GAAG,CAAC;AAC5B;IACA;IACA,IAAI,IAAI,UAAU,GAAG,GAAG,CAAC;AACzB;IACA,IAAI,KAAK,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,YAAY,EAAE,CAAC,EAAE,EAAE;IACvC,QAAQ,IAAI,WAAW,GAAGA,qBAAU,CAAC,KAAK,CAAC,SAAS,EAAE,yBAAyB,CAAC,CAAC;IACjF,QAAQ,IAAI,QAAQ,GAAGA,qBAAU,CAAC,KAAK,CAAC,MAAM,EAAE,sBAAsB,CAAC,CAAC;IACxE,QAAQ,IAAI,mBAAmB,GAAGA,qBAAU,CAAC,KAAK,CAAC,iBAAiB,EAAE,yBAAyB,CAAC,CAAC;AACjG;IACA,QAAQ,IAAI,WAAW,EAAE;IACzB,YAAY,mBAAmB,GAAGA,qBAAU,CAAC,MAAM,CAAC,mBAAmB,EAAE,mBAAmB,CAAC,CAAC;IAC9F,SAAS;AACT;IACA,QAAQ,SAAS,GAAGA,qBAAU,CAAC,MAAM,CAAC,oBAAoB,EAAE,KAAK,EAAE,uBAAuB,CAAC,CAAC;IAC5F,QAAQ,MAAM,GAAGA,qBAAU,CAAC,MAAM,CAAC,iBAAiB,EAAE,KAAK,EAAE,oBAAoB,CAAC,CAAC;IACnF,QAAQ,iBAAiB,GAAGA,qBAAU,CAAC,MAAM,CAAC,YAAY,EAAE,KAAK,EAAE,uBAAuB,CAAC,CAAC;AAC5F;IACA,QAAQ,WAAW,GAAG,UAAU,CAAC,iBAAiB,EAAE,WAAW,EAAE,SAAS,EAAE,MAAM,CAAC,CAAC;AACpF;IACA;IACA,QAAQ,iBAAiB,CAAC,QAAQ,GAAG,kBAAkB,CAAC,kBAAkB,CAAC,CAAC;IAC5E,QAAQ,iBAAiB,CAAC,SAAS,GAAG,kBAAkB,CAAC,kBAAkB,GAAG,CAAC,CAAC,CAAC;IACjF,QAAQ,eAAe,CAAC,QAAQ,GAAG,kBAAkB,CAAC,kBAAkB,GAAG,CAAC,CAAC,CAAC;IAC9E,QAAQ,eAAe,CAAC,SAAS,GAAG,kBAAkB,CAAC,kBAAkB,GAAG,CAAC,CAAC,CAAC;IAC/E,QAAQ,IAAI,OAAO,CAAC;IACpB,QAAQ,IAAI,KAAK,CAAC;IAClB,QAAQ,IAAI,qBAAqB,CAAC;IAClC,QAAQ,IAAI,mBAAmB,CAAC;AAChC;IACA,QAAQ,IAAI,mBAAmB,EAAE;IACjC,YAAY,IAAI,WAAW,GAAG,iBAAiB,CAAC,iBAAiB,EAAE,eAAe,CAAC,CAAC;IACpF,YAAY,OAAO,GAAG,UAAU,CAAC,OAAO,CAAC,iBAAiB,EAAE,qBAAqB,CAAC,CAAC;IACnF,YAAY,KAAK,GAAG,UAAU,CAAC,OAAO,CAAC,eAAe,EAAE,mBAAmB,CAAC,CAAC;IAC7E,YAAY,IAAI,WAAW,GAAG,SAAS,CAAC,KAAK,EAAE,OAAO,EAAE,sBAAsB,CAAC,CAAC;IAChF,YAAY,WAAW,CAAC,CAAC,GAAG,IAAI,CAAC,GAAG,CAAC,WAAW,CAAC,CAAC,CAAC,CAAC;AACpD;IACA,YAAY,qBAAqB,GAAG,2BAA2B,CAAC;IAChE,YAAY,mBAAmB,GAAG,yBAAyB,CAAC;IAC5D,YAAY,IAAI,WAAW,KAAK,CAAC,IAAIA,qBAAU,CAAC,GAAG,CAAC,WAAW,EAAEA,qBAAU,CAAC,MAAM,CAAC,GAAG,iBAAiB,EAAE;IACzG;IACA;IACA;IACA,gBAAgB,qBAAqB,GAAG,aAAa,CAAC,UAAU,EAAE,iBAAiB,EAAE,mBAAmB,EAAE,OAAO,EAAE,2BAA2B,CAAC,CAAC;IAChJ,gBAAgB,mBAAmB,GAAG,aAAa,CAAC,UAAU,EAAE,eAAe,EAAE,iBAAiB,EAAE,KAAK,EAAE,yBAAyB,CAAC,CAAC;IACtI,aAAa,MAAM,IAAI,WAAW,KAAK,CAAC,EAAE;IAC1C;IACA,gBAAgB,mBAAmB,GAAG,aAAa,CAAC,UAAU,EAAE,eAAe,EAAE,iBAAiB,EAAE,KAAK,EAAE,yBAAyB,CAAC,CAAC;IACtI,gBAAgB,qBAAqB,CAAC,CAAC,GAAG,GAAG,CAAC;IAC9C;IACA;IACA,gBAAgB,qBAAqB,CAAC,CAAC,GAAGH,iBAAU,CAAC,IAAI,CAAC,iBAAiB,CAAC,SAAS,GAAG,IAAI,CAAC,GAAG,CAAC,eAAe,CAAC,SAAS,CAAC,CAAC,CAAC;IAC7H,gBAAgB,qBAAqB,CAAC,CAAC,GAAG,GAAG,CAAC;IAC9C,aAAa,MAAM;IACnB;IACA,gBAAgB,qBAAqB,GAAG,aAAa,CAAC,UAAU,EAAE,iBAAiB,EAAE,mBAAmB,EAAE,OAAO,EAAE,2BAA2B,CAAC,CAAC;IAChJ,gBAAgB,mBAAmB,CAAC,CAAC,GAAG,GAAG,CAAC;IAC5C;IACA;IACA,gBAAgB,mBAAmB,CAAC,CAAC,GAAGA,iBAAU,CAAC,IAAI,CAAC,iBAAiB,CAAC,SAAS,GAAG,eAAe,CAAC,SAAS,CAAC,CAAC;IACjH,gBAAgB,mBAAmB,CAAC,CAAC,GAAG,GAAG,CAAC;IAC5C,aAAa;IACb,SAAS;AACT;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA,QAAQ,IAAI,eAAe,GAAGG,qBAAU,CAAC,QAAQ,CAAC,QAAQ,EAAE,MAAM,CAAC,CAAC;AACpE;IACA,QAAQ,IAAI,YAAY,GAAGe,mCAAiB,CAAC,aAAa,CAAC,WAAW,EAAE,aAAa,CAAC,CAAC;IACvF,QAAQ,IAAI,aAAa,GAAGf,qBAAU,CAAC,QAAQ,CAAC,SAAS,EAAE,WAAW,EAAE,aAAa,CAAC,CAAC;IACvF,QAAQ,IAAI,OAAO,GAAGA,qBAAU,CAAC,SAAS,CAAC,aAAa,EAAE,YAAY,CAAC,CAAC;AACxE;IACA,QAAQ,IAAI,OAAO,GAAGA,qBAAU,CAAC,QAAQ,CAAC,QAAQ,EAAE,WAAW,EAAE,cAAc,CAAC,CAAC;IACjF,QAAQ,OAAO,GAAGA,qBAAU,CAAC,SAAS,CAAC,OAAO,EAAE,OAAO,CAAC,CAAC;IACzD,QAAQ,IAAI,WAAW,GAAGA,qBAAU,CAAC,KAAK,CAAC,OAAO,EAAE,OAAO,EAAE,YAAY,CAAC,CAAC;IAC3E,QAAQ,WAAW,GAAGA,qBAAU,CAAC,SAAS,CAAC,WAAW,EAAE,WAAW,CAAC,CAAC;AACrE;IACA,QAAQ,IAAI,gBAAgB,GAAGA,qBAAU,CAAC,KAAK,CAAC,OAAO,EAAE,mBAAmB,EAAE,uBAAuB,CAAC,CAAC;IACvG,QAAQ,gBAAgB,GAAGA,qBAAU,CAAC,SAAS,CAAC,gBAAgB,EAAE,gBAAgB,CAAC,CAAC;AACpF;IACA,QAAQ,IAAI,KAAK,GAAGA,qBAAU,CAAC,QAAQ,CAAC,MAAM,EAAE,SAAS,EAAE,YAAY,CAAC,CAAC;IACzE,QAAQ,KAAK,GAAGA,qBAAU,CAAC,SAAS,CAAC,KAAK,EAAE,KAAK,CAAC,CAAC;IACnD,QAAQ,IAAI,cAAc,GAAGA,qBAAU,CAAC,KAAK,CAAC,iBAAiB,EAAE,KAAK,EAAE,qBAAqB,CAAC,CAAC;IAC/F,QAAQ,cAAc,GAAGA,qBAAU,CAAC,SAAS,CAAC,cAAc,EAAE,cAAc,CAAC,CAAC;AAC9E;IACA,QAAQ,IAAI,wBAAwB,GAAG,eAAe,GAAG,QAAQ,CAAC;IAClE,QAAQ,IAAI,wBAAwB,GAAG,aAAa,GAAG,QAAQ,CAAC;AAChE;IACA;IACA,QAAQ,IAAI,eAAe,GAAG,GAAG,CAAC;IAClC,QAAQ,IAAI,cAAc,CAAC;IAC3B,QAAQ,IAAI,eAAe,CAAC;IAC5B,QAAQ,IAAI,OAAO,CAAC;IACpB,QAAQ,IAAI,wBAAwB,GAAG,GAAG,CAAC;IAC3C,QAAQ,IAAI,wBAAwB,GAAG,GAAG,CAAC;IAC3C,QAAQ,IAAI,mBAAmB,EAAE;IACjC,YAAY,eAAe,GAAGA,qBAAU,CAAC,QAAQ,CAAC,OAAO,EAAE,KAAK,CAAC,CAAC;AAClE;IACA,YAAY,cAAc,GAAGe,mCAAiB,CAAC,aAAa,CAAC,OAAO,EAAE,eAAe,CAAC,CAAC;IACvF,YAAY,eAAe,GAAGf,qBAAU,CAAC,QAAQ,CAAC,KAAK,EAAE,OAAO,EAAE,sBAAsB,CAAC,CAAC;AAC1F;IACA;IACA;IACA,YAAY,OAAO,GAAGA,qBAAU,CAAC,SAAS,CAAC,eAAe,EAAE,cAAc,CAAC,CAAC;IAC5E,YAAY,IAAI,IAAI,GAAG,OAAO,CAAC,CAAC,CAAC;IACjC,YAAY,OAAO,CAAC,CAAC,GAAG,OAAO,CAAC,CAAC,CAAC;IAClC,YAAY,OAAO,CAAC,CAAC,GAAG,CAAC,IAAI,CAAC;AAC9B;IACA,YAAY,wBAAwB,GAAG,eAAe,GAAG,QAAQ,CAAC;IAClE,YAAY,wBAAwB,GAAG,aAAa,GAAG,QAAQ,CAAC;IAChE,SAAS;IACT;IACA,QAAQ,KAAK,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,CAAC,EAAE,CAAC,EAAE,EAAE;IAChC,YAAY,IAAI,SAAS,GAAG,eAAe,GAAG,CAAC,GAAG,CAAC,CAAC;IACpD,YAAY,IAAI,SAAS,GAAG,eAAe,GAAG,CAAC,GAAG,CAAC,CAAC;IACpD,YAAY,IAAI,MAAM,GAAG,SAAS,GAAG,CAAC,CAAC;AACvC;IACA;IACA;IACA,YAAY,IAAI,cAAc,GAAG,CAAC,GAAG,CAAC,GAAG,GAAG,GAAG,CAAC,GAAG,CAAC;IACpD,YAAY,IAAI,aAAa,GAAG,CAAC,KAAK,CAAC,IAAI,CAAC,KAAK,CAAC,IAAI,CAAC,KAAK,CAAC,IAAI,CAAC,KAAK,CAAC,GAAG,GAAG,GAAG,CAAC,GAAG,CAAC;AACtF;IACA;IACA,YAAYA,qBAAU,CAAC,IAAI,CAAC,YAAY,CAAC,IAAI,EAAE,wBAAwB,EAAE,SAAS,CAAC,CAAC;IACpF,YAAY,wBAAwB,CAAC,MAAM,CAAC,GAAG,aAAa,CAAC,CAAC,CAAC;AAC/D;IACA,YAAYA,qBAAU,CAAC,IAAI,CAAC,YAAY,CAAC,GAAG,EAAE,wBAAwB,EAAE,SAAS,CAAC,CAAC;IACnF,YAAY,wBAAwB,CAAC,MAAM,CAAC,GAAG,aAAa,CAAC,CAAC,CAAC;AAC/D;IACA,YAAYA,qBAAU,CAAC,IAAI,CAAC,gBAAgB,EAAE,4BAA4B,EAAE,SAAS,CAAC,CAAC;IACvF,YAAY,4BAA4B,CAAC,MAAM,CAAC,GAAG,aAAa,CAAC,CAAC,CAAC;AACnE;IACA,YAAYA,qBAAU,CAAC,IAAI,CAAC,cAAc,EAAE,2CAA2C,EAAE,SAAS,CAAC,CAAC;IACpG,YAAY,2CAA2C,CAAC,MAAM,CAAC,GAAG,wBAAwB,GAAG,cAAc,CAAC;AAC5G;IACA,YAAYA,qBAAU,CAAC,IAAI,CAAC,WAAW,EAAE,6CAA6C,EAAE,SAAS,CAAC,CAAC;AACnG;IACA,YAAY,IAAI,qBAAqB,GAAG,wBAAwB,GAAG,aAAa,CAAC;IACjF,YAAY,IAAI,qBAAqB,KAAK,GAAG,IAAI,aAAa,GAAG,GAAG,EAAE;IACtE,gBAAgB,qBAAqB,GAAG,GAAG,CAAC;IAC5C,aAAa;IACb,YAAY,6CAA6C,CAAC,MAAM,CAAC,GAAG,qBAAqB,CAAC;AAC1F;IACA;IACA,YAAY,IAAI,mBAAmB,EAAE;IACrC,gBAAgB,WAAW,CAAC,SAAS,CAAC,GAAG,cAAc,CAAC,IAAI,CAAC,CAAC,CAAC;IAC/D,gBAAgB,WAAW,CAAC,SAAS,GAAG,CAAC,CAAC,GAAG,cAAc,CAAC,IAAI,CAAC,CAAC,CAAC;IACnE,gBAAgB,WAAW,CAAC,SAAS,GAAG,CAAC,CAAC,GAAG,cAAc,CAAC,GAAG,CAAC,CAAC,CAAC;IAClE,gBAAgB,WAAW,CAAC,SAAS,GAAG,CAAC,CAAC,GAAG,cAAc,CAAC,GAAG,CAAC,CAAC,CAAC;AAClE;IACA,gBAAgB,iBAAiB,CAAC,SAAS,CAAC,GAAG,CAAC,qBAAqB,CAAC,CAAC,CAAC;IACxE,gBAAgB,iBAAiB,CAAC,SAAS,GAAG,CAAC,CAAC,GAAG,qBAAqB,CAAC,CAAC,CAAC;IAC3E,gBAAgB,iBAAiB,CAAC,SAAS,GAAG,CAAC,CAAC,GAAG,mBAAmB,CAAC,CAAC,CAAC;IACzE,gBAAgB,iBAAiB,CAAC,SAAS,GAAG,CAAC,CAAC,GAAG,CAAC,mBAAmB,CAAC,CAAC,CAAC;AAC1E;IACA,gBAAgB,gBAAgB,CAAC,SAAS,CAAC,GAAG,eAAe,CAAC,CAAC,CAAC;IAChE,gBAAgB,gBAAgB,CAAC,SAAS,GAAG,CAAC,CAAC,GAAG,eAAe,CAAC,CAAC,CAAC;IACpE,gBAAgB,gBAAgB,CAAC,SAAS,GAAG,CAAC,CAAC,GAAG,OAAO,CAAC,CAAC,CAAC;IAC5D,gBAAgB,gBAAgB,CAAC,SAAS,GAAG,CAAC,CAAC,GAAG,OAAO,CAAC,CAAC,CAAC;AAC5D;IACA,gBAAgB,uBAAuB,CAAC,SAAS,CAAC,GAAG,wBAAwB,GAAG,cAAc,CAAC;AAC/F;IACA,gBAAgB,qBAAqB,GAAG,wBAAwB,GAAG,aAAa,CAAC;IACjF,gBAAgB,IAAI,qBAAqB,KAAK,GAAG,IAAI,aAAa,GAAG,GAAG,EAAE;IAC1E,oBAAoB,qBAAqB,GAAG,GAAG,CAAC;IAChD,iBAAiB;IACjB,gBAAgB,uBAAuB,CAAC,SAAS,GAAG,CAAC,CAAC,GAAG,qBAAqB,CAAC;IAC/E,aAAa;IACb,SAAS;AACT;IACA;IACA,QAAQ,IAAI,uBAAuB,GAAG,8BAA8B,CAAC;IACrE,QAAQ,IAAI,qBAAqB,GAAG,4BAA4B,CAAC;IACjE,QAAQ,IAAI,oBAAoB,GAAG,2BAA2B,CAAC;IAC/D,QAAQ,IAAI,kBAAkB,GAAG,yBAAyB,CAAC;AAC3D;IACA,QAAQ,IAAI,mBAAmB,GAAGN,oBAAS,CAAC,qBAAqB,CAAC,sBAAsB,EAAE,yBAAyB,CAAC,CAAC;IACrH,QAAQ,IAAI,aAAa,GAAG,yBAAyB,CAAC,wBAAwB,CAAC,mBAAmB,EAAE,SAAS,CAAC,CAAC;IAC/G,QAAQ,IAAI,SAAS,GAAG,aAAa,CAAC,oBAAoB,CAAC;IAC3D,QAAQ,IAAI,SAAS,GAAG,aAAa,CAAC,oBAAoB,CAAC;AAC3D;IACA,QAAQ,UAAU,IAAI,SAAS,CAAC;IAChC,QAAQ,UAAU,IAAI,SAAS,CAAC;AAChC;IACA,QAAQ,aAAa,CAAC,WAAW,EAAE,QAAQ,EAAE,SAAS,EAAE,SAAS,EAAE,uBAAuB,EAAE,oBAAoB,CAAC,CAAC;IAClH,QAAQ,aAAa,CAAC,SAAS,EAAE,MAAM,EAAE,SAAS,EAAE,SAAS,EAAE,qBAAqB,EAAE,kBAAkB,CAAC,CAAC;AAC1G;IACA;IACA,QAAQ,IAAI,WAAW,GAAGM,qBAAU,CAAC,gBAAgB,CAAC,WAAW,EAAEH,iBAAU,CAAC,QAAQ,EAAE,kBAAkB,CAAC,CAAC;IAC5G,QAAQG,qBAAU,CAAC,GAAG,CAAC,uBAAuB,EAAE,WAAW,EAAE,uBAAuB,CAAC,CAAC;IACtF,QAAQA,qBAAU,CAAC,GAAG,CAAC,qBAAqB,EAAE,WAAW,EAAE,qBAAqB,CAAC,CAAC;IAClF,QAAQA,qBAAU,CAAC,GAAG,CAAC,oBAAoB,EAAE,WAAW,EAAE,oBAAoB,CAAC,CAAC;IAChF,QAAQA,qBAAU,CAAC,GAAG,CAAC,kBAAkB,EAAE,WAAW,EAAE,kBAAkB,CAAC,CAAC;AAC5E;IACA;IACA,QAAQ,OAAO,CAAC,uBAAuB,EAAE,qBAAqB,CAAC,CAAC;IAChE,QAAQ,OAAO,CAAC,oBAAoB,EAAE,kBAAkB,CAAC,CAAC;AAC1D;IACA,QAAQA,qBAAU,CAAC,IAAI,CAAC,uBAAuB,EAAE,cAAc,EAAE,eAAe,CAAC,CAAC;IAClF,QAAQA,qBAAU,CAAC,IAAI,CAAC,qBAAqB,EAAE,cAAc,EAAE,eAAe,GAAG,CAAC,CAAC,CAAC;IACpF,QAAQA,qBAAU,CAAC,IAAI,CAAC,kBAAkB,EAAE,cAAc,EAAE,eAAe,GAAG,CAAC,CAAC,CAAC;IACjF,QAAQA,qBAAU,CAAC,IAAI,CAAC,oBAAoB,EAAE,cAAc,EAAE,eAAe,GAAG,CAAC,CAAC,CAAC;AACnF;IACA,QAAQ,WAAW,GAAGA,qBAAU,CAAC,gBAAgB,CAAC,WAAW,EAAE,CAAC,GAAG,GAAGH,iBAAU,CAAC,QAAQ,EAAE,kBAAkB,CAAC,CAAC;IAC/G,QAAQG,qBAAU,CAAC,GAAG,CAAC,uBAAuB,EAAE,WAAW,EAAE,uBAAuB,CAAC,CAAC;IACtF,QAAQA,qBAAU,CAAC,GAAG,CAAC,qBAAqB,EAAE,WAAW,EAAE,qBAAqB,CAAC,CAAC;IAClF,QAAQA,qBAAU,CAAC,GAAG,CAAC,oBAAoB,EAAE,WAAW,EAAE,oBAAoB,CAAC,CAAC;IAChF,QAAQA,qBAAU,CAAC,GAAG,CAAC,kBAAkB,EAAE,WAAW,EAAE,kBAAkB,CAAC,CAAC;AAC5E;IACA,QAAQ,OAAO,CAAC,uBAAuB,EAAE,qBAAqB,CAAC,CAAC;IAChE,QAAQ,OAAO,CAAC,oBAAoB,EAAE,kBAAkB,CAAC,CAAC;AAC1D;IACA,QAAQA,qBAAU,CAAC,IAAI,CAAC,uBAAuB,EAAE,cAAc,EAAE,eAAe,GAAG,EAAE,CAAC,CAAC;IACvF,QAAQA,qBAAU,CAAC,IAAI,CAAC,qBAAqB,EAAE,cAAc,EAAE,eAAe,GAAG,EAAE,CAAC,CAAC;IACrF,QAAQA,qBAAU,CAAC,IAAI,CAAC,kBAAkB,EAAE,cAAc,EAAE,eAAe,GAAG,EAAE,CAAC,CAAC;IAClF,QAAQA,qBAAU,CAAC,IAAI,CAAC,oBAAoB,EAAE,cAAc,EAAE,eAAe,GAAG,EAAE,CAAC,CAAC;AACpF;IACA,QAAQ,kBAAkB,IAAI,CAAC,CAAC;IAChC,QAAQ,KAAK,IAAI,CAAC,CAAC;AACnB;IACA,QAAQ,eAAe,IAAI,EAAE,CAAC;IAC9B,QAAQ,eAAe,IAAI,EAAE,CAAC;IAC9B,QAAQ,eAAe,IAAI,EAAE,CAAC;AAC9B;IACA,QAAQ,aAAa,IAAI,eAAe,CAAC;IACzC,QAAQ,aAAa,IAAI,eAAe,CAAC;IACzC,KAAK;AACL;IACA,IAAI,KAAK,GAAG,CAAC,CAAC;IACd,IAAI,IAAI,WAAW,GAAG,CAAC,CAAC;IACxB,IAAI,KAAK,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,YAAY,EAAE,CAAC,EAAE,EAAE;IACvC,QAAQ,KAAK,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,wBAAwB,EAAE,CAAC,EAAE,EAAE;IACvD,YAAY,OAAO,CAAC,KAAK,GAAG,CAAC,CAAC,GAAG,iBAAiB,CAAC,CAAC,CAAC,GAAG,WAAW,CAAC;IACpE,SAAS;IACT,QAAQ,WAAW,IAAI,CAAC,CAAC;IACzB,QAAQ,KAAK,IAAI,wBAAwB,CAAC;IAC1C,KAAK;AACL;IACA,IAAI,IAAI,eAAe,GAAG,sBAAsB,CAAC;IACjD,IAAIE,yBAAc,CAAC,YAAY,CAAC,oBAAoB,EAAEF,qBAAU,CAAC,IAAI,EAAE,CAAC,EAAE,eAAe,CAAC,CAAC,CAAC,CAAC,CAAC;IAC9F,IAAIE,yBAAc,CAAC,YAAY,CAAC,iBAAiB,EAAEF,qBAAU,CAAC,IAAI,EAAE,CAAC,EAAE,eAAe,CAAC,CAAC,CAAC,CAAC,CAAC;IAC3F,IAAI,IAAI,cAAc,GAAGE,yBAAc,CAAC,mBAAmB,CAAC,eAAe,CAAC,CAAC;AAC7E;IACA;IACA,IAAI,cAAc,CAAC,MAAM,IAAI,UAAU,IAAI,YAAY,GAAG,GAAG,CAAC,CAAC;AAC/D;IACA,IAAI,IAAI,UAAU,GAAG;IACrB,QAAQ,QAAQ,EAAE,IAAIc,mCAAiB,CAAC;IACxC,YAAY,iBAAiB,EAAEC,mCAAiB,CAAC,MAAM;IACvD,YAAY,sBAAsB,EAAE,CAAC;IACrC,YAAY,SAAS,EAAE,KAAK;IAC5B,YAAY,MAAM,EAAE,cAAc;IAClC,SAAS,CAAC;IACV,QAAQ,wBAAwB,EAAE,wBAAwB,CAAC,wBAAwB,CAAC;IACpF,QAAQ,wBAAwB,EAAE,wBAAwB,CAAC,wBAAwB,CAAC;IACpF,QAAQ,4BAA4B,EAAE,wBAAwB,CAAC,4BAA4B,CAAC;IAC5F,QAAQ,2CAA2C,EAAE,wBAAwB,CAAC,2CAA2C,CAAC;IAC1H,QAAQ,6CAA6C,EAAE,wBAAwB,CAAC,6CAA6C,CAAC;IAC9H,KAAK,CAAC;AACN;IACA,IAAI,IAAI,mBAAmB,EAAE;IAC7B,QAAQ,UAAU,CAAC,WAAW,GAAG,wBAAwB,CAAC,WAAW,CAAC,CAAC;IACvE,QAAQ,UAAU,CAAC,gBAAgB,GAAG,wBAAwB,CAAC,gBAAgB,CAAC,CAAC;IACjF,QAAQ,UAAU,CAAC,iBAAiB,GAAG,wBAAwB,CAAC,iBAAiB,CAAC,CAAC;IACnF,QAAQ,UAAU,CAAC,uBAAuB,GAAG,IAAID,mCAAiB,CAAC;IACnE,YAAY,iBAAiB,EAAEC,mCAAiB,CAAC,KAAK;IACtD,YAAY,sBAAsB,EAAE,CAAC;IACrC,YAAY,SAAS,EAAE,KAAK;IAC5B,YAAY,MAAM,EAAE,uBAAuB;IAC3C,SAAS,CAAC,CAAC;IACX,KAAK;AACL;IACA,IAAI,OAAO,IAAIC,0BAAQ,CAAC;IACxB,QAAQ,UAAU,EAAE,UAAU;IAC9B,QAAQ,OAAO,EAAE,OAAO;IACxB,QAAQ,cAAc,EAAE,cAAc;IACtC,KAAK,CAAC,CAAC;IACP,CAAC;AACD;IACA,SAAS,wBAAwB,CAAC,UAAU,EAAE;IAC9C,IAAI,OAAO,IAAIF,mCAAiB,CAAC;IACjC,QAAQ,iBAAiB,EAAEC,mCAAiB,CAAC,KAAK;IAClD,QAAQ,sBAAsB,EAAE,CAAC;IACjC,QAAQ,SAAS,EAAE,KAAK;IACxB,QAAQ,MAAM,EAAE,UAAU;IAC1B,KAAK,CAAC,CAAC;IACP,CAAC;AACD;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA,sBAAsB,CAAC,cAAc,GAAG,aAAa;;IChrCrD,SAAS,4BAA4B,CAAC,sBAAsB,EAAE,MAAM,EAAE;IACtE,IAAI,OAAO,yBAAyB,CAAC,UAAU,EAAE,CAAC,IAAI,CAAC,YAAY;IACnE,QAAQ,IAAInB,YAAO,CAAC,MAAM,CAAC,EAAE;IAC7B,YAAY,sBAAsB,GAAG,sBAAsB,CAAC,MAAM,CAAC,sBAAsB,EAAE,MAAM,CAAC,CAAC;IACnG,SAAS;IACT,QAAQ,OAAO,sBAAsB,CAAC,cAAc,CAAC,sBAAsB,CAAC,CAAC;IAC7E,KAAK,CAAC,CAAC;IACP;;;;;;;;"}