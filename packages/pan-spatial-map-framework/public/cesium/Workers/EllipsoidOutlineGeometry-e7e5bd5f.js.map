{"version":3,"file":"EllipsoidOutlineGeometry-e7e5bd5f.js","sources":["../../../../Source/Core/EllipsoidOutlineGeometry.js"],"sourcesContent":["import arrayFill from './arrayFill.js';\r\nimport BoundingSphere from './BoundingSphere.js';\r\nimport Cartesian3 from './Cartesian3.js';\r\nimport ComponentDatatype from './ComponentDatatype.js';\r\nimport defaultValue from './defaultValue.js';\r\nimport defined from './defined.js';\r\nimport DeveloperError from './DeveloperError.js';\r\nimport Ellipsoid from './Ellipsoid.js';\r\nimport Geometry from './Geometry.js';\r\nimport GeometryAttribute from './GeometryAttribute.js';\r\nimport GeometryAttributes from './GeometryAttributes.js';\r\nimport GeometryOffsetAttribute from './GeometryOffsetAttribute.js';\r\nimport IndexDatatype from './IndexDatatype.js';\r\nimport CesiumMath from './Math.js';\r\nimport PrimitiveType from './PrimitiveType.js';\r\n\r\nvar defaultRadii = new Cartesian3(1.0, 1.0, 1.0);\r\nvar cos = Math.cos;\r\nvar sin = Math.sin;\r\n\r\n/**\r\n * A description of the outline of an ellipsoid centered at the origin.\r\n *\r\n * @alias EllipsoidOutlineGeometry\r\n * @constructor\r\n *\r\n * @param {Object} [options] Object with the following properties:\r\n * @param {Cartesian3} [options.radii=Cartesian3(1.0, 1.0, 1.0)] The radii of the ellipsoid in the x, y, and z directions.\r\n * @param {Cartesian3} [options.innerRadii=options.radii] The inner radii of the ellipsoid in the x, y, and z directions.\r\n * @param {Number} [options.minimumClock=0.0] The minimum angle lying in the xy-plane measured from the positive x-axis and toward the positive y-axis.\r\n * @param {Number} [options.maximumClock=2*PI] The maximum angle lying in the xy-plane measured from the positive x-axis and toward the positive y-axis.\r\n * @param {Number} [options.minimumCone=0.0] The minimum angle measured from the positive z-axis and toward the negative z-axis.\r\n * @param {Number} [options.maximumCone=PI] The maximum angle measured from the positive z-axis and toward the negative z-axis.\r\n * @param {Number} [options.stackPartitions=10] The count of stacks for the ellipsoid (1 greater than the number of parallel lines).\r\n * @param {Number} [options.slicePartitions=8] The count of slices for the ellipsoid (Equal to the number of radial lines).\r\n * @param {Number} [options.subdivisions=128] The number of points per line, determining the granularity of the curvature.\r\n *\r\n * @exception {DeveloperError} options.stackPartitions must be greater than or equal to one.\r\n * @exception {DeveloperError} options.slicePartitions must be greater than or equal to zero.\r\n * @exception {DeveloperError} options.subdivisions must be greater than or equal to zero.\r\n *\r\n * @example\r\n * var ellipsoid = new Cesium.EllipsoidOutlineGeometry({\r\n *   radii : new Cesium.Cartesian3(1000000.0, 500000.0, 500000.0),\r\n *   stackPartitions: 6,\r\n *   slicePartitions: 5\r\n * });\r\n * var geometry = Cesium.EllipsoidOutlineGeometry.createGeometry(ellipsoid);\r\n */\r\nfunction EllipsoidOutlineGeometry(options) {\r\n    options = defaultValue(options, defaultValue.EMPTY_OBJECT);\r\n\r\n    var radii = defaultValue(options.radii, defaultRadii);\r\n    var innerRadii = defaultValue(options.innerRadii, radii);\r\n    var minimumClock = defaultValue(options.minimumClock, 0.0);\r\n    var maximumClock = defaultValue(options.maximumClock, CesiumMath.TWO_PI);\r\n    var minimumCone = defaultValue(options.minimumCone, 0.0);\r\n    var maximumCone = defaultValue(options.maximumCone, CesiumMath.PI);\r\n    var stackPartitions = Math.round(defaultValue(options.stackPartitions, 10));\r\n    var slicePartitions = Math.round(defaultValue(options.slicePartitions, 8));\r\n    var subdivisions = Math.round(defaultValue(options.subdivisions, 128));\r\n\r\n    //>>includeStart('debug', pragmas.debug);\r\n    if (stackPartitions < 1) {\r\n        throw new DeveloperError('options.stackPartitions cannot be less than 1');\r\n    }\r\n    if (slicePartitions < 0) {\r\n        throw new DeveloperError('options.slicePartitions cannot be less than 0');\r\n    }\r\n    if (subdivisions < 0) {\r\n        throw new DeveloperError('options.subdivisions must be greater than or equal to zero.');\r\n    }\r\n    if (defined(options.offsetAttribute) && options.offsetAttribute === GeometryOffsetAttribute.TOP) {\r\n        throw new DeveloperError('GeometryOffsetAttribute.TOP is not a supported options.offsetAttribute for this geometry.');\r\n    }\r\n    //>>includeEnd('debug');\r\n\r\n    this._radii = Cartesian3.clone(radii);\r\n    this._innerRadii = Cartesian3.clone(innerRadii);\r\n    this._minimumClock = minimumClock;\r\n    this._maximumClock = maximumClock;\r\n    this._minimumCone = minimumCone;\r\n    this._maximumCone = maximumCone;\r\n    this._stackPartitions = stackPartitions;\r\n    this._slicePartitions = slicePartitions;\r\n    this._subdivisions = subdivisions;\r\n    this._offsetAttribute = options.offsetAttribute;\r\n    this._workerName = 'createEllipsoidOutlineGeometry';\r\n}\r\n\r\n/**\r\n * The number of elements used to pack the object into an array.\r\n * @type {Number}\r\n */\r\nEllipsoidOutlineGeometry.packedLength = 2 * Cartesian3.packedLength + 8;\r\n\r\n/**\r\n * Stores the provided instance into the provided array.\r\n *\r\n * @param {EllipsoidOutlineGeometry} value The value to pack.\r\n * @param {Number[]} array The array to pack into.\r\n * @param {Number} [startingIndex=0] The index into the array at which to start packing the elements.\r\n *\r\n * @returns {Number[]} The array that was packed into\r\n */\r\nEllipsoidOutlineGeometry.pack = function (value, array, startingIndex) {\r\n    //>>includeStart('debug', pragmas.debug);\r\n    if (!defined(value)) {\r\n        throw new DeveloperError('value is required');\r\n    }\r\n    if (!defined(array)) {\r\n        throw new DeveloperError('array is required');\r\n    }\r\n    //>>includeEnd('debug');\r\n\r\n    startingIndex = defaultValue(startingIndex, 0);\r\n\r\n    Cartesian3.pack(value._radii, array, startingIndex);\r\n    startingIndex += Cartesian3.packedLength;\r\n\r\n    Cartesian3.pack(value._innerRadii, array, startingIndex);\r\n    startingIndex += Cartesian3.packedLength;\r\n\r\n    array[startingIndex++] = value._minimumClock;\r\n    array[startingIndex++] = value._maximumClock;\r\n    array[startingIndex++] = value._minimumCone;\r\n    array[startingIndex++] = value._maximumCone;\r\n    array[startingIndex++] = value._stackPartitions;\r\n    array[startingIndex++] = value._slicePartitions;\r\n    array[startingIndex++] = value._subdivisions;\r\n    array[startingIndex] = defaultValue(value._offsetAttribute, -1);\r\n\r\n    return array;\r\n};\r\n\r\nvar scratchRadii = new Cartesian3();\r\nvar scratchInnerRadii = new Cartesian3();\r\nvar scratchOptions = {\r\n    radii: scratchRadii,\r\n    innerRadii: scratchInnerRadii,\r\n    minimumClock: undefined,\r\n    maximumClock: undefined,\r\n    minimumCone: undefined,\r\n    maximumCone: undefined,\r\n    stackPartitions: undefined,\r\n    slicePartitions: undefined,\r\n    subdivisions: undefined,\r\n    offsetAttribute: undefined\r\n};\r\n\r\n/**\r\n * Retrieves an instance from a packed array.\r\n *\r\n * @param {Number[]} array The packed array.\r\n * @param {Number} [startingIndex=0] The starting index of the element to be unpacked.\r\n * @param {EllipsoidOutlineGeometry} [result] The object into which to store the result.\r\n * @returns {EllipsoidOutlineGeometry} The modified result parameter or a new EllipsoidOutlineGeometry instance if one was not provided.\r\n */\r\nEllipsoidOutlineGeometry.unpack = function (array, startingIndex, result) {\r\n    //>>includeStart('debug', pragmas.debug);\r\n    if (!defined(array)) {\r\n        throw new DeveloperError('array is required');\r\n    }\r\n    //>>includeEnd('debug');\r\n\r\n    startingIndex = defaultValue(startingIndex, 0);\r\n\r\n    var radii = Cartesian3.unpack(array, startingIndex, scratchRadii);\r\n    startingIndex += Cartesian3.packedLength;\r\n\r\n    var innerRadii = Cartesian3.unpack(array, startingIndex, scratchInnerRadii);\r\n    startingIndex += Cartesian3.packedLength;\r\n\r\n    var minimumClock = array[startingIndex++];\r\n    var maximumClock = array[startingIndex++];\r\n    var minimumCone = array[startingIndex++];\r\n    var maximumCone = array[startingIndex++];\r\n    var stackPartitions = array[startingIndex++];\r\n    var slicePartitions = array[startingIndex++];\r\n    var subdivisions = array[startingIndex++];\r\n    var offsetAttribute = array[startingIndex];\r\n\r\n    if (!defined(result)) {\r\n        scratchOptions.minimumClock = minimumClock;\r\n        scratchOptions.maximumClock = maximumClock;\r\n        scratchOptions.minimumCone = minimumCone;\r\n        scratchOptions.maximumCone = maximumCone;\r\n        scratchOptions.stackPartitions = stackPartitions;\r\n        scratchOptions.slicePartitions = slicePartitions;\r\n        scratchOptions.subdivisions = subdivisions;\r\n        scratchOptions.offsetAttribute = offsetAttribute === -1 ? undefined : offsetAttribute;\r\n        return new EllipsoidOutlineGeometry(scratchOptions);\r\n    }\r\n\r\n    result._radii = Cartesian3.clone(radii, result._radii);\r\n    result._innerRadii = Cartesian3.clone(innerRadii, result._innerRadii);\r\n    result._minimumClock = minimumClock;\r\n    result._maximumClock = maximumClock;\r\n    result._minimumCone = minimumCone;\r\n    result._maximumCone = maximumCone;\r\n    result._stackPartitions = stackPartitions;\r\n    result._slicePartitions = slicePartitions;\r\n    result._subdivisions = subdivisions;\r\n    result._offsetAttribute = offsetAttribute === -1 ? undefined : offsetAttribute;\r\n\r\n    return result;\r\n};\r\n\r\n/**\r\n * Computes the geometric representation of an outline of an ellipsoid, including its vertices, indices, and a bounding sphere.\r\n *\r\n * @param {EllipsoidOutlineGeometry} ellipsoidGeometry A description of the ellipsoid outline.\r\n * @returns {Geometry|undefined} The computed vertices and indices.\r\n */\r\nEllipsoidOutlineGeometry.createGeometry = function (ellipsoidGeometry) {\r\n    var radii = ellipsoidGeometry._radii;\r\n    if (radii.x <= 0 || radii.y <= 0 || radii.z <= 0) {\r\n        return;\r\n    }\r\n\r\n    var innerRadii = ellipsoidGeometry._innerRadii;\r\n    if (innerRadii.x <= 0 || innerRadii.y <= 0 || innerRadii.z <= 0) {\r\n        return;\r\n    }\r\n\r\n    var minimumClock = ellipsoidGeometry._minimumClock;\r\n    var maximumClock = ellipsoidGeometry._maximumClock;\r\n    var minimumCone = ellipsoidGeometry._minimumCone;\r\n    var maximumCone = ellipsoidGeometry._maximumCone;\r\n    var subdivisions = ellipsoidGeometry._subdivisions;\r\n    var ellipsoid = Ellipsoid.fromCartesian3(radii);\r\n\r\n    // Add an extra slice and stack to remain consistent with EllipsoidGeometry\r\n    var slicePartitions = ellipsoidGeometry._slicePartitions + 1;\r\n    var stackPartitions = ellipsoidGeometry._stackPartitions + 1;\r\n\r\n    slicePartitions = Math.round((slicePartitions * Math.abs(maximumClock - minimumClock)) / CesiumMath.TWO_PI);\r\n    stackPartitions = Math.round((stackPartitions * Math.abs(maximumCone - minimumCone)) / CesiumMath.PI);\r\n\r\n    if (slicePartitions < 2) {\r\n        slicePartitions = 2;\r\n    }\r\n    if (stackPartitions < 2) {\r\n        stackPartitions = 2;\r\n    }\r\n\r\n    var extraIndices = 0;\r\n    var vertexMultiplier = 1.0;\r\n    var hasInnerSurface = innerRadii.x !== radii.x || innerRadii.y !== radii.y || innerRadii.z !== radii.z;\r\n    var isTopOpen = false;\r\n    var isBotOpen = false;\r\n    if (hasInnerSurface) {\r\n        vertexMultiplier = 2.0;\r\n        // Add 2x slicePartitions to connect the top/bottom of the outer to\r\n        // the top/bottom of the inner\r\n        if (minimumCone > 0.0) {\r\n            isTopOpen = true;\r\n            extraIndices += slicePartitions;\r\n        }\r\n        if (maximumCone < Math.PI) {\r\n            isBotOpen = true;\r\n            extraIndices += slicePartitions;\r\n        }\r\n    }\r\n\r\n    var vertexCount = subdivisions * vertexMultiplier * (stackPartitions + slicePartitions);\r\n    var positions = new Float64Array(vertexCount * 3);\r\n\r\n    // Multiply by two because two points define each line segment\r\n    var numIndices = 2 * (vertexCount + extraIndices - (slicePartitions + stackPartitions) * vertexMultiplier);\r\n    var indices = IndexDatatype.createTypedArray(vertexCount, numIndices);\r\n\r\n    var i;\r\n    var j;\r\n    var theta;\r\n    var phi;\r\n    var index = 0;\r\n\r\n    // Calculate sin/cos phi\r\n    var sinPhi = new Array(stackPartitions);\r\n    var cosPhi = new Array(stackPartitions);\r\n    for (i = 0; i < stackPartitions; i++) {\r\n        phi = minimumCone + (i * (maximumCone - minimumCone)) / (stackPartitions - 1);\r\n        sinPhi[i] = sin(phi);\r\n        cosPhi[i] = cos(phi);\r\n    }\r\n\r\n    // Calculate sin/cos theta\r\n    var sinTheta = new Array(subdivisions);\r\n    var cosTheta = new Array(subdivisions);\r\n    for (i = 0; i < subdivisions; i++) {\r\n        theta = minimumClock + (i * (maximumClock - minimumClock)) / (subdivisions - 1);\r\n        sinTheta[i] = sin(theta);\r\n        cosTheta[i] = cos(theta);\r\n    }\r\n\r\n    // Calculate the latitude lines on the outer surface\r\n    for (i = 0; i < stackPartitions; i++) {\r\n        for (j = 0; j < subdivisions; j++) {\r\n            positions[index++] = radii.x * sinPhi[i] * cosTheta[j];\r\n            positions[index++] = radii.y * sinPhi[i] * sinTheta[j];\r\n            positions[index++] = radii.z * cosPhi[i];\r\n        }\r\n    }\r\n\r\n    // Calculate the latitude lines on the inner surface\r\n    if (hasInnerSurface) {\r\n        for (i = 0; i < stackPartitions; i++) {\r\n            for (j = 0; j < subdivisions; j++) {\r\n                positions[index++] = innerRadii.x * sinPhi[i] * cosTheta[j];\r\n                positions[index++] = innerRadii.y * sinPhi[i] * sinTheta[j];\r\n                positions[index++] = innerRadii.z * cosPhi[i];\r\n            }\r\n        }\r\n    }\r\n\r\n    // Calculate sin/cos phi\r\n    sinPhi.length = subdivisions;\r\n    cosPhi.length = subdivisions;\r\n    for (i = 0; i < subdivisions; i++) {\r\n        phi = minimumCone + (i * (maximumCone - minimumCone)) / (subdivisions - 1);\r\n        sinPhi[i] = sin(phi);\r\n        cosPhi[i] = cos(phi);\r\n    }\r\n\r\n    // Calculate sin/cos theta for each slice partition\r\n    sinTheta.length = slicePartitions;\r\n    cosTheta.length = slicePartitions;\r\n    for (i = 0; i < slicePartitions; i++) {\r\n        theta = minimumClock + (i * (maximumClock - minimumClock)) / (slicePartitions - 1);\r\n        sinTheta[i] = sin(theta);\r\n        cosTheta[i] = cos(theta);\r\n    }\r\n\r\n    // Calculate the longitude lines on the outer surface\r\n    for (i = 0; i < subdivisions; i++) {\r\n        for (j = 0; j < slicePartitions; j++) {\r\n            positions[index++] = radii.x * sinPhi[i] * cosTheta[j];\r\n            positions[index++] = radii.y * sinPhi[i] * sinTheta[j];\r\n            positions[index++] = radii.z * cosPhi[i];\r\n        }\r\n    }\r\n\r\n    // Calculate the longitude lines on the inner surface\r\n    if (hasInnerSurface) {\r\n        for (i = 0; i < subdivisions; i++) {\r\n            for (j = 0; j < slicePartitions; j++) {\r\n                positions[index++] = innerRadii.x * sinPhi[i] * cosTheta[j];\r\n                positions[index++] = innerRadii.y * sinPhi[i] * sinTheta[j];\r\n                positions[index++] = innerRadii.z * cosPhi[i];\r\n            }\r\n        }\r\n    }\r\n\r\n    // Create indices for the latitude lines\r\n    index = 0;\r\n    for (i = 0; i < stackPartitions * vertexMultiplier; i++) {\r\n        var topOffset = i * subdivisions;\r\n        for (j = 0; j < subdivisions - 1; j++) {\r\n            indices[index++] = topOffset + j;\r\n            indices[index++] = topOffset + j + 1;\r\n        }\r\n    }\r\n\r\n    // Create indices for the outer longitude lines\r\n    var offset = stackPartitions * subdivisions * vertexMultiplier;\r\n    for (i = 0; i < slicePartitions; i++) {\r\n        for (j = 0; j < subdivisions - 1; j++) {\r\n            indices[index++] = offset + i + j * slicePartitions;\r\n            indices[index++] = offset + i + (j + 1) * slicePartitions;\r\n        }\r\n    }\r\n\r\n    // Create indices for the inner longitude lines\r\n    if (hasInnerSurface) {\r\n        offset = stackPartitions * subdivisions * vertexMultiplier + slicePartitions * subdivisions;\r\n        for (i = 0; i < slicePartitions; i++) {\r\n            for (j = 0; j < subdivisions - 1; j++) {\r\n                indices[index++] = offset + i + j * slicePartitions;\r\n                indices[index++] = offset + i + (j + 1) * slicePartitions;\r\n            }\r\n        }\r\n    }\r\n\r\n    if (hasInnerSurface) {\r\n        var outerOffset = stackPartitions * subdivisions * vertexMultiplier;\r\n        var innerOffset = outerOffset + subdivisions * slicePartitions;\r\n        if (isTopOpen) {\r\n            // Draw lines from the top of the inner surface to the top of the outer surface\r\n            for (i = 0; i < slicePartitions; i++) {\r\n                indices[index++] = outerOffset + i;\r\n                indices[index++] = innerOffset + i;\r\n            }\r\n        }\r\n\r\n        if (isBotOpen) {\r\n            // Draw lines from the top of the inner surface to the top of the outer surface\r\n            outerOffset += subdivisions * slicePartitions - slicePartitions;\r\n            innerOffset += subdivisions * slicePartitions - slicePartitions;\r\n            for (i = 0; i < slicePartitions; i++) {\r\n                indices[index++] = outerOffset + i;\r\n                indices[index++] = innerOffset + i;\r\n            }\r\n        }\r\n    }\r\n\r\n    var attributes = new GeometryAttributes({\r\n        position: new GeometryAttribute({\r\n            componentDatatype: ComponentDatatype.DOUBLE,\r\n            componentsPerAttribute: 3,\r\n            values: positions\r\n        })\r\n    });\r\n\r\n    if (defined(ellipsoidGeometry._offsetAttribute)) {\r\n        var length = positions.length;\r\n        var applyOffset = new Uint8Array(length / 3);\r\n        var offsetValue = ellipsoidGeometry._offsetAttribute === GeometryOffsetAttribute.NONE ? 0 : 1;\r\n        arrayFill(applyOffset, offsetValue);\r\n        attributes.applyOffset = new GeometryAttribute({\r\n            componentDatatype: ComponentDatatype.UNSIGNED_BYTE,\r\n            componentsPerAttribute: 1,\r\n            values: applyOffset\r\n        });\r\n    }\r\n\r\n    return new Geometry({\r\n        attributes: attributes,\r\n        indices: indices,\r\n        primitiveType: PrimitiveType.LINES,\r\n        boundingSphere: BoundingSphere.fromEllipsoid(ellipsoid),\r\n        offsetAttribute: ellipsoidGeometry._offsetAttribute\r\n    });\r\n};\r\nexport default EllipsoidOutlineGeometry;\r\n"],"names":["Cartesian3","defaultValue","CesiumMath","DeveloperError","defined","GeometryOffsetAttribute","Ellipsoid","IndexDatatype","GeometryAttributes","GeometryAttribute","ComponentDatatype","arrayFill","Geometry","PrimitiveType","BoundingSphere"],"mappings":"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"}